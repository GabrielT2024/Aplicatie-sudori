<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gestiune Sudori ‚Äì ASME Sec IX / ISCIR CR9-CR7</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#f4f6fb;
      --card:#ffffff;
      --card-border:#d8e0f2;
      --muted:#65708b;
      --text:#1f2a3d;
      --accent:#3a7afe;
      --accent-strong:#255ee9;
      --ok:#1a9b6f;
      --warn:#d28a00;
      --bad:#d94a4a;
      --table-alt:#f7f9ff;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:linear-gradient(180deg,#f8faff,#eef3fb 40%,var(--bg));
      color:var(--text);
      min-height:100vh;
    }
    body.auth-locked{ overflow:hidden; }
    .app-shell{
      display:flex;
      min-height:100vh;
      width:100%;
    }
    .sidebar{
      width:240px;
      background:linear-gradient(180deg,#4f5f7f 0%,#394763 55%,#2c364d 100%);
      color:#f4f8ff;
      display:flex;
      flex-direction:column;
      padding:28px 16px;
      gap:16px;
      box-shadow:inset -1px 0 0 rgba(255,255,255,.08);
    }
    .sidebar-header{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .sidebar-title{
      font-size:18px;
      font-weight:700;
      letter-spacing:.4px;
    }
    .sidebar-subtitle{
      font-size:12px;
      opacity:.8;
    }
    .sidebar-nav{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:16px;
    }
    .nav-button{
      appearance:none;
      border:none;
      border-radius:18px;
      padding:16px 12px;
      background:rgba(255,255,255,.06);
      color:inherit;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      font-weight:600;
      cursor:pointer;
      transition:background .2s, transform .2s, box-shadow .2s;
      text-align:center;
      min-height:84px;
    }
    .nav-button .icon{
      font-size:28px;
      width:32px;
      height:32px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
      background:rgba(0,0,0,.08);
      box-shadow:inset 0 2px 4px rgba(0,0,0,.18);
    }
    .nav-button span:last-child{
      font-size:12px;
      line-height:1.3;
      letter-spacing:.3px;
    }
    .nav-button:hover{
      background:rgba(255,255,255,.16);
      transform:translateY(-1px);
      box-shadow:0 8px 18px rgba(0,0,0,.22);
    }
    .nav-button.active{
      background:rgba(255,255,255,.28);
      color:#fff;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.35), 0 10px 22px rgba(15,35,68,.32);
    }
    .nav-button.active .icon{
      background:rgba(255,255,255,.22);
      box-shadow:inset 0 2px 4px rgba(255,255,255,.45);
    }
    .sidebar-footer{
      margin-top:auto;
      font-size:11px;
      opacity:.7;
      line-height:1.4;
    }
    .workspace{
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:100vh;
    }
    .topbar{ 
      padding:18px 24px;
      border-bottom:1px solid var(--card-border);
      background:rgba(255,255,255,.9);
      backdrop-filter:saturate(140%) blur(8px);
      display:flex;
      gap:18px;
      align-items:center;
      z-index:10;
      box-shadow:0 6px 18px rgba(32,56,104,.08);
      position:sticky;
      top:0;
    }
    .topbar h1{ font-size:18px; margin:0; letter-spacing:.3px; color:var(--text); }
    .topbar-brand{ display:flex; align-items:center; gap:14px; }
    .company-logo{
      max-width:140px;
      max-height:80px;
      width:auto;
      height:auto;
      border-radius:16px;
      object-fit:contain;
      border:1px solid rgba(37,94,233,.18);
      background:#fff;
      padding:6px;
      display:none;
    }
    .company-logo.visible{ display:block; }
    .topbar .pill{
      font-size:12px;
      padding:4px 10px;
      border-radius:999px;
      background:#e7ecfb;
      color:#255ee9;
      border:1px solid #c9d5f7;
    }
    .topbar .pill.version{
      background:#255ee9;
      color:#fff;
      border-color:#1f4dc9;
      box-shadow:0 6px 16px rgba(37,94,233,.22);
    }
    .topbar .title-stack{ display:flex; flex-direction:column; gap:6px; }
    .topbar .title-meta{ display:flex; flex-wrap:wrap; gap:6px; }
    .topbar-actions{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn.icon-leading{ display:inline-flex; align-items:center; gap:6px; }
    .btn.icon-leading .emoji{ font-size:16px; }
    .sidebar-reports{ display:flex; flex-direction:column; gap:10px; margin-top:8px; }
    .sidebar-reports .nav-button{ width:100%; }
    .company-select{ display:flex; flex-direction:column; gap:4px; font-size:12px; color:var(--muted); }
    .company-select select{ min-width:200px; }
    main{ flex:1; padding:24px 32px 32px; }
    .content-inner{ width:100%; display:flex; flex-direction:column; gap:28px; }
    .view{ display:none; }
    .view.active{ display:block; }
    .hidden{ display:none !important; }

    .selection-hub{ display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:18px; }
    .selection-card{ border:1px solid rgba(255,255,255,.18); border-radius:18px; padding:24px; background:linear-gradient(145deg, rgba(255,255,255,.75), rgba(231,237,255,.85)); box-shadow:0 14px 28px rgba(35,56,104,.12); display:flex; flex-direction:column; align-items:flex-start; gap:12px; cursor:pointer; transition:transform .2s, box-shadow .2s; position:relative; overflow:hidden; }
    .selection-card::after{ content:''; position:absolute; inset:0; pointer-events:none; border-radius:inherit; background:linear-gradient(160deg, rgba(58,122,254,.18), transparent 55%); opacity:0; transition:opacity .2s; }
    .selection-card:hover{ transform:translateY(-4px); box-shadow:0 18px 36px rgba(35,56,104,.16); }
    .selection-card:hover::after{ opacity:1; }
    .selection-card .icon{ width:56px; height:56px; border-radius:16px; background:rgba(58,122,254,.12); display:flex; align-items:center; justify-content:center; font-size:26px; color:#255ee9; box-shadow:inset 0 2px 6px rgba(37,94,233,.18); }
    .selection-card h3{ margin:0; font-size:18px; letter-spacing:.2px; }
    .selection-card p{ margin:0; font-size:13px; color:#6f7c99; }

    .subview-header{ display:flex; align-items:center; gap:12px; margin-bottom:18px; flex-wrap:wrap; }
    .subview-header h2{ margin:0; flex:1; font-size:20px; letter-spacing:.2px; }
    .back-link{ appearance:none; border:none; background:none; color:#3a7afe; font-weight:600; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:13px; padding:6px 10px; border-radius:12px; transition:background .2s; }
    .back-link:hover{ background:rgba(58,122,254,.12); }

    .welder-table-tools{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:16px; }
    .welder-table-tools .search-box{ flex:1 1 220px; }
    .welder-table-tools .actions{ display:flex; gap:10px; }

    .welder-overview table{ width:100%; border-collapse:collapse; }
    .welder-overview thead th{ background:#ecf1ff; color:#2b3b63; font-size:12px; letter-spacing:.2px; text-transform:uppercase; padding:12px; border-bottom:1px solid #d8e0f2; }
    .welder-overview tbody td{ padding:12px; border-bottom:1px solid #e3e9f8; font-size:13px; vertical-align:top; }
    .welder-overview tbody tr:nth-child(odd){ background:#f7f9ff; }
    .welder-overview tbody tr.selected{ background:#e0e8ff !important; box-shadow:inset 0 0 0 2px rgba(58,122,254,.35); }
    .welder-name-link{ color:#255ee9; font-weight:600; text-decoration:none; }
    .welder-name-link:hover{ text-decoration:underline; }
    .qualifications-summary{ display:flex; flex-wrap:wrap; gap:8px; }
    .process-summary{ display:flex; flex-wrap:wrap; gap:8px; }
    .process-chip{ background:#f1f4ff; color:#2f55d4; border-radius:999px; padding:4px 10px; font-size:11px; font-weight:600; letter-spacing:.3px; }
    .status-chip{ border-radius:999px; padding:4px 10px; font-size:11px; font-weight:600; letter-spacing:.3px; display:inline-flex; align-items:center; gap:6px; }
    .status-chip.ok{ background:rgba(26,155,111,.12); color:#137953; border:1px solid rgba(26,155,111,.4); }
    .status-chip.warn{ background:rgba(210,138,0,.14); color:#985b00; border:1px solid rgba(210,138,0,.38); }
    .status-chip.bad{ background:rgba(217,74,74,.14); color:#a52a2a; border:1px solid rgba(217,74,74,.38); }
    .status-chip .dot{ width:8px; height:8px; border-radius:50%; background:currentColor; opacity:.55; }

    .modal{ position:fixed; inset:0; background:rgba(19,28,49,.58); display:none; align-items:center; justify-content:center; padding:32px; z-index:1000; }
    .modal.open{ display:flex; }
    .modal-dialog{ background:#ffffff; border-radius:20px; width:min(820px, 96vw); max-height:94vh; overflow-y:auto; box-shadow:0 24px 48px rgba(18,32,68,.28); position:relative; padding:28px 32px; }
    .modal-close{ position:absolute; top:16px; right:16px; border:none; background:rgba(58,122,254,.1); color:#2b3b63; width:32px; height:32px; border-radius:999px; cursor:pointer; font-size:18px; font-weight:700; display:flex; align-items:center; justify-content:center; }
    .modal-close:hover{ background:rgba(58,122,254,.2); }
    .modal-dialog h2{ margin-top:0; }

    .auth-overlay{ position:fixed; inset:0; background:rgba(17,26,44,.82); display:flex; align-items:center; justify-content:center; padding:32px; z-index:2000; }
    .auth-overlay.hidden{ display:none; }
    .auth-card{ width:min(420px, 92vw); background:#fdfdff; border-radius:22px; padding:32px; box-shadow:0 32px 64px rgba(9,18,38,.45); display:flex; flex-direction:column; gap:18px; }
    .auth-card h2{ margin:0; font-size:22px; letter-spacing:.4px; color:#1e2b46; }
    .auth-card p{ margin:0; font-size:13px; color:#5f6c87; }
    .auth-card form{ display:flex; flex-direction:column; gap:14px; }
    .auth-card label{ font-size:12px; font-weight:600; color:#1e2b46; letter-spacing:.3px; }
    .auth-card input{ width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(48,68,112,.2); font-size:14px; }
    .auth-card button{ appearance:none; border:none; border-radius:14px; padding:12px 16px; background:#3a7afe; color:#fff; font-weight:600; font-size:14px; cursor:pointer; box-shadow:0 12px 24px rgba(58,122,254,.32); transition:background .2s, transform .2s; }
    .auth-card button:hover{ background:#255ee9; transform:translateY(-1px); }
    .auth-error{ background:rgba(217,74,74,.12); color:#a52a2a; border:1px solid rgba(217,74,74,.28); padding:10px 12px; border-radius:12px; font-size:12px; display:none; }
    .auth-error.visible{ display:block; }
    .auth-notice{ font-size:12px; color:#f7f9ff; background:rgba(37,94,233,.25); border:1px solid rgba(58,122,254,.35); padding:10px 12px; border-radius:12px; display:none; }
    .auth-notice.visible{ display:block; }

    .icon-button{ appearance:none; border:none; background:rgba(58,122,254,.12); color:#255ee9; width:36px; height:36px; border-radius:999px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:background .2s, transform .2s; }
    .icon-button:hover{ background:rgba(58,122,254,.22); transform:translateY(-1px); }

    .dossier-phase-settings{ display:none; flex-direction:column; gap:14px; padding:14px; border:1px solid #dfe3f5; border-radius:12px; background:#f7f9ff; box-shadow:inset 0 1px 0 rgba(255,255,255,.6); margin-top:12px; }
    .dossier-phase-settings.open{ display:flex; }
    .dossier-phase-settings h5{ margin:0; font-size:13px; color:#223054; text-transform:uppercase; letter-spacing:.4px; }
    .dossier-phase-settings .settings-row{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; }
    .dossier-phase-settings .settings-row > div{ display:flex; flex-direction:column; gap:6px; }
    .dossier-phase-settings .settings-row input{ width:100%; }
    .checkbox-field{ display:flex; align-items:center; gap:8px; font-size:13px; color:#2f3f63; }
    .checkbox-field input{ width:auto; }
    .help-text{ font-size:12px; color:#7d89a5; margin:0; }

    .custom-step-list{ display:flex; flex-direction:column; gap:12px; }
    .custom-step{ border:1px solid #dfe3f5; border-radius:12px; padding:12px; background:#fff; display:flex; flex-direction:column; gap:10px; }
    .custom-step-header{ display:flex; flex-wrap:wrap; gap:8px; align-items:flex-start; justify-content:space-between; }
    .custom-step-titlewrap{ display:flex; flex-direction:column; gap:4px; }
    .custom-step-controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end; }
    .custom-step-header h5{ margin:0; font-size:14px; }
    .custom-step-header .meta{ font-size:12px; color:#5f6c87; }
    .custom-step-actions{ display:flex; gap:8px; flex-wrap:wrap; }
    .custom-step input[type="file"]{ max-width:280px; }
    .custom-step.step-excluded{ opacity:.55; }
    .custom-step.step-excluded .step-visibility .checkbox-field{ color:var(--bad); }
    .warning-text{ color:#d94a4a; font-weight:600; margin:8px 0 0; font-size:13px; }
    .opis-list{ list-style:none; padding:0; margin:16px 0 0; font-size:13px; }
    .opis-list li{ display:flex; align-items:flex-end; gap:12px; margin-bottom:6px; }
    .opis-list .opis-info{ flex:1; display:flex; flex-direction:column; gap:4px; }
    .opis-list .opis-label{ flex:1; display:flex; align-items:flex-end; font-weight:600; }
    .opis-list .opis-label span{ position:relative; z-index:1; padding-right:8px; background:#fff; }
    .opis-list .opis-label::after{ content:""; flex:1; border-bottom:1px dotted rgba(31,42,61,.35); margin:0 0 6px 12px; }
    .opis-list .opis-detail{ font-size:12px; color:var(--muted); margin-top:2px; }
    .opis-list .opis-page{ font-weight:600; min-width:110px; text-align:right; }
    .letter-body.formatted-letter{ font-size:13px; line-height:1.7; color:#1f2a3d; white-space:normal; }
    .letter-body.formatted-letter .letter-rows{ display:flex; flex-direction:column; gap:6px; margin-bottom:18px; }
    .letter-body.formatted-letter .letter-row{ display:flex; gap:18px; align-items:flex-start; }
    .letter-body.formatted-letter .letter-label{ min-width:150px; font-weight:700; }
    .letter-body.formatted-letter .letter-value{ flex:1; font-weight:400; }
    .letter-body.formatted-letter .letter-gap{ height:12px; }
    .letter-body.formatted-letter .letter-paragraphs{ display:flex; flex-direction:column; gap:12px; }
    .letter-body.formatted-letter .letter-paragraphs p{ margin:0; }
    .letter-body.formatted-letter .letter-signatures{ display:flex; flex-wrap:wrap; gap:48px; margin-top:48px; }
    .letter-body.formatted-letter .letter-signature-block{ flex:1; min-width:180px; display:flex; flex-direction:column; gap:6px; }
    .letter-body.formatted-letter .letter-signature-title{ font-weight:700; text-transform:uppercase; }
    .letter-body.formatted-letter .letter-signature-name{ font-weight:600; }

    .branding-row{ display:flex; flex-wrap:nowrap; gap:var(--branding-gap, 16px); align-items:flex-start; justify-content:space-between; }
    .branding-row .branding-block{ flex:1 1 0; min-width:0; display:flex; justify-content:flex-start; align-items:center; word-break:break-word; }
    .branding-row .branding-block.align-center{ justify-content:center; text-align:center; }
    .branding-row .branding-block.align-right{ justify-content:flex-end; text-align:right; }
    .branding-row .branding-block img{ max-height:64px; width:auto; max-width:100%; object-fit:contain; margin-inline:auto; }

    .branding-item .row-select{ width:72px; }

    .dossier-archive{ border-top:1px solid #dfe3f5; padding-top:16px; display:flex; flex-direction:column; gap:12px; }
    .dossier-archive table{ width:100%; border-collapse:collapse; }
    .dossier-archive th, .dossier-archive td{ padding:10px 12px; border-bottom:1px solid #e1e7f7; font-size:12px; text-align:left; }
    .dossier-archive thead th{ background:#eef2ff; font-weight:600; color:#2f3f63; }
    .dossier-archive-empty{ font-size:13px; color:#7d89a5; margin:0; }

    .grid{ display:grid; grid-template-columns:minmax(320px, 360px) 1fr; gap:24px; align-items:start; }
    .form-row{ display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:16px; margin-bottom:16px; }
    .form-row:last-of-type{ margin-bottom:0; }
    .attachment-preview{ display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted); margin-top:8px; align-items:flex-start; }
    .attachment-preview .btn{ font-size:12px; }
    .attachment-preview .attachment-meta-note{ font-size:11px; color:#5c678a; }
    .attachment-preview img{ width:120px; height:120px; object-fit:cover; border-radius:12px; border:1px solid var(--card-border); }
    .attachment-expiry{ margin-top:6px; display:flex; align-items:center; gap:8px; font-size:12px; color:#5c678a; }
    .attachment-expiry label{ margin:0; font-size:12px; color:#5c678a; }
    .attachment-expiry input{ width:auto; min-width:160px; padding:6px 8px; border-radius:8px; font-size:12px; }
    .tag-secondary{ background:#f0f3ff; color:#3a7afe; border:1px solid #c9d5f7; padding:2px 8px; border-radius:999px; font-size:11px; display:inline-flex; align-items:center; gap:4px; }
    .attachment-actions{ display:flex; gap:8px; flex-wrap:wrap; }
    .panson-card-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .panson-meta{ font-size:12px; color:var(--muted); }
    .panson-archive-toggle{ width:100%; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .panson-archive-toggle::after{ content:'‚ñæ'; font-size:14px; color:var(--muted); transition:transform .2s ease; }
    .panson-archive-toggle[aria-expanded="true"]::after{ transform:rotate(180deg); }
    .auth-standard-tabs{ display:flex; border-bottom:2px solid #2f55d4; margin-bottom:18px; flex-wrap:wrap; gap:6px; }
    .auth-standard-tabs button{ appearance:none; border:none; background:none; padding:10px 18px; font-weight:600; color:var(--muted); cursor:pointer; position:relative; border-radius:12px 12px 0 0; }
    .auth-standard-tabs button::after{ content:''; position:absolute; left:0; right:0; bottom:-2px; height:2px; background:transparent; transition:background .2s; border-radius:999px; }
    .auth-standard-tabs button.active{ color:var(--accent-strong); }
    .auth-standard-tabs button.active::after{ background:var(--accent-strong); }
    .auth-context{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin-bottom:16px; }
    .auth-context .tag{ font-size:12px; }
    .divider{ height:1px; background:var(--card-border); margin:18px 0; }
    .report-actions{ display:flex; flex-wrap:wrap; gap:12px; }
    .branding-section{ border:1px solid var(--card-border); border-radius:14px; padding:16px; margin-bottom:18px; background:rgba(255,255,255,.85); box-shadow:inset 0 1px 0 rgba(255,255,255,.4); }
    .branding-section h3{ margin:0 0 8px; font-size:16px; color:var(--text); }
    .branding-section p{ margin:0 0 12px; }
    .welding-log-section{ border:1px solid #dfe3f5; border-radius:12px; padding:16px; background:#f9fbff; display:flex; flex-direction:column; gap:12px; }
    .welding-log-section h3{ margin:0; font-size:16px; color:#223054; }
    .welding-log-meta{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; }
    .welding-log-meta label{ font-size:12px; font-weight:600; color:#2f3f63; }
    .welding-log-meta input{ padding:10px 12px; border-radius:10px; border:1px solid #d0d7eb; font-size:13px; }
    .welding-log-table{ width:100%; border-collapse:collapse; }
    .welding-log-table thead th{ background:#ecf1ff; color:#2b3b63; font-size:11px; letter-spacing:.3px; text-transform:uppercase; padding:8px; border-bottom:1px solid #d8e0f2; }
    .welding-log-table tbody td{ padding:6px; border-bottom:1px solid #e5ebfa; }
    .welding-log-table tbody tr:nth-child(odd){ background:#f7f9ff; }
    .welding-log-table input, .welding-log-table textarea{ width:100%; padding:8px; border-radius:8px; border:1px solid #cfd7ee; font-size:12px; }
    .welding-log-table textarea{ resize:vertical; min-height:36px; }
    .welding-log-actions{ display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    .welding-log-options{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
    .welding-log-options .checkbox-field{ margin:0; font-size:13px; color:#2f3f63; }
    .welding-log-options .btn{ margin-left:auto; }
    .table-scroll{ overflow-x:auto; }
    .welding-log-table td:last-child, .welding-log-table th:last-child{ text-align:center; min-width:70px; }
    .welding-log-print .muted{ color:var(--muted); font-size:12px; }
    .welding-log-print-header{ display:flex; flex-direction:column; gap:4px; font-size:13px; margin-bottom:8px; }
    .welding-log-print-table{ width:100%; border-collapse:collapse; margin-top:12px; font-size:12px; }
    .welding-log-print-table th, .welding-log-print-table td{ border:1px solid #d8e0f2; padding:6px; text-align:left; vertical-align:top; }
    .welding-log-print-table thead th{ background:#ecf1ff; font-weight:600; }
    .branding-list{ display:flex; flex-direction:column; gap:8px; margin-bottom:12px; }
    .branding-item{ display:flex; justify-content:space-between; align-items:flex-start; gap:12px; padding:10px 12px; border:1px solid var(--card-border); border-radius:10px; background:linear-gradient(180deg,#f8f9ff 0%,#eef2ff 100%); }
    .branding-item .meta{ display:flex; flex-direction:column; gap:4px; font-size:13px; color:var(--text); }
    .branding-item .meta .label{ font-weight:600; font-size:14px; }
    .branding-item .actions{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .branding-preview{ max-height:48px; max-width:140px; object-fit:contain; border-radius:8px; border:1px solid var(--card-border); background:#fff; padding:4px; }
    .branding-controls{ display:flex; flex-wrap:wrap; gap:10px; }
    .branding-controls .btn{ font-size:13px; }
    .branding-spacing-control{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; font-size:12px; color:var(--muted); margin-top:8px; }
    .branding-spacing-control input{ width:90px; }
    .subtabs{ display:flex; gap:8px; border-bottom:1px solid #d8e0f2; margin-bottom:18px; flex-wrap:wrap; }
    .subtabs button{ appearance:none; border:none; background:#eef2ff; color:#42507a; padding:10px 18px; border-radius:12px 12px 0 0; font-weight:600; cursor:pointer; box-shadow:inset 0 -1px 0 rgba(37,94,233,.25); }
    .subtabs button.active{ background:#fff; color:var(--accent-strong); box-shadow:0 -2px 10px rgba(37,94,233,.12); }
    .subtabs.compact{ gap:6px; margin-bottom:12px; }
    .subtabs.compact button{ padding:8px 14px; font-size:12px; border-radius:10px 10px 0 0; }
    .subtab-panel{ display:none; animation:fadeIn .25s ease; }
    .subtab-panel.active{ display:block; }
    .standard-manager{ border:1px solid #dfe6fb; border-radius:12px; padding:12px; background:#f8faff; margin-top:12px; display:none; flex-direction:column; gap:12px; }
    .standard-manager.visible{ display:flex; }
    .standard-row{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:8px 10px; border-radius:10px; background:#fff; border:1px solid #dfe6fb; }
    .standard-row strong{ font-size:13px; }
    .standard-meta{ font-size:11px; color:#7d89a5; display:flex; gap:12px; flex-wrap:wrap; }
    .dossier-builder{ display:flex; flex-direction:column; gap:16px; }
    .dossier-create{ display:flex; gap:16px; flex-wrap:wrap; align-items:flex-end; }
    .dossier-create > div{ flex:1 1 220px; }
    .dossier-create-actions{ display:flex; gap:8px; align-items:center; }
    .dossier-switcher{ display:flex; flex-wrap:wrap; gap:8px; }
    .dossier-switcher button{ appearance:none; border:none; background:#eef2ff; color:#2b3b63; padding:6px 12px; border-radius:999px; font-size:12px; cursor:pointer; }
    .dossier-switcher button.active{ background:#3a7afe; color:#fff; box-shadow:0 4px 12px rgba(58,122,254,.18); }
    .dossier-detail{ border:1px solid #dfe3f5; border-radius:14px; padding:16px; background:#f9fbff; display:flex; flex-direction:column; gap:18px; }
    .dossier-detail.hidden{ display:none; }
    .dossier-header-bar{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .dossier-header-bar h3{ margin:0; }
    .dossier-actions{ display:flex; gap:8px; flex-wrap:wrap; }
    .dossier-header-actions{ justify-content:flex-end; }
    .phase-toolbar{ display:flex; flex-wrap:wrap; gap:8px; padding-left:60px; }
    .phase-toolbar .btn{ font-size:12px; }
    .letter-actions{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .letter-actions .btn{ font-size:12px; }
    #auth_dossier_editor_body{ position:relative; display:flex; flex-direction:column; gap:32px; padding:0; }
    .dossier-phase{ position:relative; display:flex; flex-direction:column; gap:20px; padding-left:26px; counter-reset:dossier-step; }
    .dossier-phase::before{ content:''; position:absolute; left:46px; top:60px; bottom:10px; width:2px; background:linear-gradient(180deg, rgba(74,110,226,.25) 0%, rgba(74,110,226,.05) 100%); pointer-events:none; }
    .dossier-phase + .dossier-phase{ margin-top:12px; }
    .dossier-phase-header{ display:flex; align-items:flex-start; justify-content:space-between; gap:16px; padding-left:60px; }
    .dossier-phase-header h4{ margin:0; font-size:16px; color:#1f2a3d; }
    .dossier-phase-header p{ margin:4px 0 0; font-size:12.5px; color:#65708b; max-width:520px; }
    .phase-toggle{ display:flex; align-items:center; gap:10px; font-size:12.5px; color:#eef2ff; background:rgba(74,110,226,.22); border-radius:999px; padding:6px 14px; box-shadow:inset 0 0 0 1px rgba(255,255,255,.18); }
    .phase-toggle input{ accent-color:#3a7afe; width:16px; height:16px; }
    .phase-toggle span{ font-weight:600; color:#fff; }
    .dossier-step{ position:relative; padding:20px 22px 22px 86px; background:linear-gradient(135deg, rgba(255,255,255,1) 0%, rgba(244,247,255,1) 100%); border:1px solid rgba(90,118,210,.18); border-radius:20px; box-shadow:0 12px 28px rgba(37,74,180,.08); }
    .dossier-phase .dossier-step::before{ counter-increment:dossier-step; content:counter(dossier-step); position:absolute; left:26px; top:24px; width:36px; height:36px; border-radius:12px; background:linear-gradient(135deg, #3a7afe 0%, #7c9dff 100%); color:#fff; font-weight:700; font-size:16px; display:flex; align-items:center; justify-content:center; box-shadow:0 10px 18px rgba(58,122,254,.2); }
    .dossier-phase .dossier-step::after{ content:''; position:absolute; left:44px; top:72px; bottom:-24px; width:2px; background:linear-gradient(180deg, rgba(58,122,254,.18) 0%, rgba(58,122,254,0) 100%); }
    .dossier-phase .dossier-step:last-of-type::after{ display:none; }
    .dossier-step h4{ margin:0 0 10px; font-size:15px; color:#233056; display:flex; align-items:center; gap:8px; }
    .dossier-step-header{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
    .step-visibility{ display:flex; align-items:center; flex-shrink:0; }
    .step-visibility .checkbox-field{ margin:0; font-size:12px; color:var(--muted); gap:6px; }
    .step-visibility .checkbox-field input{ margin:0; }
    .dossier-step.step-excluded{ opacity:.55; }
    .dossier-step.step-excluded .step-visibility .checkbox-field{ color:var(--bad); }
    .dossier-step > .muted{ margin-top:-4px; font-size:12.5px; }
    .opis-preview{ background:#fff; border:1px solid #dfe3f5; border-radius:12px; padding:12px; display:flex; flex-direction:column; gap:8px; }
    .opis-title{ font-weight:600; text-align:center; }
    .opis-preview ol{ margin:0; padding-left:18px; display:flex; flex-direction:column; gap:4px; font-size:13px; }
    .dossier-row-form{ border:1px dashed #c9d5f7; border-radius:12px; padding:12px; background:#fff; display:flex; flex-direction:column; gap:12px; }
    .form-actions.align-end{ display:flex; align-items:flex-end; justify-content:flex-end; }
    .dossier-doc-list{ display:flex; flex-direction:column; gap:8px; }
    .dossier-doc-list .doc-item{ display:flex; justify-content:space-between; align-items:center; gap:12px; padding:10px 12px; background:#fff; border:1px solid #dfe3f5; border-radius:10px; font-size:13px; }
    .dossier-doc-list .doc-item .meta{ display:flex; flex-direction:column; gap:2px; }
    .dossier-doc-list .doc-item .actions{ display:flex; gap:8px; }
    .material-uploader{ border:1px dashed #c9d5f7; border-radius:12px; padding:12px; background:#fff; display:flex; flex-direction:column; gap:12px; }
    .material-uploader-controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .dossier-actions{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }
    .dossier-list{ border:1px solid #dfe3f5; border-radius:12px; overflow:hidden; }
    .dossier-list table{ width:100%; border-collapse:collapse; }
    .dossier-list th, .dossier-list td{ padding:10px 12px; border-bottom:1px solid #e7ecfb; font-size:13px; text-align:left; }
    .dossier-list tbody tr:nth-child(odd){ background:#f9fbff; }
    .dossier-empty{ font-size:13px; color:#7d89a5; }
    @keyframes fadeIn{ from{ opacity:0; transform:translateY(4px); } to{ opacity:1; transform:translateY(0); } }
    .logo-preview{ width:64px; height:64px; border-radius:16px; border:1px dashed #c9d5f7; display:flex; align-items:center; justify-content:center; background:#f4f7ff; overflow:hidden; }
    .logo-preview img{ max-width:100%; max-height:100%; object-fit:contain; }
    .card{
      background:var(--card);
      border:1px solid var(--card-border);
      border-radius:16px;
      box-shadow:0 10px 28px rgba(32,56,104,.12);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      font-size:16px;
      padding:14px 16px;
      border-bottom:1px solid var(--card-border);
      background:#eff3ff;
      color:var(--text);
    }
    .card .content{ padding:14px 16px; }
    .muted{ color:var(--muted); font-size:13px; }
    .row{ display:flex; gap:10px; }
    .row > *{ flex:1; }
    label{ font-size:12px; color:#7381a3; display:block; margin:8px 0 6px; }
    input, select, textarea{
      width:100%;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid #c9d5f7;
      background:#f9fbff;
      color:var(--text);
      outline:none;
      transition:border-color .2s, box-shadow .2s;
    }
    input:focus, select:focus, textarea:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(58,122,254,.18);
    }
    input::placeholder, textarea::placeholder{ color:#9aa7c6; }
    button{ appearance:none; border:none; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer; transition:transform .15s ease, box-shadow .15s ease; }
    button:hover{ transform:translateY(-1px); box-shadow:0 6px 16px rgba(37,94,233,.18); }
    button:disabled{ cursor:not-allowed; opacity:.6; box-shadow:none; transform:none; }
    button:disabled:hover{ box-shadow:none; transform:none; }
    .btn{
      background:var(--accent);
      color:#fff;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 14px;
      border-radius:12px;
      border:1px solid transparent;
      font-weight:600;
      cursor:pointer;
      text-decoration:none;
      line-height:1;
      transition:transform .15s ease, box-shadow .15s ease, background .2s ease, color .2s ease;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 6px 16px rgba(37,94,233,.18); }
    .btn.secondary{ background:#e7ecfb; color:var(--accent-strong); box-shadow:none; }
    .btn.secondary:hover{ background:#dbe5ff; color:var(--accent-strong); box-shadow:0 4px 12px rgba(37,94,233,.12); }
    .btn.ghost{ background:#fff; border:1px solid #c9d5f7; color:var(--accent-strong); box-shadow:none; }
    .btn.ghost:hover{ background:#f5f7ff; box-shadow:0 4px 12px rgba(37,94,233,.12); }
    .btn.danger{ background:var(--bad); color:#fff; box-shadow:none; }
    .btn[data-icon]::before{
      content:'';
      width:18px;
      height:18px;
      background-repeat:no-repeat;
      background-position:center;
      background-size:contain;
    }
    .btn.small{ font-size:12px; padding:6px 10px; border-radius:8px; gap:6px; }
    .btn.small[data-icon]::before{ width:16px; height:16px; }
    .btn[data-icon="view"]::before{ background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%232f3f63' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='6'/%3E%3Cline x1='16.5' y1='16.5' x2='21' y2='21'/%3E%3C/svg%3E"); }
    .btn[data-icon="download"]::before{ background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%231aa76d' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 3v12'/%3E%3Cpath d='M6 13l6 6 6-6'/%3E%3Cpath d='M5 21h14'/%3E%3C/svg%3E"); }
    .btn[data-icon="attach"]::before{ background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%233a7afe' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M7 13l6-6a3 3 0 0 1 4.2 4.2l-7 7a4 4 0 1 1-5.6-5.6l7-7'/%3E%3C/svg%3E"); }
    .toolbar{ display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }

    table{ width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:14px; border:1px solid var(--card-border); }
    th, td{ text-align:left; padding:10px 12px; font-size:14px; }
    thead th{ background:#eef3ff; position:sticky; top:0; z-index:1; color:var(--text); }
    tbody tr:nth-child(odd){ background:#fff; }
    tbody tr:nth-child(even){ background:var(--table-alt); }
    tbody tr:hover{ background:#e7efff; }
    .status{ font-size:12px; padding:4px 8px; border-radius:999px; display:inline-block; border:1px solid transparent; }
    .status.ok{ background:rgba(26,155,111,.12); color:#187657; border-color:rgba(26,155,111,.24); }
    .status.warn{ background:rgba(210,138,0,.12); color:#8a5a00; border-color:rgba(210,138,0,.24); }
    .status.bad{ background:rgba(217,74,74,.12); color:#932828; border-color:rgba(217,74,74,.26); }

    .list{ max-height:480px; overflow:auto; }
    .search-box{ margin-bottom:12px; }
    .search-box input{ width:100%; }
    #welder_count{ font-weight:600; }
    #welders_tbody tr.selected{ background:#e0e8ff !important; box-shadow:inset 0 0 0 2px rgba(58,122,254,.35); }
    .welder-name-cell{ display:flex; align-items:center; gap:8px; }
    .icon-button{ background:transparent; border:1px solid transparent; color:var(--bad); padding:4px; border-radius:10px; cursor:pointer; font-size:16px; line-height:1; transition:background .2s, border-color .2s, color .2s; }
    .icon-button:hover{ background:rgba(217,74,74,.08); border-color:rgba(217,74,74,.18); }
    .icon-button:focus-visible{ outline:2px solid var(--bad); outline-offset:2px; }
    .status.neutral{ background:#edf2ff; color:var(--accent-strong); border-color:#d0dcff; }
    .hidden{ display:none !important; }
    .section-title{ display:flex; align-items:center; gap:8px; margin:8px 0 4px; color:var(--text); }
    .tag{ font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid #c9d5f7; color:var(--accent-strong); background:#edf2ff; }
    .help{ font-size:12px; color:#7d89a5; margin-top:8px; }
    .storage-file-actions{ margin-top:12px; display:flex; flex-direction:column; gap:8px; }
    .storage-file-actions .btn-row{ display:flex; flex-wrap:wrap; gap:8px; }
    .storage-file-actions .note{ font-size:12px; color:#7d89a5; }
    .storage-file-actions.disabled .btn{ opacity:.5; pointer-events:none; }
    .storage-transfer-help{ margin-top:12px; padding:12px 14px; background:#f1f4ff; border-radius:12px; font-size:12px; color:#43516f; line-height:1.55; display:flex; flex-direction:column; gap:10px; }
    .storage-transfer-help strong{ color:#1f2a3d; }
    .storage-transfer-help ol{ margin:0; padding-left:18px; display:flex; flex-direction:column; gap:6px; }
    .storage-transfer-help li{ margin:0; }
    .storage-transfer-help p{ margin:0; }
    .storage-transfer-help .footnote{ color:#5c678a; font-size:11.5px; }
    .checkbox-field{ display:flex; align-items:flex-start; gap:8px; }
    .checkbox-field input[type="checkbox"]{ margin-top:4px; }
    #q_attachment_wrap{ margin-top:12px; }
    .danger-zone{ border-top:1px dashed #c9d5f7; margin-top:12px; padding-top:12px; }
    .stats-grid{ display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:18px; margin-top:16px; }
    .stat-card{ background:linear-gradient(180deg,#ffffff,#f4f7ff); border:1px solid var(--card-border); border-radius:16px; padding:16px; box-shadow:0 10px 24px rgba(32,56,104,.12); transition:background .2s, border-color .2s; }
    .stat-card.warning{ background:linear-gradient(180deg,#fff8e6,#ffeab6); border-color:rgba(210,138,0,.45); }
    .stat-card.danger{ background:linear-gradient(180deg,#ffeaea,#ffd1d1); border-color:rgba(217,74,74,.45); }
    .stat-card h3{ margin:0 0 6px; font-size:12px; text-transform:uppercase; letter-spacing:.6px; color:#6c7aa1; }
    .stat-card strong{ font-size:28px; font-weight:700; color:var(--accent-strong); }
    .stat-card span{ font-size:12px; color:#7c88a8; }
    .stat-card.warning h3{ color:#a06400; }
    .stat-card.warning strong{ color:var(--warn); }
    .stat-card.warning span{ color:#a06400; }
    .stat-card.danger h3{ color:#b33a3a; }
    .stat-card.danger strong{ color:var(--bad); }
    .stat-card.danger span{ color:#b33a3a; }
    .overview-table{ margin-top:20px; border-radius:16px; overflow:hidden; border:1px solid var(--card-border); }
    .overview-table table{ border:none; }
    .overview-table caption{ text-align:left; font-weight:600; padding:12px 16px; background:#eef3ff; }
    .company-list{ display:flex; flex-direction:column; gap:12px; margin-top:12px; }
    .company-item{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; padding:12px; border:1px solid var(--card-border); border-radius:12px; background:#f8faff; }
    .company-item input{ max-width:240px; }
    .company-item .tag{ margin-left:auto; }
    .app-footer{ margin-top:auto; padding:18px 24px; color:#7d89a5; font-size:12px; background:rgba(255,255,255,.86); border-top:1px solid var(--card-border); }
    .view-note{ font-size:13px; color:#7180a4; margin-top:8px; }
    .document-viewer{ position:fixed; inset:0; background:rgba(17,28,62,.65); backdrop-filter:blur(4px); display:none; align-items:center; justify-content:center; z-index:999; padding:32px; }
    .document-viewer.open{ display:flex; }
    .document-viewer-dialog{ position:relative; background:#fff; border-radius:18px; box-shadow:0 18px 60px rgba(17,28,62,.28); max-width:90vw; width:960px; max-height:90vh; display:flex; flex-direction:column; }
    .document-viewer-header{ display:flex; align-items:center; justify-content:space-between; padding:16px 20px; border-bottom:1px solid #e2e8ff; }
    .document-viewer-title{ font-size:16px; font-weight:600; color:var(--surface); }
    .document-viewer-close{ border:none; background:none; font-size:20px; line-height:1; cursor:pointer; color:#7481a0; }
    .document-viewer-close:hover{ color:#2b3b63; }
    .document-viewer-body{ padding:0 20px 20px; overflow:auto; flex:1; }
    .document-viewer-body iframe{ width:100%; height:70vh; border:none; border-radius:12px; background:#f5f7ff; }
    .document-viewer-body img{ max-width:100%; height:auto; border-radius:12px; }
    .print-branding{ display:flex; flex-direction:column; gap:4px; font-size:12px; color:#202b46; }
    .print-branding img{ max-height:48px; object-fit:contain; }
    @media (max-width:720px){
      .dossier-phase{ padding-left:18px; }
      .dossier-phase::before{ left:36px; top:70px; }
      .dossier-phase-header{ padding-left:48px; flex-direction:column; align-items:flex-start; }
      .phase-toggle{ margin-top:6px; }
      .dossier-phase .dossier-step{ padding:18px 18px 20px 76px; }
      .dossier-phase .dossier-step::before{ left:18px; top:20px; }
      .dossier-phase .dossier-step::after{ left:34px; }
    }
    @media (max-width:520px){
      .dossier-phase{ padding-left:10px; }
      .dossier-phase::before{ left:28px; }
      .dossier-phase-header{ padding-left:36px; }
      .dossier-phase .dossier-step{ padding:18px 16px 20px 68px; }
      .dossier-phase .dossier-step::before{ left:12px; top:18px; }
      .dossier-phase .dossier-step::after{ left:30px; }
      .phase-toggle{ width:100%; justify-content:flex-start; }
    }
    @media (max-width:960px){
      .app-shell{ flex-direction:column; }
      .sidebar{ flex-direction:row; overflow:auto; width:100%; padding:16px 12px; gap:12px; align-items:flex-start; }
      .sidebar-header{ display:none; }
      .sidebar-nav{ flex-direction:row; flex-wrap:wrap; margin-top:0; gap:12px; }
      .nav-button{ flex:1 1 150px; flex-direction:row; justify-content:flex-start; min-height:auto; padding:12px 14px; }
      .nav-button .icon{ font-size:20px; width:24px; height:24px; border-radius:8px; }
      .nav-button span:last-child{ text-transform:none; font-size:14px; text-align:left; }
      .sidebar-reports{ flex:1 1 150px; margin-top:0; }
      .sidebar-reports .nav-button{ flex-direction:row; justify-content:flex-start; min-height:auto; padding:12px 14px; }
      .reports-menu{ position:static; }
      .workspace{ min-height:auto; }
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .archive-section{ margin-top:16px; border-top:1px dashed var(--card-border); padding-top:16px; }
    .archive-toggle{ width:100%; display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .archive-toggle::after{ content:'‚ñæ'; font-size:14px; color:var(--muted); transition:transform .2s ease; }
    .archive-toggle[aria-expanded="true"]::after{ transform:rotate(180deg); }
    .archive-toggle:disabled{ opacity:.5; cursor:not-allowed; }
    .archive-panel{ margin-top:12px; background:#f8faff; border:1px solid #dfe6fb; border-radius:12px; padding:12px; }
    .archive-panel .archive-note{ margin:0 0 10px; font-size:12px; color:#7d89a5; }
    .archive-panel .list{ max-height:240px; }
    .archive-panel table thead th{ background:#e9eeff; }
    .archive-panel td:last-child{ text-align:right; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
  <div id="auth_overlay" class="auth-overlay" aria-hidden="false">
    <div class="auth-card" role="dialog" aria-modal="true" aria-labelledby="auth_title">
      <h2 id="auth_title">Autentificare</h2>
      <p>Introduce datele de acces pentru a intra √Æn aplica»õie.</p>
      <div id="auth_error" class="auth-error" role="alert">Utilizator sau parolƒÉ incorecte.</div>
      <p id="auth_notice" class="auth-notice" role="status"></p>
      <form id="auth_form" autocomplete="off">
        <div>
          <label for="auth_user">Utilizator</label>
          <input id="auth_user" name="username" type="text" autocomplete="username" required />
        </div>
        <div>
          <label for="auth_pass">ParolƒÉ</label>
          <input id="auth_pass" name="password" type="password" autocomplete="current-password" required />
        </div>
        <button type="submit">AutentificƒÉ-te</button>
      </form>
    </div>
  </div>
  <div class="app-shell">
    <aside class="sidebar">
      <div class="sidebar-header">
        <span class="sidebar-title">Gestiune Sudori</span>
        <span class="sidebar-subtitle">panou opera»õional</span>
      </div>
      <nav class="sidebar-nav">
        <button class="nav-button active" data-view="home">
          <span class="icon">üè†</span>
          <span>Home</span>
        </button>
        <button class="nav-button" data-view="authorizations">
          <span class="icon">üìÑ</span>
          <span>Autoriza»õii</span>
        </button>
        <button class="nav-button" data-view="welders">
          <span class="icon">üßë‚Äçüè≠</span>
          <span>Sudori</span>
        </button>
        <button class="nav-button" data-view="procedures">
          <span class="icon">üìò</span>
          <span>OmologƒÉri</span>
        </button>
        <button class="nav-button" data-view="settings">
          <span class="icon">‚öôÔ∏è</span>
          <span>SetƒÉri</span>
        </button>
      </nav>
      <div class="sidebar-reports">
        <button class="nav-button" data-view="reports">
          <span class="icon">üìä</span>
          <span>Rapoarte</span>
        </button>
      </div>
      <div class="sidebar-footer" id="sidebar_storage_hint">
        Date salvate local √Æn browser.<br/>DescarcƒÉ periodic backup-ul JSON.
      </div>
    </aside>
    <div class="workspace">
      <header class="topbar">
        <div class="topbar-brand">
          <img id="active_company_logo" class="company-logo" alt="Logo companie" />
          <div class="title-stack">
            <h1>Gestiune Sudori</h1>
            <div class="title-meta">
              <span class="pill">ASME Sec IX ¬∑ ISCIR CR9 / CR7</span>
              <span class="pill version">Versiunea 3.5</span>
            </div>
          </div>
        </div>
        <div class="topbar-actions">
          <div class="company-select">
            <span>Companie activƒÉ</span>
            <select id="company_selector"></select>
          </div>
          <button class="btn ghost" id="btn_add_company">Companie nouƒÉ</button>
          <span class="muted" id="storage_mode_hint">Frontend HTML ‚Äì date stocate local</span>
          <button class="btn ghost" id="btn_import_state">ImportƒÉ baza de date</button>
          <button class="btn ghost" id="btn_export_state" data-icon="download">SalveazƒÉ baza de date</button>
          <input type="file" id="input_import_state" accept="application/json" hidden />
        </div>
      </header>
      <main>
        <div class="content-inner">
          <section id="view_home" class="view active">
            <div class="card">
              <h2>Panou general</h2>
              <div class="content">
                <p class="muted">Statistici agregate din toate companiile administrate.</p>
                <div class="stats-grid">
                  <div class="stat-card">
                    <h3>Sudori activi</h3>
                    <strong id="home_total_welders">0</strong>
                    <span>Total sudori √Ænregistra»õi</span>
                  </div>
                  <div class="stat-card">
                    <h3>Autoriza»õii active</h3>
                    <strong id="home_total_authorizations">0</strong>
                    <span>Autoriza»õii sudori √Æn curs de valabilitate</span>
                  </div>
                  <div class="stat-card">
                    <h3>OmologƒÉri active</h3>
                    <strong id="home_total_procedures">0</strong>
                    <span>Procedee omologate gestionate</span>
                  </div>
                  <div class="stat-card warning">
                    <h3>ExpirƒÉ cur√¢nd</h3>
                    <strong id="home_expiring_soon">0</strong>
                    <span>√én urmƒÉtoarele 30 de zile</span>
                  </div>
                  <div class="stat-card danger">
                    <h3>Expirate</h3>
                    <strong id="home_expired">0</strong>
                    <span>NecesitƒÉ ac»õiune</span>
                  </div>
                  <div class="stat-card warning">
                    <h3>CI expirƒÉ cur√¢nd</h3>
                    <strong id="home_id_card_expiring">0</strong>
                    <span>Buletine de identitate √Æn urmƒÉtoarele 30 de zile</span>
                  </div>
                  <div class="stat-card danger">
                    <h3>CI expirate</h3>
                    <strong id="home_id_card_expired">0</strong>
                    <span>NecesitƒÉ actualizare acte de identitate</span>
                  </div>
                  <div class="stat-card warning">
                    <h3>Fi»ôe aptitudini cur√¢nd</h3>
                    <strong id="home_aptitude_expiring">0</strong>
                    <span>ExpirƒÉ √Æn urmƒÉtoarele 30 de zile</span>
                  </div>
                  <div class="stat-card danger">
                    <h3>Fi»ôe aptitudini expirate</h3>
                    <strong id="home_aptitude_expired">0</strong>
                    <span>ContacteazƒÉ medicina muncii</span>
                  </div>
                </div>
                <div class="overview-table">
                  <table>
                    <caption>Situa»õie pe companii</caption>
                    <thead>
                      <tr>
                        <th>Companie</th>
                        <th>Sudori</th>
                        <th>Autoriza»õii</th>
                        <th>Procedee</th>
                        <th>ExpirƒÉ &lt; 30 zile</th>
                        <th>Expirate</th>
                      </tr>
                    </thead>
                    <tbody id="home_company_table"></tbody>
                  </table>
                </div>
                <p class="muted hidden" id="home_companies_empty">AdaugƒÉ o companie »ôi √ÆnregistreazƒÉ sudori pentru a vedea statistici defalcate.</p>
                <div class="overview-table">
                  <table>
                    <caption>UrmƒÉtoarele expirƒÉri</caption>
                    <thead>
                      <tr>
                        <th>Companie</th>
                        <th>Sudor</th>
                        <th>Standard</th>
                        <th>Proces</th>
                        <th>ExpirƒÉ la</th>
                      </tr>
                    </thead>
                    <tbody id="home_expiring_table"></tbody>
                  </table>
                </div>
                <p class="muted hidden" id="home_no_expiring">Nicio autoriza»õie nu expirƒÉ √Æn urmƒÉtoarele 60 de zile.</p>
              </div>
            </div>
          </section>

          <section id="view_welders" class="view">
            <div class="content-inner">
              <section id="welders_menu" class="card">
                <h2>Alege modul de administrare</h2>
                <div class="content">
                  <p class="muted">Gestionarea personalului este √ÆmpƒÉr»õitƒÉ pe douƒÉ zone dedicate.</p>
                  <div class="selection-hub">
                    <button type="button" class="selection-card" id="welders_menu_welders">
                      <div class="icon">üë∑‚Äç‚ôÇÔ∏è</div>
                      <h3>Sudori</h3>
                      <p>ListƒÉ completƒÉ cu eviden»õa autoriza»õiilor »ôi acces la documentele fiecƒÉrui sudor.</p>
                    </button>
                    <button type="button" class="selection-card" id="welders_menu_pansoane">
                      <div class="icon">üîñ</div>
                      <h3>Pansoane</h3>
                      <p>AdministreazƒÉ codurile disponibile, arhiveazƒÉ sau reactiveazƒÉ pansoane.</p>
                    </button>
                  </div>
                </div>
              </section>

              <section id="welders_overview" class="card hidden">
                <div class="content welder-overview">
                  <div class="subview-header">
                    <button type="button" class="back-link" data-subview-back="menu">‚Üê √énapoi la meniu</button>
                    <h2>Sudori</h2>
                    <span class="tag">Total activi: <strong id="welder_count">0</strong></span>
                  </div>
                  <div class="welder-table-tools">
                    <div class="search-box">
                      <input id="welder_search" type="search" placeholder="CautƒÉ dupƒÉ nume sau cod" aria-label="CautƒÉ sudor" />
                    </div>
                    <div class="actions">
                      <button type="button" class="btn secondary" id="btn_new_welder">AdaugƒÉ sudor</button>
                    </div>
                  </div>
                  <div class="list">
                    <table>
                      <thead>
                        <tr>
                          <th style="width:15%">Panson</th>
                          <th style="width:20%">Sudor</th>
                          <th style="width:30%">CalificƒÉri</th>
                          <th style="width:25%">CalificƒÉri pe proces</th>
                          <th style="width:10%">Ac»õiuni</th>
                        </tr>
                      </thead>
                      <tbody id="welders_tbody"></tbody>
                    </table>
                  </div>
                  <div class="archive-section">
                    <button type="button" class="btn ghost archive-toggle" id="toggle_archive" aria-expanded="false">
                      ArhivƒÉ sudori (0)
                    </button>
                    <div class="archive-panel hidden" id="archive_panel" aria-hidden="true">
                      <p class="archive-note">Sudorii arhiva»õi pot fi reactiva»õi √ÆmpreunƒÉ cu autoriza»õiile lor.</p>
                      <div class="search-box">
                        <input type="search" id="archive_search" placeholder="CautƒÉ √Æn arhivƒÉ dupƒÉ nume, cod sau motiv" />
                      </div>
                      <div class="list hidden" id="archive_table_wrap">
                        <table>
                          <thead>
                            <tr>
                              <th style="width:28%">Nume</th>
                              <th>Cod</th>
                              <th>Arhivat la</th>
                              <th>Motiv</th>
                              <th>AutorizƒÉri</th>
                              <th></th>
                            </tr>
                          </thead>
                          <tbody id="archive_tbody"></tbody>
                        </table>
                      </div>
                      <p class="muted" id="archive_empty">Arhiva este goalƒÉ.</p>
                      <p class="muted hidden" id="archive_no_results">Nicio potrivire pentru filtrul curent.</p>
                    </div>
                  </div>
                </div>
              </section>

              <section id="pansoane_overview" class="card hidden">
                <div class="content">
                  <div class="subview-header">
                    <button type="button" class="back-link" data-subview-back="menu">‚Üê √énapoi la meniu</button>
                    <h2>Pansoane active (<span id="panson_count">0</span>)</h2>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Cod panson</label>
                      <input id="panson_code" placeholder="ex: P-001" />
                    </div>
                    <div>
                      <label>Descriere</label>
                      <input id="panson_description" placeholder="ex: Panson linia A" />
                    </div>
                    <div class="toolbar">
                      <button class="btn" id="btn_add_panson">AdaugƒÉ panson</button>
                    </div>
                  </div>
                  <div class="list">
                    <table>
                      <thead>
                        <tr>
                          <th>Cod</th>
                          <th>Descriere</th>
                          <th>UtilizƒÉri</th>
                          <th></th>
                        </tr>
                      </thead>
                      <tbody id="pansoane_tbody"></tbody>
                    </table>
                  </div>
                  <p class="muted" id="pansoane_empty">AdaugƒÉ primul panson pentru a-l putea asigna sudorilor.</p>
                  <div class="archive-section">
                    <button type="button" class="btn ghost panson-archive-toggle" id="toggle_panson_archive" aria-expanded="false">
                      ArhivƒÉ pansoane (0)
                    </button>
                    <div class="archive-panel hidden" id="panson_archive_panel" aria-hidden="true">
                      <p class="archive-note">Pansoanele arhivate nu mai pot fi alese de sudori, dar pot fi restaurate ulterior.</p>
                      <div class="list hidden" id="panson_archive_table_wrap">
                        <table>
                          <thead>
                            <tr>
                              <th>Cod</th>
                              <th>Descriere</th>
                              <th>Arhivat la</th>
                              <th></th>
                            </tr>
                          </thead>
                          <tbody id="panson_archive_tbody"></tbody>
                        </table>
                      </div>
                      <p class="muted" id="panson_archive_empty">Nu existƒÉ pansoane arhivate.</p>
                    </div>
                  </div>
                </div>
              </section>
            </div>
          </section>

          <section id="view_authorizations" class="view">
            <section class="card">
              <h2>Autoriza»õii</h2>
              <div class="content">
                <div class="auth-context">
                  <span class="muted">Sudor selectat:</span>
                  <span id="auth_current_welder" class="tag">(selecteazƒÉ un sudor)</span>
                </div>
                <div class="subtabs" id="auth_tabs" role="tablist" aria-label="Sec»õiuni autoriza»õii">
                  <button type="button" class="active" data-tab="auth_form">Autoriza»õii sudori</button>
                  <button type="button" data-tab="auth_existing">Autoriza»õii existente</button>
                  <button type="button" data-tab="auth_dossier">Dosar autorizare</button>
                </div>

                <div class="subtab-panel active" data-panel="auth_form">
                  <div class="auth-standard-tabs" id="auth_standard_tabs" role="tablist" aria-label="Standard autorizare"></div>
                  <div class="form-row">
                    <div>
                      <label>Standard</label>
                      <select id="auth_standard"></select>
                      <button type="button" class="btn ghost small" id="btn_manage_standards">Gestionare standarde</button>
                    </div>
                    <div>
                      <label>Sudor</label>
                      <select id="auth_welder_select">
                        <option value="">SelecteazƒÉ sudor</option>
                      </select>
                    </div>
                    <div>
                      <label>Panson asignat</label>
                      <input id="auth_welder_panson" type="text" placeholder="‚Äî" readonly />
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Procedeu omologat</label>
                      <select id="auth_procedure_select">
                        <option value="">SelecteazƒÉ procedeu</option>
                      </select>
                    </div>
                    <div>
                      <label id="auth_process_label">Procedeu de sudare</label>
                      <select id="auth_process">
                        <option>GMAW (MIG/MAG)</option>
                        <option>GTAW (TIG)</option>
                        <option>SMAW (MMA)</option>
                        <option>FCAW</option>
                        <option>SAW</option>
                      </select>
                    </div>
                    <div>
                      <label>Calitate material de bazƒÉ</label>
                      <input id="auth_base_quality" placeholder="ex: S235" />
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Materiale de bazƒÉ</label>
                      <input id="auth_base_material" placeholder="ex: »õeavƒÉ S355 / 48.6√ó3.6" />
                    </div>
                    <div>
                      <label>Material de adaos</label>
                      <input id="auth_filler_material" placeholder="ex: ER70S-6" />
                    </div>
                    <div>
                      <label id="auth_position_label">Pozi»õie de sudare</label>
                      <select id="auth_position">
                        <option>PA</option><option>PB</option><option>PC</option><option>PD</option><option>PE</option><option>PF</option><option>PG</option>
                      </select>
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Dimensiune material de bazƒÉ</label>
                      <input id="auth_base_dimension" placeholder="ex: 300 √ó 30 mm" />
                    </div>
                    <div>
                      <label>Diametru / grosime</label>
                      <input id="auth_diameter" placeholder="ex: √ò114 ¬∑ 8 mm" />
                    </div>
                    <div>
                      <label>Domeniu grosime</label>
                      <input id="auth_thickness_domain" placeholder="ex: t16√∑38 mm" />
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Nr. autoriza»õie</label>
                      <input id="auth_cert" placeholder="ex: Q-2025-044" />
                    </div>
                    <div>
                      <label>Emitent</label>
                      <input id="auth_issuer" placeholder="ex: Organism Aprob." />
                    </div>
                    <div>
                      <label>Data expirƒÉrii</label>
                      <input id="auth_expiry" type="date" />
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Observa»õii</label>
                      <input id="auth_observation" placeholder="ex: Autorizare ini»õialƒÉ" />
                    </div>
                    <div>
                      <label>Document asociat (PDF op»õional)</label>
                      <input id="auth_attachment" type="file" accept="application/pdf" />
                      <p class="help">Ata»ôeazƒÉ copia autoriza»õiei √Æn format PDF pentru eviden»õƒÉ.</p>
                    </div>
                  </div>
                  <div class="toolbar">
                    <button class="btn" id="btn_add_authorization">AdaugƒÉ autoriza»õie</button>
                    <button class="btn ghost" id="btn_refresh_authorizations">Re√ÆncarcƒÉ</button>
                  </div>
                  <div class="standard-manager" id="auth_standard_manager" aria-hidden="true">
                    <div class="standard-row">
                      <strong>Standardele disponibile</strong>
                      <div class="attachment-actions">
                        <button type="button" class="btn secondary small" id="btn_add_standard">AdaugƒÉ standard</button>
                        <button type="button" class="btn ghost small" id="btn_close_standard_manager">√énchide</button>
                      </div>
                    </div>
                    <p class="muted">ActualizeazƒÉ denumirea »ôi grupul standardelor folosite pentru autorizarea sudorilor.</p>
                    <div id="auth_standard_list"></div>
                  </div>
                </div>

                <div class="subtab-panel" data-panel="auth_existing">
                  <div class="section-title">
                    <strong>Autoriza»õii existente</strong>
                    <span class="tag" id="auth_existing_hint">vizualizare pe standarde fƒÉrƒÉ selec»õie de sudor</span>
                  </div>
                  <div class="subtabs compact" id="auth_existing_tabs" role="tablist" aria-label="Grupuri standard autoriza»õii"></div>
                  <p class="muted hidden" id="auth_empty_state">Nu existƒÉ autoriza»õii salvate.</p>
                  <div class="list" id="auth_existing_tables"></div>
                </div>

                <div class="subtab-panel" data-panel="auth_dossier">
                  <div class="dossier-builder">
                    <div class="dossier-create">
                      <div>
                        <label>Standard dosar</label>
                        <select id="auth_dossier_standard_select"></select>
                      </div>
                      <div class="dossier-create-actions">
                        <button type="button" class="btn" id="btn_new_auth_dossier">Dosar nou</button>
                      </div>
                    </div>
                    <div id="auth_dossier_switcher" class="dossier-switcher"></div>
                    <p class="muted" id="auth_dossier_empty_state">CreeazƒÉ un dosar de autorizare pentru a √Æncepe.</p>
                    <div id="auth_dossier_detail" class="dossier-detail hidden" aria-live="polite">
                      <div class="dossier-header-bar">
                        <div>
                          <h3 id="auth_dossier_title">Dosar autorizare</h3>
                          <span class="tag" id="auth_dossier_standard_label"></span>
                        </div>
                        <div class="dossier-actions dossier-header-actions">
                          <button type="button" class="btn ghost" id="btn_save_auth_dossier_pdf">SalveazƒÉ √Æn arhivƒÉ</button>
                          <button type="button" class="btn ghost small" id="btn_delete_auth_dossier">»òterge dosarul</button>
                        </div>
                      </div>

                      <div id="auth_dossier_editor_body">
                        <div class="dossier-phase" id="auth_dossier_phase_preliminary">
                          <div class="dossier-phase-header">
                            <div>
                              <h4>Documenta»õie preliminarƒÉ</h4>
                              <p>CompleteazƒÉ pa»ôii ini»õiali ai dosarului. MarcheazƒÉ faza ca √ÆnchisƒÉ c√¢nd toate informa»õiile sunt validate.</p>
                            </div>
                            <label class="phase-toggle">
                              <input type="checkbox" id="auth_phase_preliminary_closed" />
                              <span>FazƒÉ preliminarƒÉ √ÆnchisƒÉ</span>
                            </label>
                          </div>
                          <div class="phase-toolbar">
                            <button type="button" class="btn ghost small" id="btn_auth_preliminary_settings" data-action="toggle-auth-settings" data-phase="preliminary">SetƒÉri fazƒÉ preliminarƒÉ</button>
                            <button type="button" class="btn secondary" id="btn_preview_auth_preliminary_pdf" data-icon="view">PrevizualizeazƒÉ faza preliminarƒÉ</button>
                            <button type="button" class="btn" id="btn_download_auth_preliminary_pdf" data-icon="download">DescarcƒÉ faza preliminarƒÉ</button>
                          </div>
                          <div class="dossier-phase-settings" id="auth_preliminary_settings_panel" aria-hidden="true">
                            <h5>SetƒÉri documenta»õie preliminarƒÉ</h5>
                            <label class="checkbox-field"><input type="checkbox" id="auth_dossier_page_numbers" data-phase="preliminary" checked /> NumeroteazƒÉ paginile fazei preliminare</label>
                            <div class="settings-row">
                              <div>
                                <label for="auth_dossier_start_page">NumƒÉr afi»ôat pe prima paginƒÉ numerotatƒÉ</label>
                                <input type="number" id="auth_dossier_start_page" data-phase="preliminary" min="1" step="1" value="1" />
                              </div>
                              <div>
                                <label for="auth_dossier_page_offset">Pagini fƒÉrƒÉ numƒÉr √Ænainte de OPIS</label>
                                <input type="number" id="auth_dossier_page_offset" data-phase="preliminary" min="0" max="1" step="1" value="0" />
                              </div>
                            </div>
                            <p class="help-text">Folose»ôte op»õiunea de offset pentru a √Æncepe numerotarea pe pagina a doua, dar cu eticheta ‚ÄûPagina 1‚Äù.</p>
                          </div>
                          <div class="dossier-step" id="auth_dossier_step_opis">
                            <h4>Pasul 1 ¬∑ OPIS</h4>
                            <p class="muted">Titlul »ôi numerotarea se actualizeazƒÉ automat √Æn func»õie de pa»ôii completa»õi.</p>
                            <div class="opis-preview">
                              <div class="opis-title" id="auth_dossier_opis_title"></div>
                              <ol id="auth_dossier_opis_list"></ol>
                            </div>
                          </div>

                          <div class="dossier-step" data-step-key="preliminary-letter">
                            <div class="dossier-step-header">
                              <h4>Pasul 2 ¬∑ AdresƒÉ cƒÉtre organismul de calificare</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="preliminary" data-step="letter" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <textarea id="auth_dossier_letter" rows="5" placeholder="Introdu textul adresei cƒÉtre organismul de calificare"></textarea>
                            <div class="letter-actions">
                              <button type="button" class="btn ghost small" id="btn_edit_preliminary_letter" data-icon="edit">Deschide editor</button>
                              <button type="button" class="btn secondary" id="btn_preview_preliminary_letter_pdf" data-icon="view">PrevizualizeazƒÉ adresa PDF</button>
                            </div>
                          </div>

                          <div class="dossier-step" data-step-key="preliminary-table">
                            <div class="dossier-step-header">
                              <h4>Pasul 3 ¬∑ Tabel autoriza»õii</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="preliminary" data-step="table" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">CompleteazƒÉ manual sau folose»ôte butoanele ‚ÄûReautorizare‚Äù »ôi ‚ÄûPrelungire‚Äù din tabul ‚ÄûAutoriza»õii existente‚Äù.</p>
                            <div class="dossier-row-form">
                              <div class="form-row">
                                <div>
                                  <label>Sudor</label>
                                  <select id="auth_dossier_row_welder">
                                    <option value="">SelecteazƒÉ sudor</option>
                                  </select>
                                </div>
                                <div>
                                  <label>Procedeu de sudare</label>
                                  <input id="auth_dossier_row_process" />
                                </div>
                                <div>
                                  <label>Calitate material de bazƒÉ</label>
                                  <input id="auth_dossier_row_base" />
                                </div>
                                <div>
                                  <label>Procedeu omologat (op»õional)</label>
                                  <select id="auth_dossier_row_procedure">
                                    <option value="">FƒÉrƒÉ asociere</option>
                                  </select>
                                </div>
                              </div>
                              <div class="form-row">
                                <div>
                                  <label>Material de adaos</label>
                                  <input id="auth_dossier_row_filler" />
                                </div>
                                <div>
                                  <label>Materiale de bazƒÉ</label>
                                  <input id="auth_dossier_row_material" />
                                </div>
                                <div>
                                  <label>Pozi»õie de sudare</label>
                                  <input id="auth_dossier_row_position" />
                                </div>
                              </div>
                              <div class="form-row">
                                <div>
                                  <label>Dim. material de bazƒÉ</label>
                                  <input id="auth_dossier_row_dimension" />
                                </div>
                                <div>
                                  <label>Diametru / grosime</label>
                                  <input id="auth_dossier_row_diameter" />
                                </div>
                                <div>
                                  <label>Domeniu grosime</label>
                                  <input id="auth_dossier_row_domain" />
                                </div>
                                <div>
                                  <label>Observa»õii</label>
                                  <input id="auth_dossier_row_observation" placeholder="autorizare / prelungire / omologare" />
                                </div>
                                <div class="form-actions align-end">
                                  <button type="button" class="btn secondary" id="btn_add_dossier_row">AdaugƒÉ √Æn tabel</button>
                                </div>
                              </div>
                            </div>
                            <div class="list" id="auth_dossier_table_wrap">
                              <table>
                                <thead>
                                  <tr>
                                    <th>Nr. crt.</th>
                                    <th>Nume / panson</th>
                                    <th>Procedee de sudare</th>
                                    <th>Calitatea mat. de bazƒÉ</th>
                                    <th>Materiale de adaos</th>
                                    <th>Pozi»õii de sudare</th>
                                    <th>Grosime mat. de bazƒÉ</th>
                                    <th>Diametru »õeavƒÉ</th>
                                    <th>Domeniu grosimi / observa»õii</th>
                                    <th></th>
                                  </tr>
                                </thead>
                                <tbody id="auth_dossier_table_body"></tbody>
                              </table>
                            </div>
                            <p class="muted hidden" id="auth_dossier_table_empty">Tabelul nu con»õine √ÆncƒÉ intrƒÉri.</p>
                          </div>

                          <div class="dossier-step" data-step-key="preliminary-procedures">
                            <div class="dossier-step-header">
                              <h4>Pasul 4 ¬∑ Procedee anexate</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="preliminary" data-step="procedures" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">Procedeele omologate selectate se includ automat cu documentele ata»ôate.</p>
                            <div class="dossier-doc-list" id="auth_dossier_procedure_docs"></div>
                          </div>

                          <div class="dossier-step" data-step-key="preliminary-welderDocs">
                            <div class="dossier-step-header">
                              <h4>Pasul 5 ¬∑ Documente sudori</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="preliminary" data-step="welderDocs" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">Pentru fiecare sudor din tabel se vor ata»ôa copia actului de identitate, diploma, contractul »ôi fi»ôa de aptitudini (dacƒÉ existƒÉ).</p>
                            <p class="warning-text hidden" id="auth_dossier_welder_docs_warning"></p>
                            <div class="dossier-doc-list" id="auth_dossier_welder_docs"></div>
                          </div>

                          <div class="dossier-step" data-step-key="preliminary-baseMaterials">
                            <div class="dossier-step-header">
                              <h4>Pasul 6 ¬∑ Materiale de bazƒÉ</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="preliminary" data-step="baseMaterials" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <div class="material-uploader">
                              <div class="material-uploader-controls">
                                <select id="auth_dossier_base_material_select"></select>
                                <input type="file" id="auth_dossier_base_material_file" accept="application/pdf,image/*" />
                                <button type="button" class="btn ghost" id="btn_add_base_material_doc" data-icon="attach">Ata»ôeazƒÉ document</button>
                              </div>
                              <div class="dossier-doc-list" id="auth_dossier_base_material_docs"></div>
                            </div>
                          </div>

                          <div class="dossier-step" data-step-key="preliminary-fillerMaterials">
                            <div class="dossier-step-header">
                              <h4>Pasul 7 ¬∑ Materiale de adaos</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="preliminary" data-step="fillerMaterials" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <div class="material-uploader">
                              <div class="material-uploader-controls">
                                <select id="auth_dossier_filler_material_select"></select>
                                <input type="file" id="auth_dossier_filler_material_file" accept="application/pdf,image/*" />
                                <button type="button" class="btn ghost" id="btn_add_filler_material_doc" data-icon="attach">Ata»ôeazƒÉ document</button>
                              </div>
                              <div class="dossier-doc-list" id="auth_dossier_filler_material_docs"></div>
                            </div>
                          </div>
                          <div class="dossier-step">
                            <h4>Pa»ôi suplimentari</h4>
                            <p class="muted">AdaugƒÉ pa»ôi personaliza»õi cu denumire, descriere pentru OPIS »ôi documente aferente.</p>
                            <div class="dossier-row-form">
                              <div class="form-row">
                                <div>
                                  <label>Denumire pas</label>
                                  <input id="auth_custom_step_name" placeholder="ex: Raport evaluator" />
                                </div>
                                <div>
                                  <label>Text √Æn OPIS</label>
                                  <input id="auth_custom_step_opis" placeholder="ex: Raport evaluator autorizare" />
                                </div>
                              </div>
                              <div class="dossier-actions">
                                <button type="button" class="btn secondary" id="btn_add_custom_step">AdaugƒÉ pas</button>
                              </div>
                            </div>
                            <p class="muted" id="auth_custom_steps_empty">Nu existƒÉ pa»ôi suplimentari defini»õi.</p>
                            <div id="auth_custom_steps_list" class="custom-step-list"></div>
                          </div>
                        </div>

                        <div class="dossier-phase" id="auth_dossier_phase_final">
                          <div class="dossier-phase-header">
                            <div>
                              <h4>Documenta»õie finalƒÉ</h4>
                              <p>AsigurƒÉ-te cƒÉ fiecare sudor are procesele verbale »ôi rapoartele finale ata»ôate. Dosarul poate fi arhivat doar dupƒÉ finalizarea acestei etape.</p>
                            </div>
                            <label class="phase-toggle">
                              <input type="checkbox" id="auth_phase_final_closed" />
                              <span>Documenta»õie finalƒÉ finalizatƒÉ</span>
                            </label>
                          </div>
                          <div class="phase-toolbar">
                            <button type="button" class="btn ghost small" id="btn_auth_final_settings" data-action="toggle-auth-settings" data-phase="final">SetƒÉri documenta»õie finalƒÉ</button>
                            <button type="button" class="btn secondary" id="btn_preview_auth_final_pdf" data-icon="view">PrevizualizeazƒÉ documenta»õia finalƒÉ</button>
                            <button type="button" class="btn" id="btn_download_auth_final_pdf" data-icon="download">DescarcƒÉ documenta»õia finalƒÉ</button>
                          </div>
                          <div class="dossier-phase-settings" id="auth_final_settings_panel" aria-hidden="true">
                            <h5>SetƒÉri documenta»õie finalƒÉ</h5>
                            <label class="checkbox-field"><input type="checkbox" id="auth_final_page_numbers" data-phase="final" checked /> NumeroteazƒÉ paginile documenta»õiei finale</label>
                            <div class="settings-row">
                              <div>
                                <label for="auth_final_start_page">NumƒÉr afi»ôat pe prima paginƒÉ numerotatƒÉ</label>
                                <input type="number" id="auth_final_start_page" data-phase="final" min="1" step="1" value="1" />
                              </div>
                              <div>
                                <label for="auth_final_page_offset">Pagini fƒÉrƒÉ numƒÉr √Ænainte de OPIS</label>
                                <input type="number" id="auth_final_page_offset" data-phase="final" min="0" max="1" step="1" value="0" />
                              </div>
                            </div>
                            <p class="help-text">Valorile se aplicƒÉ previzualizƒÉrii »ôi exportului documenta»õiei finale.</p>
                          </div>
                          <div class="dossier-step" id="auth_final_step_opis">
                            <h4>Pasul 1 ¬∑ OPIS fazƒÉ finalƒÉ</h4>
                            <p class="muted">Statusul pa»ôilor de mai jos este urmƒÉrit automat pentru a »ôti rapid ce mai trebuie completat.</p>
                            <div class="opis-preview">
                              <div class="opis-title" id="auth_final_opis_title"></div>
                              <ol id="auth_final_opis_list"></ol>
                            </div>
                          </div>
                          <div class="dossier-step" data-step-key="final-letter">
                            <div class="dossier-step-header">
                              <h4>Pasul 2 ¬∑ AdresƒÉ cƒÉtre organism</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="letter" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <textarea id="auth_final_letter" rows="5" placeholder="Introduce»õi adresa pentru documenta»õia finalƒÉ"></textarea>
                            <div class="letter-actions">
                              <button type="button" class="btn ghost small" id="btn_edit_final_letter" data-icon="edit">Deschide editor</button>
                              <button type="button" class="btn secondary" id="btn_preview_final_letter_pdf" data-icon="view">PrevizualizeazƒÉ adresa PDF</button>
                            </div>
                          </div>
                          <div class="dossier-step" data-step-key="final-examReports">
                            <div class="dossier-step-header">
                              <h4>Pasul 3 ¬∑ Procese verbale de examinare sudori</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="examReports" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">√éncarcƒÉ procesul verbal pentru fiecare sudor care a sus»õinut proba.</p>
                            <div class="dossier-doc-list" id="auth_final_exam_docs"></div>
                          </div>
                          <div class="dossier-step" data-step-key="final-writtenWorks">
                            <div class="dossier-step-header">
                              <h4>Pasul 4 ¬∑ LucrƒÉri scrise sudori</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="writtenWorks" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">Ata»ôeazƒÉ lucrarea scrisƒÉ pentru fiecare sudor participant.</p>
                            <div class="dossier-doc-list" id="auth_final_written_docs"></div>
                          </div>
                          <div class="dossier-step" data-step-key="final-labAuthorizations">
                            <div class="dossier-step-header">
                              <h4>Pasul 5 ¬∑ Autoriza»õii ISCIR laborator √ÆncercƒÉri nedistructive</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="labAuthorizations" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">AdaugƒÉ copia autoriza»õiei laboratorului de examinƒÉri nedistructive utilizat.</p>
                            <div class="material-uploader">
                              <div class="material-uploader-controls">
                                <input type="file" id="auth_final_lab_file" accept="application/pdf,image/*" style="display:none;" />
                                <button type="button" class="btn ghost" id="btn_add_final_lab_doc" data-icon="attach">Ata»ôeazƒÉ autoriza»õie</button>
                              </div>
                              <div class="dossier-doc-list" id="auth_final_lab_docs"></div>
                            </div>
                          </div>
                          <div class="dossier-step" data-step-key="final-ndtBulletins">
                            <div class="dossier-step-header">
                              <h4>Pasul 6 ¬∑ Buletine examinare nedistructivƒÉ</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="ndtBulletins" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">√éncarcƒÉ buletinul de examinare pentru fiecare sudor evaluat nedistructiv.</p>
                            <div class="dossier-doc-list" id="auth_final_ndt_docs"></div>
                          </div>
                          <div class="dossier-step" data-step-key="final-destructiveReports">
                            <div class="dossier-step-header">
                              <h4>Pasul 7 ¬∑ Rapoarte de √ÆncercƒÉri distructive</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="destructiveReports" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">Ata»ôeazƒÉ rapoartele probelor distructive pentru fiecare sudor.</p>
                            <div class="dossier-doc-list" id="auth_final_destructive_docs"></div>
                          </div>
                          <div class="dossier-step" data-step-key="final-inspectorReports">
                            <div class="dossier-step-header">
                              <h4>Pasul 8 ¬∑ Procese verbale ale inspectorului de specialitate</h4>
                              <div class="step-visibility">
                                <label class="checkbox-field"><input type="checkbox" data-step-visibility data-phase="final" data-step="inspectorReports" checked /> Include √Æn OPIS »ôi PDF</label>
                              </div>
                            </div>
                            <p class="muted">√éncarcƒÉ procesele verbale √Æntocmite de inspectorul de specialitate.</p>
                            <div class="material-uploader">
                              <div class="material-uploader-controls">
                                <input type="file" id="auth_final_inspector_file" accept="application/pdf,image/*" style="display:none;" />
                                <button type="button" class="btn ghost" id="btn_add_final_inspector_doc" data-icon="attach">Ata»ôeazƒÉ proces verbal</button>
                              </div>
                              <div class="dossier-doc-list" id="auth_final_inspector_docs"></div>
                            </div>
                          </div>
                          <div class="dossier-step">
                            <h4>Pa»ôi suplimentari documenta»õie finalƒÉ</h4>
                            <p class="muted">AdaugƒÉ pa»ôi personaliza»õi pentru documenta»õia finalƒÉ, cu descriere pentru OPIS »ôi documente aferente.</p>
                            <div class="dossier-row-form">
                              <div class="form-row">
                                <div>
                                  <label>Denumire pas final</label>
                                  <input id="auth_final_custom_step_name" placeholder="ex: Proces verbal suplimentar" />
                                </div>
                                <div>
                                  <label>Text OPIS</label>
                                  <input id="auth_final_custom_step_opis" placeholder="ex: Proces verbal suplimentar documenta»õie finalƒÉ" />
                                </div>
                              </div>
                              <div class="dossier-actions">
                                <button type="button" class="btn secondary" id="btn_add_final_custom_step">AdaugƒÉ pas final</button>
                              </div>
                            </div>
                            <p class="muted" id="auth_final_custom_steps_empty">Nu existƒÉ pa»ôi suplimentari pentru documenta»õia finalƒÉ.</p>
                            <div id="auth_final_custom_steps_list" class="custom-step-list"></div>
                          </div>
                        </div>
                      </div>
                      <div class="dossier-archive" id="auth_dossier_archive_section">
                        <h4>ArhivƒÉ dosare PDF salvate</h4>
                        <p class="dossier-archive-empty" id="auth_dossier_archive_empty">Nu existƒÉ dosare salvate √Æn arhivƒÉ.</p>
                        <div class="list hidden" id="auth_dossier_archive_table_wrap">
                          <table>
                            <thead>
                              <tr>
                                <th>Denumire</th>
                                <th>Standard</th>
                                <th>Salvat la</th>
                                <th>Pagini</th>
                                <th></th>
                              </tr>
                            </thead>
                            <tbody id="auth_dossier_archive_tbody"></tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </section>
          </section>

          <section id="view_reports" class="view">
            <section class="card">
              <h2>Rapoarte</h2>
              <div class="content">
                <p class="muted">GenereazƒÉ situa»õiile actualizate pentru sudori, autoriza»õii »ôi omologƒÉri.</p>
                <div class="report-actions">
                  <button class="btn secondary" id="btn_report_welders" data-icon="download">Raport sudori</button>
                  <button class="btn secondary" id="btn_report_authorizations" data-icon="download">Raport autoriza»õii</button>
                  <button class="btn secondary" id="btn_report_procedures" data-icon="download">Raport omologƒÉri</button>
                </div>
              </div>
            </section>
          </section>

          <section id="view_procedures" class="view">
            <section class="card">
              <h2>OmologƒÉri</h2>
              <div class="content">
                <div class="subtabs" id="proc_tabs" role="tablist" aria-label="Sec»õiuni omologƒÉri">
                  <button type="button" class="active" data-tab="proc_form">OmologƒÉri procedee</button>
                  <button type="button" data-tab="proc_existing">Procedee omologate</button>
                  <button type="button" data-tab="proc_dossier">Dosar omologare</button>
                </div>

                <div class="subtab-panel active" data-panel="proc_form">
                  <div class="form-row">
                    <div>
                      <label>Standard</label>
                      <select id="proc_standard">
                        <option value="ISCIR_CR7">ISCIR CR7 (omologare)</option>
                        <option value="ASME_IX">ASME Sec»õiunea IX</option>
                        <option value="EN_ISO_15614">EN ISO 15614</option>
                        <option value="AWS_D1_1">AWS D1.1</option>
                      </select>
                    </div>
                    <div>
                      <label>Procedeu</label>
                      <select id="proc_process">
                        <option>GMAW (MIG/MAG)</option>
                        <option>GTAW (TIG)</option>
                        <option>SMAW (MMA)</option>
                        <option>FCAW</option>
                        <option>SAW</option>
                      </select>
                    </div>
                    <div>
                      <label>Pozi»õie</label>
                      <select id="proc_position">
                        <option>PA</option><option>PB</option><option>PC</option><option>PD</option><option>PE</option><option>PF</option><option>PG</option>
                      </select>
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Sudor (op»õional)</label>
                      <select id="proc_welder_select">
                        <option value="">Procedeu general</option>
                      </select>
                    </div>
                    <div>
                      <label>P-No. (material)</label>
                      <input id="proc_pno" placeholder="ex: P-No. 1" />
                    </div>
                    <div>
                      <label>Interval grosime (t)</label>
                      <input id="proc_thk" placeholder="ex: 3‚Äì12 mm" />
                    </div>
                    <div>
                      <label>Produs</label>
                      <select id="proc_product">
                        <option>PlacƒÉ</option>
                        <option>»öeavƒÉ</option>
                        <option>ColoanƒÉ</option>
                      </select>
                    </div>
                  </div>
                  <div class="form-row">
                    <div>
                      <label>Nr. procedeu</label>
                      <input id="proc_cert" placeholder="ex: WPQR-01" />
                    </div>
                    <div>
                      <label>Emitent</label>
                      <input id="proc_issuer" placeholder="ex: Organism Aprob." />
                    </div>
                    <div>
                      <label>Document procedeu (PDF op»õional)</label>
                      <input id="proc_attachment" type="file" accept="application/pdf" />
                    </div>
                  </div>
                  <div class="toolbar">
                    <button class="btn" id="btn_add_procedure">AdaugƒÉ procedeu</button>
                    <button class="btn ghost" id="btn_refresh_procedures">Re√ÆncarcƒÉ</button>
                  </div>
                </div>

                <div class="subtab-panel" data-panel="proc_existing">
                  <div class="section-title">
                    <strong>Procedee omologate</strong>
                    <span class="tag">nu au datƒÉ de expirare</span>
                  </div>
                  <p class="muted hidden" id="procedures_empty_state">Nu existƒÉ procedee omologate salvate √ÆncƒÉ.</p>
                  <div class="list" id="procedures_list_wrap">
                    <table>
                      <thead>
                        <tr>
                          <th style="width:18%">Standard</th>
                          <th>Procedeu</th>
                          <th>Pozi»õie</th>
                          <th>P-No.</th>
                          <th>t</th>
                          <th>Produs</th>
                          <th>Certificat</th>
                          <th>Sudor asociat</th>
                          <th></th>
                        </tr>
                      </thead>
                      <tbody id="procedures_tbody"></tbody>
                    </table>
                  </div>
                </div>

                <div class="subtab-panel" data-panel="proc_dossier">
                  <p class="muted">√éncarcƒÉ documente generale pentru dosarul de omologare al companiei active.</p>
                  <div class="dossier-actions">
                    <input type="file" id="proc_dossier_file" accept="application/pdf,image/*" />
                    <button type="button" class="btn" id="btn_add_proc_dossier">AdaugƒÉ document</button>
                    <button type="button" class="btn ghost" id="btn_refresh_proc_dossier">Re√ÆncarcƒÉ</button>
                  </div>
                  <div class="dossier-list hidden" id="proc_dossier_list_wrap">
                    <table>
                      <thead>
                        <tr>
                          <th>Document</th>
                          <th>AdƒÉugat</th>
                          <th></th>
                        </tr>
                      </thead>
                      <tbody id="proc_dossier_tbody"></tbody>
                    </table>
                  </div>
                  <p class="dossier-empty" id="proc_dossier_empty">Nu existƒÉ documente √Æn dosarul de omologare.</p>
                </div>
              </div>
            </section>
          </section>

          <section id="view_settings" class="view">
            <div class="card">
              <h2>SetƒÉri generale</h2>
              <div class="content">
                <div class="form-row">
                  <div>
                    <label for="general_inactivity_minutes">Blocare dupƒÉ inactivitate (minute)</label>
                    <input id="general_inactivity_minutes" type="number" min="1" max="120" />
                    <p class="help">DupƒÉ aceastƒÉ perioadƒÉ aplica»õia solicitƒÉ din nou parola de acces.</p>
                  </div>
                </div>
                <div class="form-row">
                  <div>
                    <label for="general_storage_mode">MetodƒÉ de stocare a datelor</label>
                    <select id="general_storage_mode">
                      <option value="browser">Browser (localStorage)</option>
                      <option value="file">Fi»ôier local (File System Access API)</option>
                    </select>
                    <p class="help" id="storage_mode_help">Datele sunt pƒÉstrate √Æn memoria browserului (√Æn general limitatƒÉ la aproximativ 5‚Äì10 MB). Pentru volume mari de fi»ôiere PDF, imagini sau arhive folose»ôte op»õiunea de fi»ôier local.</p>
                    <div class="storage-file-actions hidden" id="storage_file_controls">
                      <div class="btn-row">
                        <button type="button" class="btn secondary" id="btn_storage_pick_file">SelecteazƒÉ fi»ôier bazƒÉ de date</button>
                        <button type="button" class="btn secondary" id="btn_storage_pick_folder">ConecteazƒÉ folder bazƒÉ de date</button>
                        <button type="button" class="btn ghost" id="btn_storage_load_file">√éncarcƒÉ din fi»ôier</button>
                        <button type="button" class="btn ghost" id="btn_storage_reconnect">ReconecteazƒÉ folderul bazei de date</button>
                      </div>
                      <p class="note" id="storage_file_status">Nu a fost selectat niciun fi»ôier. Alege un fi»ôier sau un folder pentru a salva datele local.</p>
                    </div>
                    <div class="storage-transfer-help" id="storage_transfer_help">
                      <p><strong>Transfer pe alt calculator</strong></p>
                      <ol>
                        <li>Folose»ôte butonul ‚ÄûSalveazƒÉ baza de date‚Äù din panoul principal pentru a descƒÉrca fi»ôierul JSON ce con»õine toatƒÉ baza de date, inclusiv fotografiile »ôi documentele √ÆncƒÉrcate (carte de identitate, contract, fi»ôe medicale, autorizƒÉri etc.).</li>
                        <li>CopiazƒÉ fi»ôierul pe noul calculator »ôi √Æn aplica»õie apasƒÉ ‚Äû√éncarcƒÉ din fi»ôier‚Äù pentru a-l importa. DacƒÉ folose»ôti modul ‚ÄûFi»ôier local‚Äù, po»õi transfera direct fi»ôierul configurat »ôi √Æl po»õi selecta din nou aici.</li>
                      </ol>
                      <p class="footnote">Fi»ôierul JSON salveazƒÉ documentele √ÆncƒÉrcate de tine (imagini, PDF-uri, arhive). Rapoartele generate din aplica»õie (dosare, rapoarte PDF) se creeazƒÉ la nevoie »ôi nu sunt pƒÉstrate permanent √Æn baza de date.</p>
                    </div>
                  </div>
                </div>
                <div class="form-row">
                  <div class="checkbox-field">
                    <input type="checkbox" id="general_suspend_login" />
                    <div>
                      <label for="general_suspend_login">SuspendƒÉ solicitarea parolei la pornirea aplica»õiei</label>
                      <p class="help">Po»õi reactiva parola oric√¢nd din acest meniu. Inactivitatea nu va mai bloca automat aplica»õia.</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="card">
              <h2>SetƒÉri companii</h2>
              <div class="content">
                <p class="muted">Redenume»ôte sau activeazƒÉ companiile existente. Folose»ôte ‚ÄûCompanie nouƒÉ‚Äù din antet pentru a adƒÉuga firme suplimentare.</p>
                <div class="company-list" id="company_list"></div>
              </div>
            </div>
          </section>
        </div>
      </main>
      <footer class="app-footer" id="storage_footer_hint">
        Datele introduse sunt pƒÉstrate local √Æn browser prin <span class="mono">localStorage</span>. Folose»ôte butonul ‚ÄûSalveazƒÉ baza de date‚Äù pentru a descƒÉrca un backup JSON.
      </footer>
    </div>
  </div>

  <div id="welder_modal" class="modal" aria-hidden="true">
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="welder_modal_title">
      <button type="button" class="modal-close" data-action="close-welder-modal" aria-label="√énchide">√ó</button>
      <h2 id="welder_modal_title">Detalii sudor</h2>
      <p class="muted">CompleteazƒÉ datele de identificare »ôi ata»ôeazƒÉ documentele necesare dosarului personal.</p>
      <div class="form-row">
        <div>
          <label>Nume »ôi prenume</label>
          <input id="w_name" placeholder="ex: Popescu Ion" />
        </div>
        <div>
          <label>Telefon</label>
          <input id="w_phone" placeholder="ex: 07xx xxx xxx" />
        </div>
        <div>
          <label>Data angajƒÉrii</label>
          <input id="w_hire" type="date" />
        </div>
      </div>
      <div class="form-row">
        <div>
          <label>Panson</label>
          <select id="w_panson">
            <option value="">SelecteazƒÉ panson</option>
          </select>
          <p class="help">Lista este populatƒÉ din sec»õiunea ‚ÄûPansoane‚Äù.</p>
        </div>
        <div>
          <label>Cod de identificare (manual)</label>
          <input id="w_code_manual" placeholder="ex: W-017" />
          <p class="help">DacƒÉ alegi un panson, codul se completeazƒÉ automat. Folose»ôte acest c√¢mp doar pentru coduri personalizate.</p>
        </div>
      </div>
      <div class="divider"></div>
      <div class="form-row">
        <div>
          <label>Fotografie sudor</label>
          <input id="w_photo" type="file" accept="image/*" />
          <div class="attachment-preview" id="w_photo_preview"></div>
        </div>
        <div>
          <label>Carte de identitate</label>
          <input id="w_id_card" type="file" accept="application/pdf,image/*" />
          <div class="attachment-expiry">
            <label for="w_id_card_expiry">Data expirƒÉrii</label>
            <input id="w_id_card_expiry" type="date" />
          </div>
          <div class="attachment-preview" id="w_id_card_preview"></div>
        </div>
      </div>
      <div class="form-row">
        <div>
          <label>DiplomƒÉ</label>
          <input id="w_diploma" type="file" accept="application/pdf,image/*" />
          <div class="attachment-preview" id="w_diploma_preview"></div>
        </div>
        <div>
          <label>Contract</label>
          <input id="w_contract" type="file" accept="application/pdf,image/*" />
          <div class="attachment-preview" id="w_contract_preview"></div>
        </div>
      </div>
      <div class="form-row">
        <div>
          <label>Fi»ôƒÉ de aptitudini</label>
          <input id="w_aptitude" type="file" accept="application/pdf,image/*" />
          <div class="attachment-expiry">
            <label for="w_aptitude_expiry">Data expirƒÉrii</label>
            <input id="w_aptitude_expiry" type="date" />
          </div>
          <div class="attachment-preview" id="w_aptitude_preview"></div>
        </div>
      </div>
      <div class="form-row">
        <div>
          <label>Documente personale (CI/DiplomƒÉ/Contract/Fi»ôƒÉ)</label>
          <input id="w_bundle" type="file" accept="application/pdf,image/*" />
          <div class="attachment-preview" id="w_bundle_preview"></div>
        </div>
      </div>
      <div class="divider"></div>
      <div class="welding-log-section">
        <h3>Fi»ôa de eviden»õƒÉ a lucrƒÉrilor de sudare</h3>
        <p class="muted">CompleteazƒÉ manual interven»õiile sudorului. √énregistrƒÉrile sunt incluse automat √Æn dosarele de prelungire ASME.</p>
        <div class="welding-log-meta">
          <div>
            <label for="w_log_number">NumƒÉr fi»ôƒÉ</label>
            <input id="w_log_number" placeholder="ex: 74/2024" />
          </div>
        </div>
        <div class="welding-log-actions">
          <span class="muted">AdaugƒÉ c√¢te un r√¢nd pentru fiecare lucrare executatƒÉ.</span>
          <button type="button" class="btn ghost small" id="btn_add_welding_log_row">AdaugƒÉ r√¢nd</button>
        </div>
        <div class="welding-log-options">
          <label class="checkbox-field">
            <input type="checkbox" id="w_log_include" checked /> Include fi»ôa √Æn dosarul de autorizare
          </label>
          <button type="button" class="btn ghost small" id="btn_preview_welding_log" data-icon="view">VizualizeazƒÉ fi»ôa (PDF)</button>
        </div>
        <div class="table-scroll">
          <table class="welding-log-table">
            <thead>
              <tr>
                <th>Data</th>
                <th>Nr. contract</th>
                <th>Lucrare</th>
                <th>Material / piesƒÉ</th>
                <th>Grosime</th>
                <th>Procedeu / WPS</th>
                <th>Pozi»õie</th>
                <th>Rezultate ND</th>
                <th>Rezultate D</th>
                <th>Observa»õii inspector</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="w_welding_log_tbody"></tbody>
          </table>
        </div>
      </div>
      <div class="toolbar">
        <button class="btn" id="btn_save_welder">SalveazƒÉ</button>
      </div>
    </div>
  </div>

  <div id="document_viewer" class="document-viewer" aria-hidden="true">
    <div class="document-viewer-dialog" role="dialog" aria-modal="true" aria-labelledby="document_viewer_title">
      <div class="document-viewer-header">
        <div id="document_viewer_title" class="document-viewer-title">Vizualizare document</div>
        <button type="button" class="document-viewer-close" data-action="close-viewer" aria-label="√énchide vizualizarea">√ó</button>
      </div>
      <div class="document-viewer-body" id="document_viewer_body"></div>
    </div>
  </div>

  <div id="branding_modal" class="modal" aria-hidden="true">
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="branding_modal_title">
      <button type="button" class="modal-close" data-action="close-branding-modal" aria-label="√énchide">√ó</button>
      <h2 id="branding_modal_title">SetƒÉri antet &amp; subsol rapoarte</h2>
      <div id="branding_modal_content"></div>
    </div>
  </div>


<script>
const STORAGE_KEY = 'gestiune_sudori_local_v1';
const STORAGE_CONFIG_KEY = 'gestiune_sudori_config_v1';
const STORAGE_MODE_BROWSER = 'browser';
const STORAGE_MODE_FILE = 'file';
const DATABASE_FILE_TYPES = [
  {
    description: 'BazƒÉ de date JSON',
    accept: { 'application/json': ['.json'] },
  },
];
const AUTH_USERNAME = 'inginerSudor';
const AUTH_PASSWORD = 'gestionareSudori2025@';
const AUTH_SESSION_KEY = 'gestiune_sudori_auth_session';
const DEFAULT_AUTH_STANDARD = 'ASME_IX';
const DEFAULT_PROCEDURE_STANDARD = 'ISCIR_CR7';
const QUALIFICATION_CATEGORIES = ['autorizatii', 'procedee'];
const DEFAULT_QUALIFICATION_CATEGORY = 'autorizatii';
const DEFAULT_LETTER_STYLE = { align: 'left', bold: false, size: 12 };
const MS_PER_DAY = 86400000;
const DEFAULT_ASME_PRELIMINARY_LETTER = `Catre:   ISCIR BUCURESTI
          Sector: 5; str. Sf. Elefterie; nr. 47-49; cod: 050524

In atentia:    Inspector de Stat Sef- CRISTIAN MATEI
Referitor:     Personal de specialitate desemnat pentru participare la examenul de autorizare sudori
Subiect:       DOCUMENTATIE TEHNICA PRELIMINARA

Va rugam sa delegati un inspector de specialitate din cadrul ISCIR, pentru participarea la examenul de autorizare sudori in conformitate cu PT N SCP 1-2008 si cod ASME Sect. IX ed.1980, in cadrul SC NIMB CONSMETAL SRL Cernavoda.
Atasam la prezenta dosarul cu documentatia tehnica preliminara intocmita conform prescriptiilor ISCIR.

DIRECTOR GENERAL,
Ing. Alexandru Andries

RTS,
Ing. »öiclete Costel Gabriel`;
const DEFAULT_ASME_FINAL_LETTER = `Catre:   ISCIR BUCURESTI
          Sector: 5; str. Sf. Elefterie; nr. 47-49; cod: 050524

In atentia:    Inspector de Stat Sef- CRISTIAN MATEI
Referitor:     AUTORIZARE SUDORI IN CONFORMITATE CU PT N SCP 1-2008 SI COD ASME SECT.IX ED. 1980
Subiect:       DOCUMENTATIE TEHNICA FINALA

Anexat va transmitem documentatia tehnica finala in vederea autorizarii sudorilor in conformitate cu PT N SCP 1-2008 si COD ASME Sect.IX ed.1980.

DIRECTOR GENERAL,
Ing. Alexandru Andries

RTS,
Ing. Ticlete Gabriel- Costel`;
const DEFAULT_STORAGE_FILE_NAME = 'gestiune_sudori.json';
const STORAGE_HANDLE_DB_NAME = 'gestiune_sudori_handles_v1';
const STORAGE_HANDLE_STORE = 'handles';
const STORAGE_FILE_HANDLE_KEY = 'databaseFile';
const STORAGE_DIRECTORY_HANDLE_KEY = 'databaseDirectory';
const FINAL_WELDER_DOC_CONFIG = [
  {
    key: 'examReports',
    containerId: 'auth_final_exam_docs',
    opisLabel: 'Procese verbale examinare sudori',
    uploadLabel: 'Ata»ôeazƒÉ proces verbal',
    tagLabel: 'Proces verbal',
    emptyMessage: 'Nu existƒÉ procese verbale ata»ôate √ÆncƒÉ.',
  },
  {
    key: 'writtenWorks',
    containerId: 'auth_final_written_docs',
    opisLabel: 'LucrƒÉri scrise sudori',
    uploadLabel: 'Ata»ôeazƒÉ lucrare scrisƒÉ',
    tagLabel: 'Lucrare scrisƒÉ',
    emptyMessage: 'Nu sunt lucrƒÉri scrise ata»ôate.',
  },
  {
    key: 'ndtBulletins',
    containerId: 'auth_final_ndt_docs',
    opisLabel: 'Buletine examinare nedistructivƒÉ',
    uploadLabel: 'Ata»ôeazƒÉ buletin',
    tagLabel: 'Buletin ND',
    emptyMessage: 'Nu existƒÉ buletine nedistructive √ÆncƒÉ.',
  },
  {
    key: 'destructiveReports',
    containerId: 'auth_final_destructive_docs',
    opisLabel: 'Rapoarte √ÆncercƒÉri distructive',
    uploadLabel: 'Ata»ôeazƒÉ raport',
    tagLabel: 'Raport distructiv',
    emptyMessage: 'Nu sunt rapoarte distructive ata»ôate.',
  },
];
const FINAL_WELDER_FALLBACK = {
  examReports: 'proces_verbal.pdf',
  writtenWorks: 'lucrare_scrisa.pdf',
  ndtBulletins: 'buletin_nd.pdf',
  destructiveReports: 'raport_distructiv.pdf',
};
const FINAL_GENERAL_DOC_CONFIG = [
  {
    key: 'labAuthorizations',
    containerId: 'auth_final_lab_docs',
    opisLabel: 'Autoriza»õii ISCIR laborator',
    buttonId: 'btn_add_final_lab_doc',
    fileInputId: 'auth_final_lab_file',
    emptyMessage: 'Nu existƒÉ autoriza»õii ISCIR √ÆncƒÉrcate.',
  },
  {
    key: 'inspectorReports',
    containerId: 'auth_final_inspector_docs',
    opisLabel: 'Procese verbale inspector',
    buttonId: 'btn_add_final_inspector_doc',
    fileInputId: 'auth_final_inspector_file',
    emptyMessage: 'Nu existƒÉ procese verbale ata»ôate.',
  },
];
const FINAL_GENERAL_FALLBACK = {
  labAuthorizations: 'autorizatie_lab.pdf',
  inspectorReports: 'proces_verbal_inspector.pdf',
};
const BASE_STANDARDS = [
  {
    id: 'ASME_IX',
    label: 'ASME Sec»õiunea IX',
    type: 'both',
    group: 'ASME',
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  },
  {
    id: 'ISCIR_CR9',
    label: 'ISCIR CR9 (autorizare)',
    type: 'authorization',
    group: 'ALTE',
    fieldLabels: { process: 'Proces autorizat', position: 'Pozi»õie autorizatƒÉ' },
  },
  {
    id: 'ISCIR_CR7',
    label: 'ISCIR CR7 (omologare)',
    type: 'procedure',
    group: 'ALTE',
    fieldLabels: { process: 'Procedeu omologat', position: 'Pozi»õie omologatƒÉ' },
  },
  {
    id: 'ISO_9606_1',
    label: 'ISO 9606-1',
    type: 'authorization',
    group: 'ISO',
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  },
  {
    id: 'ISO_14732',
    label: 'ISO 14732',
    type: 'authorization',
    group: 'ISO',
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  },
  {
    id: 'AWS_D1_1',
    label: 'AWS D1.1',
    type: 'authorization',
    group: 'AWS',
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  },
  {
    id: 'AWS_D1_6',
    label: 'AWS D1.6',
    type: 'authorization',
    group: 'AWS',
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  },
  {
    id: 'EN_287',
    label: 'EN 287',
    type: 'authorization',
    group: 'ALTE',
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  },
  {
    id: 'EN_ISO_15614',
    label: 'EN ISO 15614',
    type: 'procedure',
    group: 'ALTE',
    fieldLabels: { process: 'Procedeu', position: 'Pozi»õie' },
  },
];
const PRINT_STYLES = `
@page portrait { size: A4 portrait; margin: 18mm 18mm 20mm; }
@page landscape { size: A4 landscape; margin: 16mm 18mm 18mm; }
@page portrait-full { size: A4 portrait; margin: 0; }
@page landscape-full { size: A4 landscape; margin: 0; }
body{ font-family: 'Segoe UI','Roboto',sans-serif; color:#1a2240; margin:0; }
.print-document{ page-break-after:always; position:relative; min-height:100vh; padding:70px 40px 70px; box-sizing:border-box; }
.print-document:last-of-type{ page-break-after:auto; }
.print-document.portrait{ page: portrait; }
.print-document.landscape{ page: landscape; }
.print-document.portrait.full-bleed{ page: portrait-full; }
.print-document.landscape.full-bleed{ page: landscape-full; }
.print-document.full-bleed{ padding:48px 24px 48px; }
.print-document.full-bleed .print-header,.print-document.full-bleed .print-footer{ left:24px; right:24px; }
.print-document.full-bleed .print-header{ top:16px; }
.print-document.full-bleed .print-footer{ bottom:16px; }
.print-document.no-branding{ padding-top:0; padding-bottom:0; }
.print-document.no-branding .print-header,.print-document.no-branding .print-footer{ display:none; }
.print-document.no-branding .print-body{ margin-top:0; margin-bottom:0; }
.print-document.full-bleed.no-branding{ padding:0; }
.print-document.full-bleed.no-branding .print-body.full-bleed{ height:100vh; }
.print-header,.print-footer{ position:absolute; left:40px; right:40px; }
.print-header{ top:20px; }
.print-footer{ bottom:20px; }
.print-body{ margin-top:90px; margin-bottom:70px; }
.print-body.full-bleed{ margin:0; padding:0; height:calc(100vh - 120px); display:flex; flex-direction:column; }
.print-body.full-bleed .attachment-section.pdf-attachment{ flex:1; display:flex; flex-direction:column; }
.print-body.full-bleed .attachment-section.pdf-attachment .attachment-frame{ flex:1; height:100%; }
.print-title{ font-size:20px; font-weight:700; margin:0 0 12px; text-align:center; }
.print-subtitle{ font-size:14px; margin:0 0 18px; text-align:center; }
.print-table{ width:100%; border-collapse:collapse; font-size:12px; }
.print-table th,.print-table td{ border:1px solid #1f2f5c; padding:6px 8px; vertical-align:top; }
.print-table thead th{ background:#e5ecff; text-transform:uppercase; font-size:11px; letter-spacing:.6px; }
.print-table tbody tr:nth-child(even){ background:#f8faff; }
.opis-list{ list-style:none; padding:0; margin:24px 0 0; font-size:13px; }
.opis-list li{ display:flex; align-items:flex-end; gap:12px; margin-bottom:8px; }
.opis-list .opis-info{ flex:1; display:flex; flex-direction:column; gap:4px; }
.opis-list .opis-label{ flex:1; display:flex; align-items:flex-end; font-weight:600; }
.opis-list .opis-label span{ position:relative; z-index:1; padding-right:8px; background:#fff; }
.opis-list .opis-label::after{ content:""; flex:1; border-bottom:1px dotted rgba(31,42,61,.35); margin:0 0 6px 12px; }
.opis-list .opis-detail{ font-size:12px; color:#5f6c87; margin-top:2px; }
.opis-list .opis-page{ font-weight:600; min-width:110px; text-align:right; }
.letter-body{ font-size:13px; line-height:1.7; white-space:pre-wrap; }
.letter-body.formatted-letter{ font-size:13px; line-height:1.7; color:#1f2a3d; white-space:normal; }
.letter-body.formatted-letter .letter-rows{ display:flex; flex-direction:column; gap:6px; margin-bottom:18px; }
.letter-body.formatted-letter .letter-row{ display:flex; gap:18px; align-items:flex-start; }
.letter-body.formatted-letter .letter-label{ min-width:150px; font-weight:700; }
.letter-body.formatted-letter .letter-value{ flex:1; font-weight:400; }
.letter-body.formatted-letter .letter-gap{ height:12px; }
.letter-body.formatted-letter .letter-paragraphs{ display:flex; flex-direction:column; gap:12px; }
.letter-body.formatted-letter .letter-paragraphs p{ margin:0; }
.letter-body.formatted-letter .letter-signatures{ display:flex; flex-wrap:wrap; gap:48px; margin-top:48px; }
.letter-body.formatted-letter .letter-signature-block{ flex:1; min-width:180px; display:flex; flex-direction:column; gap:6px; }
.letter-body.formatted-letter .letter-signature-title{ font-weight:700; text-transform:uppercase; }
.letter-body.formatted-letter .letter-signature-name{ font-weight:600; }
.print-note{ color:#5a6285; font-size:11px; }
.section-heading{ font-size:18px; font-weight:600; margin:0 0 12px; text-align:left; }
.section-text{ font-size:13px; line-height:1.6; white-space:pre-wrap; }
.doc-list{ display:flex; flex-direction:column; gap:8px; font-size:13px; }
.doc-item{ display:flex; justify-content:space-between; gap:16px; border:1px solid #d9e1ff; border-radius:12px; padding:10px 14px; }
.doc-item strong{ font-weight:600; }
.dossier-table td > div{ margin-bottom:4px; }
.dossier-table td > div:last-child{ margin-bottom:0; }
.branding-row{ display:flex; flex-wrap:nowrap; gap:var(--branding-gap, 16px); align-items:center; justify-content:space-between; }
.branding-row .branding-block{ flex:1 1 0; min-width:0; display:flex; justify-content:flex-start; align-items:center; gap:10px; word-break:break-word; }
.branding-row .branding-block.align-center{ justify-content:center; text-align:center; }
.branding-row .branding-block.align-right{ justify-content:flex-end; text-align:right; }
.branding-row .branding-block img{ max-height:56px; width:auto; max-width:100%; object-fit:contain; margin-inline:auto; }
.attachment-section{ display:flex; flex-direction:column; gap:14px; font-size:13px; }
.attachment-section.bare{ gap:0; height:100%; flex:1; }
.attachment-section.bare .attachment-frame{ flex:1; }
.attachment-meta{ font-size:12px; color:#3f4b7f; display:flex; flex-direction:column; gap:4px; }
.attachment-frame{ border:1px solid #c9d4f9; border-radius:12px; padding:12px; background:#f6f8ff; min-height:640px; display:flex; align-items:center; justify-content:center; }
.attachment-frame.bare{ border:none; background:none; padding:0; min-height:0; height:100%; width:100%; }
.attachment-frame img{ max-width:100%; max-height:100%; object-fit:contain; border-radius:8px; }
.attachment-frame.bare img{ border-radius:0; width:100%; height:100%; object-fit:contain; }
.attachment-frame object,.attachment-frame embed,.attachment-frame iframe{ width:100%; height:100%; min-height:100%; border:none; border-radius:8px; background:#fff; display:block; }
.attachment-frame.bare object,.attachment-frame.bare embed,.attachment-frame.bare iframe{ border-radius:0; }
.attachment-section.pdf-attachment{ gap:12px; height:100%; }
.attachment-section.pdf-attachment .attachment-frame{ border:none; background:none; padding:0; min-height:auto; display:block; height:100%; }
.attachment-section.pdf-attachment .attachment-meta{ margin-bottom:12px; }
.attachment-section.pdf-attachment .attachment-frame object,
.attachment-section.pdf-attachment .attachment-frame embed,
.attachment-section.pdf-attachment .attachment-frame iframe{ border-radius:0; background:#fff; height:100%; }
.attachment-fallback{ font-size:11px; color:#5a6285; margin:6px 0 0; }
`;
const PRINT_DELAY = 350;
const PDF_PAGE_DIMENSIONS = {
  portrait: { width: 595.28, height: 841.89 },
  landscape: { width: 841.89, height: 595.28 },
};
const PDF_PAGE_PIXEL_DIMENSIONS = {
  portrait: { width: 794, height: 1123 },
  landscape: { width: 1123, height: 794 },
};
const attachmentRegistry = new Map();
let attachmentSequence = 1;
let activeViewerUrl = null;
const ESCAPE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "\"": "&quot;",
  "'": "&#039;",
};

function cloneBaseStandards(){
  return BASE_STANDARDS.map(item => ({
    ...item,
    fieldLabels: item.fieldLabels ? { ...item.fieldLabels } : { process: 'Proces', position: 'Pozi»õie' },
  }));
}

function normalizeStandard(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim() ? raw.id.trim() : null;
  if(!id){
    return null;
  }
  const base = BASE_STANDARDS.find(item => item.id === id);
  const label = typeof raw.label === 'string' && raw.label.trim()
    ? raw.label.trim()
    : base && base.label ? base.label : id;
  const type = raw.type === 'authorization' || raw.type === 'procedure' || raw.type === 'both'
    ? raw.type
    : (base && base.type ? base.type : 'authorization');
  const group = typeof raw.group === 'string' && raw.group.trim()
    ? raw.group.trim()
    : base && base.group ? base.group : 'ALTE';
  const fieldLabels = base && base.fieldLabels ? { ...base.fieldLabels } : { process: 'Proces', position: 'Pozi»õie' };
  if(raw.fieldLabels && typeof raw.fieldLabels === 'object'){
    if(raw.fieldLabels.process){
      fieldLabels.process = String(raw.fieldLabels.process);
    }
    if(raw.fieldLabels.position){
      fieldLabels.position = String(raw.fieldLabels.position);
    }
  }
  return { id, label, type, group, fieldLabels };
}

function ensureStandards(list){
  const normalized = new Map();
  (Array.isArray(list) ? list : []).map(normalizeStandard).filter(Boolean).forEach(entry => {
    normalized.set(entry.id, entry);
  });
  BASE_STANDARDS.forEach(base => {
    if(!normalized.has(base.id)){
      normalized.set(base.id, {
        ...base,
        fieldLabels: base.fieldLabels ? { ...base.fieldLabels } : { process: 'Proces', position: 'Pozi»õie' },
      });
    }
  });
  return Array.from(normalized.values());
}

function ensureStateStandards(){
  if(!state || !Array.isArray(state.standards)){
    if(!state){
      state = createDefaultState();
    }
    state.standards = ensureStandards(state && state.standards);
  }
  return state.standards;
}

function ensureGeneralSettings(){
  if(!state || typeof state !== 'object'){
    state = createDefaultState();
  }
  if(!state.generalSettings || typeof state.generalSettings !== 'object'){
    state.generalSettings = normalizeGeneralSettings();
  } else {
    state.generalSettings.inactivityMinutes = clampInactivityMinutes(state.generalSettings.inactivityMinutes);
    if(state.generalSettings.storageMode !== STORAGE_MODE_FILE){
      state.generalSettings.storageMode = STORAGE_MODE_BROWSER;
    }
    if(typeof state.generalSettings.storageFileName !== 'string'){
      state.generalSettings.storageFileName = '';
    }
    if(typeof state.generalSettings.storageDirectoryName !== 'string'){
      state.generalSettings.storageDirectoryName = '';
    }
    state.generalSettings.suspendLogin = state.generalSettings.suspendLogin === true;
  }
  return state.generalSettings;
}

function getStorageMode(){
  const settings = ensureGeneralSettings();
  return settings.storageMode === STORAGE_MODE_FILE ? STORAGE_MODE_FILE : STORAGE_MODE_BROWSER;
}

function isFileStorageMode(){
  return getStorageMode() === STORAGE_MODE_FILE;
}

function getStorageFileName(){
  const settings = ensureGeneralSettings();
  return typeof settings.storageFileName === 'string' ? settings.storageFileName : '';
}

function getStorageDirectoryName(){
  const settings = ensureGeneralSettings();
  return typeof settings.storageDirectoryName === 'string' ? settings.storageDirectoryName : '';
}

function isLoginSuspended(){
  const settings = ensureGeneralSettings();
  return settings.suspendLogin === true;
}

function getInactivityMinutes(){
  const settings = ensureGeneralSettings();
  return settings.inactivityMinutes;
}

function getInactivityTimeoutMs(){
  if(isLoginSuspended()){
    return 0;
  }
  return getInactivityMinutes() * 60000;
}

function setGeneralInactivityMinutes(value){
  const minutes = clampInactivityMinutes(value);
  const settings = ensureGeneralSettings();
  if(settings.inactivityMinutes !== minutes){
    settings.inactivityMinutes = minutes;
    persistState();
  }
  restartInactivityTimer();
  return minutes;
}

function setLoginSuspended(flag){
  const next = !!flag;
  const settings = ensureGeneralSettings();
  if(settings.suspendLogin === next){
    persistConfigurationSnapshot();
    if(next){
      setAuthenticationState(true);
      updateAuthNotice('Acces fƒÉrƒÉ parolƒÉ activat din setƒÉri generale.');
    } else {
      lockApplication('mode-change');
    }
    renderGeneralSettings();
    return next;
  }
  settings.suspendLogin = next;
  persistState();
  renderGeneralSettings();
  if(next){
    try {
      if(window.sessionStorage){
        window.sessionStorage.setItem(AUTH_SESSION_KEY, '1');
      }
    } catch (err) {
      console.warn('Nu s-a putut actualiza sesiunea de autentificare.', err);
    }
    setAuthenticationState(true);
    updateAuthNotice('Acces fƒÉrƒÉ parolƒÉ activat din setƒÉri generale.');
  } else {
    lockApplication('mode-change');
  }
  return next;
}

function renderGeneralSettings(){
  const inactivityInput = document.getElementById('general_inactivity_minutes');
  if(inactivityInput){
    const minutes = getInactivityMinutes();
    if(Number(inactivityInput.value) !== Number(minutes)){
      inactivityInput.value = minutes;
    }
  }
  const suspendCheckbox = document.getElementById('general_suspend_login');
  if(suspendCheckbox){
    suspendCheckbox.checked = isLoginSuspended();
  }
  renderStorageSettings();
  updateStorageModeIndicators();
}

function renderStorageSettings(){
  const mode = getStorageMode();
  const select = document.getElementById('general_storage_mode');
  if(select && select.value !== mode){
    select.value = mode;
  }
  const controls = document.getElementById('storage_file_controls');
  const supported = isFileStorageSupported();
  if(controls){
    if(mode === STORAGE_MODE_FILE){
      controls.classList.remove('hidden');
      controls.classList.toggle('disabled', !supported);
    } else {
      controls.classList.add('hidden');
      controls.classList.remove('disabled');
    }
  }
  const help = document.getElementById('storage_mode_help');
  if(help){
    let message = mode === STORAGE_MODE_FILE
      ? 'Datele vor fi salvate √Æntr-un fi»ôier local sau √Æntr-un folder conectat prin File System Access API.'
      : 'Datele sunt pƒÉstrate √Æn memoria browserului, care oferƒÉ de regulƒÉ 5‚Äì10 MB disponibili.';
    if(mode === STORAGE_MODE_FILE && !supported){
      message += ' Browserul curent nu suportƒÉ salvarea directƒÉ √Æn fi»ôiere.';
    }
    help.textContent = message;
  }
  const status = document.getElementById('storage_file_status');
  if(status){
    if(mode === STORAGE_MODE_FILE){
      if(!supported){
        status.textContent = 'Func»õia necesitƒÉ un browser modern (Chrome, Edge sau similar).';
      } else {
        const name = getStorageFileName();
        const directory = getStorageDirectoryName();
        if(storageNeedsReconnect){
          status.textContent = directory
            ? `Accesul la folderul ‚Äû${directory}‚Äù trebuie reautorizat. Folose»ôte ‚ÄûReconecteazƒÉ folderul bazei de date‚Äù.`
            : 'Permisiunea pentru fi»ôierul selectat trebuie re√ÆnnoitƒÉ. ApasƒÉ ‚ÄûReconecteazƒÉ folderul bazei de date‚Äù.';
        } else if(storageDirectoryHandle && storageFileHandle && name){
          const directoryLabel = directory ? `folderul ‚Äû${directory}‚Äù` : 'folderul conectat';
          status.textContent = `${directoryLabel}. Fi»ôierul ${name} este actualizat automat.`;
        } else if(storageFileHandle && name){
          status.textContent = `Fi»ôier selectat: ${name}. Toate documentele √ÆncƒÉrcate sunt salvate √Æn acest fi»ôier.`;
        } else if(name){
          status.textContent = `Fi»ôierul ${name} trebuie reconectat. SelecteazƒÉ din nou fi»ôierul sau conecteazƒÉ folderul pentru a continua salvarea automatƒÉ.`;
        } else {
          status.textContent = 'Nu a fost selectat niciun fi»ôier. Alege un fi»ôier sau conecteazƒÉ un folder pentru a salva datele local.';
        }
      }
    } else {
      status.textContent = 'Stocarea √Æn browser este activƒÉ. Datele »ôi documentele √ÆncƒÉrcate sunt pƒÉstrate local, dar limitele de 5‚Äì10 MB se aplicƒÉ; descarcƒÉ backup-uri periodice.';
    }
  }
  const pickBtn = document.getElementById('btn_storage_pick_file');
  if(pickBtn){
    pickBtn.disabled = mode !== STORAGE_MODE_FILE || !supported;
  }
  const folderBtn = document.getElementById('btn_storage_pick_folder');
  if(folderBtn){
    folderBtn.disabled = mode !== STORAGE_MODE_FILE || !supported;
  }
  const loadBtn = document.getElementById('btn_storage_load_file');
  if(loadBtn){
    loadBtn.disabled = mode !== STORAGE_MODE_FILE || !supported;
  }
  const reconnectBtn = document.getElementById('btn_storage_reconnect');
  if(reconnectBtn){
    reconnectBtn.disabled = mode !== STORAGE_MODE_FILE || !supported || (!storageDirectoryHandle && !storageFileHandle && !getStorageFileName());
  }
}

function updateStorageModeIndicators(){
  const mode = getStorageMode();
  const fileName = getStorageFileName();
  const directoryName = getStorageDirectoryName();
  const safeName = fileName ? escapeHtml(fileName) : '';
  const safeDirectory = directoryName ? escapeHtml(directoryName) : '';
  const hint = document.getElementById('storage_mode_hint');
  if(hint){
    hint.textContent = mode === STORAGE_MODE_FILE
      ? 'Frontend HTML ‚Äì date salvate √Æn fi»ôier local sau folder conectat'
      : 'Frontend HTML ‚Äì date stocate √Æn browser (limitƒÉ ~5‚Äì10 MB)';
  }
  const sidebarHint = document.getElementById('sidebar_storage_hint');
  if(sidebarHint){
    if(mode === STORAGE_MODE_FILE){
      if(storageNeedsReconnect){
        const folderLabel = safeDirectory ? `folderul <strong>${safeDirectory}</strong>` : 'folderul/fi»ôierul conectat';
        sidebarHint.innerHTML = `Permisiunea pentru ${folderLabel} trebuie re√ÆnnoitƒÉ.<br/>Folose»ôte ‚ÄûReconecteazƒÉ folderul bazei de date‚Äù.`;
      } else if(storageDirectoryHandle && storageFileHandle && safeName){
        const folderLabel = safeDirectory ? `folderul <strong>${safeDirectory}</strong>` : 'folderul conectat';
        sidebarHint.innerHTML = `Date salvate √Æn ${folderLabel} ‚Äì fi»ôierul <strong>${safeName}</strong> este actualizat automat.<br/>PƒÉstreazƒÉ copii de siguran»õƒÉ periodice.`;
      } else if(storageFileHandle && safeName){
        sidebarHint.innerHTML = `Date salvate √Æn fi»ôierul local <strong>${safeName}</strong>.<br/>PƒÉstreazƒÉ copii de siguran»õƒÉ periodice.`;
      } else if(safeName){
        sidebarHint.innerHTML = `Stocarea √Æn fi»ôier este activƒÉ, dar fi»ôierul <strong>${safeName}</strong> trebuie reconectat.<br/>Deschide setƒÉrile »ôi selecteazƒÉ din nou fi»ôierul sau folderul.`;
      } else {
        sidebarHint.innerHTML = 'Stocare √Æn fi»ôier local activƒÉ. SelecteazƒÉ un fi»ôier sau conecteazƒÉ un folder pentru a salva datele »ôi pƒÉstreazƒÉ copii de siguran»õƒÉ periodice.';
      }
    } else {
      sidebarHint.innerHTML = 'Date salvate local √Æn browser (limitƒÉ aproximativ 5‚Äì10 MB).<br/>DescarcƒÉ periodic backup-ul JSON.';
    }
  }
  const footerHint = document.getElementById('storage_footer_hint');
  if(footerHint){
    if(mode === STORAGE_MODE_FILE){
      if(storageNeedsReconnect){
        const folderLabel = safeDirectory ? `folderul <span class="mono">${safeDirectory}</span>` : 'folderul conectat';
        footerHint.innerHTML = `ReconecteazƒÉ ${folderLabel} pentru a continua salvarea automatƒÉ. Folose»ôte butonul ‚ÄûReconecteazƒÉ folderul bazei de date‚Äù.`;
      } else if(storageDirectoryHandle && storageFileHandle && safeName){
        const folderLabel = safeDirectory ? `folderul <span class="mono">${safeDirectory}</span>` : 'folderul conectat';
        footerHint.innerHTML = `Datele introduse sunt pƒÉstrate √Æn ${folderLabel}, fi»ôierul <span class="mono">${safeName}</span>. Folose»ôte ‚ÄûSalveazƒÉ baza de date‚Äù pentru un backup suplimentar.`;
      } else if(storageFileHandle && safeName){
        footerHint.innerHTML = `Datele introduse sunt pƒÉstrate √Æn fi»ôierul selectat <span class="mono">${safeName}</span>. Folose»ôte ‚ÄûSalveazƒÉ baza de date‚Äù pentru un backup suplimentar.`;
      } else if(safeName){
        footerHint.innerHTML = `Fi»ôierul <span class="mono">${safeName}</span> trebuie reconectat pentru salvare automatƒÉ. AcceseazƒÉ setƒÉrile »ôi selecteazƒÉ din nou fi»ôierul sau folderul.`;
      } else {
        footerHint.innerHTML = 'Datele vor fi pƒÉstrate √Æn fi»ôierul local ales. SelecteazƒÉ un fi»ôier sau conecteazƒÉ un folder din setƒÉri »ôi folose»ôte ‚ÄûSalveazƒÉ baza de date‚Äù pentru un backup suplimentar.';
      }
    } else {
      footerHint.innerHTML = 'Datele introduse sunt pƒÉstrate local √Æn browser prin <span class="mono">localStorage</span> (limitƒÉ aproximativƒÉ 5‚Äì10 MB). Folose»ôte butonul ‚ÄûSalveazƒÉ baza de date‚Äù pentru a descƒÉrca un backup JSON.';
    }
  }
}

function clearInactivityTimer(){
  if(inactivityTimer){
    clearTimeout(inactivityTimer);
    inactivityTimer = null;
  }
}

function scheduleInactivityTimer(){
  clearInactivityTimer();
  if(!isAuthenticated || isLoginSuspended()){
    return;
  }
  const timeout = getInactivityTimeoutMs();
  if(timeout <= 0){
    return;
  }
  inactivityTimer = setTimeout(() => lockApplication('timeout'), timeout);
}

function restartInactivityTimer(){
  if(!isAuthenticated || isLoginSuspended()){
    clearInactivityTimer();
    return;
  }
  scheduleInactivityTimer();
}

function handleUserActivity(){
  if(!isAuthenticated || isLoginSuspended()){
    return;
  }
  scheduleInactivityTimer();
}

function bindInactivityListeners(){
  if(inactivityListenersBound){
    return;
  }
  inactivityListenersBound = true;
  ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'].forEach(eventName => {
    document.addEventListener(eventName, handleUserActivity, true);
  });
  window.addEventListener('focus', handleUserActivity);
  document.addEventListener('visibilitychange', () => {
    if(!document.hidden){
      handleUserActivity();
    }
  });
}

function updateAuthNotice(message){
  const notice = document.getElementById('auth_notice');
  if(!notice){
    return;
  }
  if(message){
    notice.textContent = message;
    notice.classList.add('visible');
  } else {
    notice.textContent = '';
    notice.classList.remove('visible');
  }
}

function lockApplication(reason){
  if(isLoginSuspended()){
    return;
  }
  clearInactivityTimer();
  try {
    if(window.sessionStorage){
      window.sessionStorage.removeItem(AUTH_SESSION_KEY);
    }
  } catch (err) {
    console.warn('Nu s-a putut curƒÉ»õa sesiunea de autentificare.', err);
  }
  if(reason === 'timeout'){
    const minutes = getInactivityMinutes();
    updateAuthNotice(`Sesiunea a fost blocatƒÉ dupƒÉ ${minutes} minute de inactivitate. Reintrodu parola pentru a continua.`);
  } else {
    updateAuthNotice('');
  }
  setAuthenticationState(false);
}

function registerAttachment(attachment){
  if(!attachment || !attachment.data){
    return null;
  }
  const id = `att_${attachmentSequence++}`;
  attachmentRegistry.set(id, attachment);
  return id;
}

function getAttachmentById(id){
  return attachmentRegistry.get(id) || null;
}

function dataUrlToObjectUrl(dataUrl){
  try {
    if(!dataUrl || !dataUrl.startsWith('data:')){
      return dataUrl;
    }
    const parts = dataUrl.split(',');
    if(parts.length < 2){
      return dataUrl;
    }
    const meta = parts[0];
    const base64 = parts[1];
    const match = meta.match(/^data:([^;]+);base64$/i);
    if(!match){
      return dataUrl;
    }
    const mime = match[1];
    const binary = atob(base64);
    const length = binary.length;
    const bytes = new Uint8Array(length);
    for(let index = 0; index < length; index += 1){
      bytes[index] = binary.charCodeAt(index);
    }
    const blob = new Blob([bytes], { type: mime });
    return URL.createObjectURL(blob);
  } catch (error) {
    console.warn('Nu s-a putut converti documentul pentru previzualizare.', error);
    return dataUrl;
  }
}

function buildBrandingHtml(items, company){
  if(!items || items.length === 0){
    return '';
  }
  const spacing = getCompanyBrandingSpacing(company);
  const grouped = new Map();
  items.forEach(item => {
    if(!item){
      return;
    }
    const rowValue = Number(item.row);
    const row = Number.isInteger(rowValue) && rowValue > 0 ? rowValue : 1;
    if(!grouped.has(row)){
      grouped.set(row, []);
    }
    grouped.get(row).push(item);
  });
  const rows = Array.from(grouped.keys()).sort((a, b) => a - b);
  return rows.map(rowNumber => {
    const rowItems = grouped.get(rowNumber) || [];
    const rowContent = rowItems.map(item => {
      if(!item){
        return '';
      }
      const alignClass = item.align === 'center'
        ? ' align-center'
        : (item.align === 'right' ? ' align-right' : '');
      if(item.type === 'image' && item.data){
        return `<div class="branding-block${alignClass}"><img src="${item.data}" alt="Branding" /></div>`;
      }
      if(item.type === 'text' && item.content){
        const size = clampBrandingTextSize(item.size);
        return `<div class="branding-block${alignClass}" style="font-size:${size}px;">${escapeHtml(String(item.content)).replace(/\n/g, '<br />')}</div>`;
      }
      return '';
    }).join('');
    if(!rowContent){
      return '';
    }
    return `<div class="branding-row" style="--branding-gap:${spacing}px">${rowContent}</div>`;
  }).join('');
}

function renderPrintPage(options){
  const company = options && options.company ? options.company : getActiveCompany();
  const orientation = options && options.orientation ? options.orientation : 'portrait';
  const fullBleed = Boolean(options && options.fullBleed);
  const showBranding = options && options.showBranding !== undefined ? Boolean(options.showBranding) : true;
  const heading = fullBleed ? '' : (options && options.heading ? options.heading : '');
  const subheading = fullBleed ? '' : (options && options.subheading ? options.subheading : '');
  const content = options && options.content ? options.content : '';
  const branding = ensureReportBranding(company);
  const headerHtml = showBranding ? buildBrandingHtml(branding.header, company) : '';
  const footerHtml = showBranding ? buildBrandingHtml(branding.footer, company) : '';
  const headingHtml = heading ? `<h1 class="print-title">${heading}</h1>` : '';
  const subheadingHtml = subheading ? `<p class="print-subtitle">${subheading}</p>` : '';
  const bodyClasses = ['print-body'];
  if(fullBleed){
    bodyClasses.push('full-bleed');
  }
  if(options && options.bodyClass){
    bodyClasses.push(options.bodyClass);
  }
  const sectionClasses = ['print-document', orientation];
  if(fullBleed){
    sectionClasses.push('full-bleed');
  }
  if(!showBranding){
    sectionClasses.push('no-branding');
  }
  return `
    <section class="${sectionClasses.join(' ')}">
      <header class="print-header">${headerHtml}</header>
      <footer class="print-footer">${footerHtml}</footer>
      <div class="${bodyClasses.join(' ')}">
        ${headingHtml}
        ${subheadingHtml}
        ${content}
      </div>
    </section>
  `;
}

function openPrintPreview(config){
  const pages = config && Array.isArray(config.pages) ? config.pages.filter(Boolean) : [];
  if(pages.length === 0){
    alert('Nu existƒÉ con»õinut de tipƒÉrit.');
    return;
  }
  const title = config && config.title ? config.title : 'Raport';
  const printWindow = window.open('', '_blank');
  if(!printWindow){
    alert('Fereastra de tipƒÉrire a fost blocatƒÉ de browser.');
    return;
  }
  const htmlParts = [
    '<!DOCTYPE html><html lang="ro"><head><meta charset="utf-8" />',
    `<title>${escapeHtml(title)}</title>`,
    `<style>${PRINT_STYLES}</style>`,
    '</head><body>',
    pages.join(''),
    `<script>(function(){var PRINT_DELAY=${PRINT_DELAY};function triggerPrint(){setTimeout(function(){try{window.focus();}catch(e){}window.print();},PRINT_DELAY);}function cleanupObjectUrls(){var selectors=['object[data^="blob:"]','embed[src^="blob:"]','iframe[src^="blob:"]'];var nodes=Array.prototype.slice.call(document.querySelectorAll(selectors.join(',')));nodes.forEach(function(node){var attr=node.tagName==='OBJECT'?'data':'src';var value=node.getAttribute(attr);if(!value){return;}var base=value.split('#')[0];if(base&&base.indexOf('blob:')===0){try{URL.revokeObjectURL(base);}catch(err){}}});}window.addEventListener('beforeunload',cleanupObjectUrls);window.addEventListener('load',function(){var resources=Array.prototype.slice.call(document.querySelectorAll('object,embed,iframe,img'));if(resources.length===0){triggerPrint();return;}var remaining=resources.length;var fired=false;function resolveOne(){if(remaining>0){remaining-=1;}if(remaining<=0&&!fired){fired=true;if(fallback){clearTimeout(fallback);}triggerPrint();}}var fallback=setTimeout(function(){if(!fired){fired=true;triggerPrint();}},10000);resources.forEach(function(node){var settled=false;var waitTimer=null;function settle(){if(settled){return;}settled=true;if(waitTimer){clearTimeout(waitTimer);waitTimer=null;}resolveOne();}waitTimer=setTimeout(function(){settle();},5000);if(node.tagName==='IMG'){if(node.complete){settle();return;}node.addEventListener('load',settle,{once:true});node.addEventListener('error',settle,{once:true});return;}node.addEventListener('load',settle,{once:true});node.addEventListener('error',settle,{once:true});if(node.tagName==='IFRAME'){try{var doc=node.contentDocument;if(doc&&doc.readyState==='complete'){settle();}}catch(err){}}});});})();<\/script>`,
    '</body></html>',
  ];
  printWindow.document.open();
  printWindow.document.write(htmlParts.join(''));
  printWindow.document.close();
}

function getStandardById(id){
  if(!id){
    return null;
  }
  const standards = ensureStateStandards();
  return standards.find(entry => entry.id === id) || null;
}

function syncStandardsFromState(){
  const standards = ensureStateStandards();
  const known = new Map(standards.map(entry => [entry.id, entry]));
  let changed = false;
  if(state && Array.isArray(state.companies)){
    state.companies.forEach(company => {
      if(!company || !Array.isArray(company.qualifications)){
        return;
      }
      company.qualifications.forEach(q => {
        if(!q || !q.standard){
          return;
        }
        const id = String(q.standard);
        if(!known.has(id)){
          const type = q.category === 'procedee' ? 'procedure' : 'authorization';
          const entry = normalizeStandard({ id, label: id, type });
          if(entry){
            known.set(entry.id, entry);
            changed = true;
          }
        }
      });
    });
  }
  if(changed){
    state.standards = Array.from(known.values());
  }
}

function getStandardLabel(id){
  const entry = getStandardById(id);
  if(entry){
    return entry.label || entry.id;
  }
  const fallback = BASE_STANDARDS.find(item => item.id === id);
  return fallback ? fallback.label : (id || '');
}

function getFieldLabelsForStandard(standard){
  const entry = getStandardById(standard);
  if(entry && entry.fieldLabels){
    return {
      process: entry.fieldLabels.process || 'Proces',
      position: entry.fieldLabels.position || 'Pozi»õie',
    };
  }
  return { process: 'Proces', position: 'Pozi»õie' };
}

function getStandardsForType(type){
  return ensureStateStandards().filter(entry => entry && (entry.type === type || entry.type === 'both'));
}

function getAuthorizationGroups(){
  const groups = new Set();
  getStandardsForType('authorization').forEach(entry => {
    if(entry && entry.group){
      groups.add(entry.group);
    }
  });
  if(groups.size === 0){
    groups.add('ALTE');
  }
  return Array.from(groups);
}

function normalizeNameInput(raw){
  if(typeof raw !== 'string'){
    return '';
  }
  return raw.trim().replace(/\s+/g, ' ');
}

function getNameParts(value){
  const normalized = normalizeNameInput(value).toLowerCase();
  if(!normalized){
    return { full: '', family: '', given: '' };
  }
  const segments = normalized.split(' ');
  return {
    full: normalized,
    family: segments[0] || '',
    given: segments.slice(1).join(' ') || '',
  };
}

function toDateInputValue(date){
  if(!(date instanceof Date) || Number.isNaN(date.getTime())){
    return null;
  }
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function parseDateOnly(value){
  if(!value){
    return null;
  }
  if(typeof value === 'string'){
    const trimmed = value.trim();
    if(!trimmed){
      return null;
    }
    const isoMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if(isoMatch){
      const year = Number(isoMatch[1]);
      const month = Number(isoMatch[2]);
      const day = Number(isoMatch[3]);
      const date = new Date(year, month - 1, day);
      if(Number.isNaN(date.getTime())){
        return null;
      }
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const parsed = new Date(trimmed);
    if(Number.isNaN(parsed.getTime())){
      return null;
    }
    parsed.setHours(0, 0, 0, 0);
    return parsed;
  }
  if(value instanceof Date){
    const cloned = new Date(value.getTime());
    if(Number.isNaN(cloned.getTime())){
      return null;
    }
    cloned.setHours(0, 0, 0, 0);
    return cloned;
  }
  if(typeof value === 'number' && Number.isFinite(value)){
    const numericDate = new Date(value);
    if(Number.isNaN(numericDate.getTime())){
      return null;
    }
    numericDate.setHours(0, 0, 0, 0);
    return numericDate;
  }
  return null;
}

function normalizeDateValue(value){
  const date = parseDateOnly(value);
  if(!date){
    return null;
  }
  const formatted = toDateInputValue(date);
  return formatted || null;
}

function formatDisplayDate(value){
  const date = parseDateOnly(value);
  if(!date){
    if(typeof value === 'string'){
      return value;
    }
    return '';
  }
  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const year = date.getFullYear();
  return `${day}.${month}.${year}`;
}

function cleanDossierSectionLabel(label){
  if(label === undefined || label === null){
    return 'Sec»õiune';
  }
  const text = String(label);
  const cleaned = text.replace(/^\s*Pasul\s*\d+\s*[¬∑:\-‚Äì‚Äî\.]*\s*/i, '').trim();
  if(cleaned){
    return cleaned;
  }
  const fallback = text.trim();
  return fallback || 'Sec»õiune';
}

function buildAuthorizationLetterContent(dossier, options){
  const phase = options && options.phase === 'final' ? 'final' : 'preliminary';
  const standard = dossier && typeof dossier.standard === 'string' ? dossier.standard : '';
  const style = phase === 'final'
    ? ensureFinalPhaseLetterStyle(dossier)
    : ensureDossierLetterStyle(dossier);
  const baseValue = phase === 'final'
    ? (ensureFinalPhase(dossier).address || '')
    : (dossier && typeof dossier.letter === 'string' ? dossier.letter : '');
  const fontSize = Number(style && style.size) ? Number(style.size) : DEFAULT_LETTER_STYLE.size;
  const effectiveSize = standard === 'ASME_IX' ? Math.max(13, fontSize) : fontSize;
  const normalizedHtml = normalizeLetterInput(baseValue, standard, phase);
  const className = standard === 'ASME_IX' ? 'letter-body formatted-letter' : 'letter-body';
  const sections = [`font-size:${effectiveSize}px`, `line-height:1.6`];
  const containerAlign = style && style.align ? style.align : 'left';
  sections.push(`text-align:${containerAlign}`);
  const weight = style && style.bold ? 600 : 400;
  sections.push(`font-weight:${weight}`);
  const innerHtml = normalizedHtml ? normalizedHtml : '<p>AdresƒÉ necompletatƒÉ.</p>';
  return `<div class="${className}" style="${sections.join(';')}">${innerHtml}</div>`;
}

function formatGenericLetterHtml(text){
  return escapeHtml(text).replace(/\n/g, '<br />');
}

function formatAsmeLetterHtml(text){
  const normalized = typeof text === 'string' ? text.replace(/\r\n/g, '\n').trim() : '';
  if(!normalized){
    return '<p>AdresƒÉ necompletatƒÉ.</p>';
  }
  const blocks = [];
  const lines = normalized.split('\n');
  let current = [];
  lines.forEach(line => {
    if(line.trim() === ''){
      if(current.length){
        blocks.push(current);
        current = [];
      }
    } else {
      current.push(line);
    }
  });
  if(current.length){
    blocks.push(current);
  }
  const headerLines = blocks.length ? blocks.shift() : [];
  let bodyBlocks = blocks.slice();
  let signatureLines = [];
  if(bodyBlocks.length){
    const lastBlock = bodyBlocks[bodyBlocks.length - 1];
    const signatureHint = Array.isArray(lastBlock)
      && lastBlock.some(line => /director|rts|ing\./i.test(line));
    if(signatureHint){
      signatureLines = bodyBlocks.pop();
    }
  }
  const headerHtml = headerLines
    .map(line => {
      const trimmed = line.trim();
      if(!trimmed){
        return '';
      }
      const colonIndex = trimmed.indexOf(':');
      if(colonIndex === -1){
        return `<div class="letter-row"><span class="letter-value">${escapeHtml(trimmed)}</span></div>`;
      }
      const label = trimmed.slice(0, colonIndex + 1).trim();
      const value = trimmed.slice(colonIndex + 1).trim();
      return `<div class="letter-row"><span class="letter-label">${escapeHtml(label)}</span><span class="letter-value">${escapeHtml(value)}</span></div>`;
    })
    .filter(Boolean)
    .join('');
  const paragraphHtml = bodyBlocks
    .map(block => block.map(line => line.trim()).filter(Boolean))
    .filter(block => block.length)
    .map(block => `<p>${block.map(line => escapeHtml(line)).join(' ')}</p>`)
    .join('');
  const signatureColumns = splitSignatureColumns(signatureLines);
  const signaturesHtml = signatureColumns
    .map(column => {
      if(!column || column.length === 0){
        return '';
      }
      const [title, ...rest] = column;
      const nameHtml = rest.map(line => `<span class="letter-signature-name">${escapeHtml(line)}</span>`).join('');
      return `<div class="letter-signature-block"><span class="letter-signature-title">${escapeHtml(title)}</span>${nameHtml}</div>`;
    })
    .filter(Boolean)
    .join('');
  const sections = [];
  if(headerHtml){
    sections.push(`<div class="letter-rows">${headerHtml}</div>`);
  }
  if(paragraphHtml){
    if(headerHtml){
      sections.push('<div class="letter-gap"></div>');
    }
    sections.push(`<div class="letter-paragraphs">${paragraphHtml}</div>`);
  }
  if(signaturesHtml){
    sections.push(`<div class="letter-signatures">${signaturesHtml}</div>`);
  }
  return sections.join('');
}

const LETTER_ALLOWED_TAGS = new Set([
  'P', 'DIV', 'SPAN', 'BR', 'STRONG', 'B', 'EM', 'U', 'UL', 'OL', 'LI',
  'TABLE', 'TBODY', 'TR', 'TD', 'TH', 'THEAD', 'TFOOT', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'
]);
const LETTER_ALLOWED_CLASSES = new Set([
  'letter-rows', 'letter-row', 'letter-label', 'letter-value', 'letter-gap',
  'letter-paragraphs', 'letter-signatures', 'letter-signature-block',
  'letter-signature-title', 'letter-signature-name'
]);
const LETTER_ALLOWED_STYLES = new Set([
  'text-align', 'font-weight', 'font-style', 'text-decoration', 'font-size', 'margin',
  'margin-left', 'margin-right', 'margin-top', 'margin-bottom', 'line-height',
  'letter-spacing', 'padding-left', 'padding-right', 'padding-top', 'padding-bottom'
]);

function sanitizeLetterStyle(value){
  if(typeof value !== 'string'){ return ''; }
  const parts = value.split(';');
  const cleaned = parts
    .map(part => part.trim())
    .filter(Boolean)
    .map(part => {
      const index = part.indexOf(':');
      if(index === -1){
        return '';
      }
      const property = part.slice(0, index).trim().toLowerCase();
      const rawValue = part.slice(index + 1).trim();
      if(!LETTER_ALLOWED_STYLES.has(property)){
        return '';
      }
      if(/url\s*\(/i.test(rawValue)){
        return '';
      }
      const valueLower = rawValue.toLowerCase();
      if(property === 'text-align'){
        if(!['left', 'center', 'right', 'justify', 'start', 'end'].includes(valueLower)){
          return '';
        }
      } else if(property === 'font-size'){
        const match = rawValue.match(/([0-9]+(?:\.[0-9]+)?)\s*(px|pt)/i);
        if(!match){
          return '';
        }
        let sizeValue = parseFloat(match[1]);
        if(!Number.isFinite(sizeValue)){
          return '';
        }
        const unit = match[2].toLowerCase();
        if(unit === 'pt'){
          sizeValue = sizeValue * (96 / 72);
        } else if(unit !== 'px'){
          return '';
        }
        const clamped = Math.min(64, Math.max(8, Math.round(sizeValue)));
        return `${property}:${clamped}px`;
      }
      return `${property}:${rawValue}`;
    })
    .filter(Boolean);
  return cleaned.join(';');
}

function sanitizeLetterHtml(html){
  const raw = typeof html === 'string' ? html : '';
  if(!raw.trim()){
    return '';
  }
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${raw}</div>`, 'text/html');
  const container = doc.body.firstElementChild || doc.body;
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, null);
  const nodesToUnwrap = [];
  while(walker.nextNode()){
    const element = walker.currentNode;
    if(!element || element === container){
      continue;
    }
    let tag = element.tagName.toUpperCase();
    if(tag === 'B'){
      const strong = doc.createElement('strong');
      while(element.firstChild){
        strong.appendChild(element.firstChild);
      }
      element.parentNode.replaceChild(strong, element);
      continue;
    }
    if(tag === 'I'){
      const em = doc.createElement('em');
      while(element.firstChild){
        em.appendChild(element.firstChild);
      }
      element.parentNode.replaceChild(em, element);
      continue;
    }
    tag = element.tagName.toUpperCase();
    if(!LETTER_ALLOWED_TAGS.has(tag)){
      nodesToUnwrap.push(element);
      continue;
    }
    if(element.hasAttribute('class')){
      const classes = element.className
        .split(/\s+/)
        .map(token => token.trim())
        .filter(token => LETTER_ALLOWED_CLASSES.has(token));
      if(classes.length > 0){
        element.className = classes.join(' ');
      } else {
        element.removeAttribute('class');
      }
    }
    Array.from(element.attributes).forEach(attr => {
      const name = attr.name.toLowerCase();
      if(name === 'style'){
        const sanitized = sanitizeLetterStyle(attr.value);
        if(sanitized){
          element.setAttribute('style', sanitized);
        } else {
          element.removeAttribute('style');
        }
        return;
      }
      if(name === 'class'){
        return;
      }
      if(name === 'align'){
        const value = attr.value ? String(attr.value).toLowerCase() : '';
        if(['left', 'center', 'right', 'justify'].includes(value)){
          element.style.textAlign = value;
        }
        element.removeAttribute('align');
        return;
      }
      element.removeAttribute(attr.name);
    });
  }
  while(nodesToUnwrap.length){
    const node = nodesToUnwrap.pop();
    if(!node || !node.parentNode){
      continue;
    }
    while(node.firstChild){
      node.parentNode.insertBefore(node.firstChild, node);
    }
    node.parentNode.removeChild(node);
  }
  const sanitized = container.innerHTML.trim();
  return sanitized;
}

function isLikelyHtml(value){
  if(typeof value !== 'string'){
    return false;
  }
  return /<[^>]+>/.test(value);
}

function plainTextToLetterHtml(text){
  if(typeof text !== 'string'){
    return '';
  }
  const normalized = text.replace(/\r\n/g, '\n').trim();
  if(!normalized){
    return '';
  }
  const paragraphs = normalized.split(/\n{2,}/).map(block => block.trim()).filter(Boolean);
  return paragraphs
    .map(block => `<p>${escapeHtml(block).replace(/\n/g, '<br />')}</p>`)
    .join('');
}

function letterHtmlToPlainText(html){
  if(typeof html !== 'string' || !html.trim()){
    return '';
  }
  const sanitized = sanitizeLetterHtml(html);
  if(!sanitized){
    return isLikelyHtml(html) ? '' : html.trim();
  }
  const decoded = sanitized
    .replace(/<br\s*\/?>(\s*)/gi, '\n$1')
    .replace(/<\/(p|div|li|h[1-6])>/gi, '\n\n')
    .replace(/<\/(tr)>/gi, '\n')
    .replace(/<\/(td|th)>/gi, '\t')
    .replace(/<[^>]+>/g, '')
    .replace(/\u00a0/g, ' ')
    .replace(/\t+/g, ' ')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
  const textarea = document.createElement('textarea');
  textarea.innerHTML = decoded;
  return textarea.value.replace(/\u00a0/g, ' ').trim();
}

function normalizeLetterInput(value, standard, phase){
  const raw = typeof value === 'string' ? value.trim() : '';
  if(!raw){
    return '';
  }
  if(isLikelyHtml(raw)){
    const sanitized = sanitizeLetterHtml(raw);
    if(sanitized){
      return sanitized;
    }
  }
  if(standard === 'ASME_IX'){
    return formatAsmeLetterHtml(raw);
  }
  return plainTextToLetterHtml(raw);
}

function splitSignatureColumns(lines){
  if(!Array.isArray(lines)){
    return [];
  }
  const trimmed = lines.map(line => line.trim()).filter(Boolean);
  if(trimmed.length === 0){
    return [];
  }
  const twoColumnRows = trimmed
    .map(line => line.split(/\s{2,}/).map(part => part.trim()).filter(Boolean));
  const hasTwoColumns = twoColumnRows.every(row => row.length >= 2);
  if(hasTwoColumns){
    const columns = [];
    twoColumnRows.forEach(row => {
      row.slice(0, 2).forEach((value, index) => {
        if(!columns[index]){
          columns[index] = [];
        }
        columns[index].push(value);
      });
    });
    return columns.filter(column => Array.isArray(column) && column.length);
  }
  const separated = trimmed.join('\n').split(/\n\s*\n/).map(block => block.trim()).filter(Boolean);
  if(separated.length >= 2){
    return separated.slice(0, 2).map(block => block.split('\n').map(line => line.trim()).filter(Boolean));
  }
  if(trimmed.length >= 4){
    return [trimmed.slice(0, 2), trimmed.slice(2, 4)];
  }
  if(trimmed.length >= 2){
    const mid = Math.ceil(trimmed.length / 2);
    return [trimmed.slice(0, mid), trimmed.slice(mid)];
  }
  return [trimmed];
}

function buildLetterEditorHtml(config){
  const sanitized = {
    phase: config && config.phase === 'final' ? 'final' : 'preliminary',
    text: config && typeof config.text === 'string' ? config.text : '',
    style: normalizeLetterStyle(config && config.style),
    title: config && typeof config.title === 'string' ? config.title : '',
    standardLabel: config && typeof config.standardLabel === 'string' ? config.standardLabel : '',
    standard: config && typeof config.standard === 'string' ? config.standard : '',
    heading: config && typeof config.heading === 'string' ? config.heading : '',
    subheading: config && typeof config.subheading === 'string' ? config.subheading : '',
    headerHtml: config && typeof config.headerHtml === 'string' ? config.headerHtml : '',
    footerHtml: config && typeof config.footerHtml === 'string' ? config.footerHtml : '',
  };
  const configJson = JSON.stringify(sanitized).replace(/</g, '\\u003c').replace(/>/g, '\\u003e');
  const pageTitle = sanitized.title || 'Editor adresƒÉ dosar';
  const allowedTagsJson = JSON.stringify(Array.from(LETTER_ALLOWED_TAGS));
  const allowedClassesJson = JSON.stringify(Array.from(LETTER_ALLOWED_CLASSES));
  const allowedStylesJson = JSON.stringify(Array.from(LETTER_ALLOWED_STYLES));
  return `<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<title>${pageTitle.replace(/`/g, '\\`')}</title>
<style>
  *{ box-sizing:border-box; }
  body{ margin:0; font-family:'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif; background:#eef2fb; color:#1f2a3d; }
  .editor-shell{ max-width:860px; margin:0 auto; padding:28px 32px 36px; display:flex; flex-direction:column; gap:18px; }
  header h1{ margin:0; font-size:22px; font-weight:700; letter-spacing:.3px; }
  header .subtitle{ margin:0; font-size:13px; color:#5c6787; }
  .hint{ margin:0; font-size:12px; color:#6b789d; background:#fff; border:1px dashed #c9d3ef; padding:12px 14px; border-radius:12px; }
  .toolbar{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .toolbar-button{ appearance:none; border:none; background:#dfe7fb; color:#1f2a3d; padding:8px 14px; border-radius:10px; font-size:12px; font-weight:600; cursor:pointer; transition:background .2s, color .2s; }
  .toolbar-button.active{ background:#2f55d4; color:#fff; box-shadow:0 4px 10px rgba(47,85,212,.35); }
  .toolbar-button:hover{ background:#cdd7f5; }
  .size-control{ display:flex; align-items:center; gap:10px; font-size:12px; color:#435072; background:#fff; border-radius:12px; padding:6px 12px; border:1px solid #d9e2ff; }
  .size-control input{ width:140px; }
  .editor-area{ width:100%; min-height:280px; border-radius:16px; border:1px solid #cdd6f1; padding:16px; font-size:14px; line-height:1.6; color:#1f2a3d; box-shadow:0 6px 18px rgba(45,72,140,.08); background:#fff; outline:none; transition:border .2s, box-shadow .2s; position:relative; overflow-y:auto; white-space:normal; word-break:break-word; }
  .editor-area:focus{ outline:3px solid rgba(47,85,212,.25); border-color:#2f55d4; }
  .editor-area.is-empty::before{ content:attr(data-placeholder); position:absolute; left:16px; top:16px; color:#98a3c3; pointer-events:none; font-style:italic; }
  .editor-area p{ margin:0 0 12px; }
  .editor-area p:last-child{ margin-bottom:0; }
  .preview-wrapper{ background:#fff; border-radius:18px; border:1px solid #d8e0f2; box-shadow:0 10px 24px rgba(38,58,112,.12); padding:20px 24px; display:flex; flex-direction:column; gap:14px; }
  .preview-header{ font-size:13px; font-weight:600; color:#5a6a90; text-transform:uppercase; letter-spacing:.4px; }
  .preview-frame{ --preview-scale:.48; border:1px solid #dfe3f5; border-radius:14px; padding:16px; background:linear-gradient(180deg,#f8faff 0%,#eef3ff 100%); display:flex; justify-content:center; align-items:flex-start; overflow:auto; max-width:100%; }
  .preview-stage{ position:relative; width:calc(794px * var(--preview-scale)); height:calc(1123px * var(--preview-scale)); min-width:calc(794px * var(--preview-scale)); min-height:calc(1123px * var(--preview-scale)); }
  .preview-stage .preview-page{ position:absolute; top:0; left:0; width:794px; min-height:1123px; transform:scale(var(--preview-scale)); transform-origin:top left; background:#fff; border-radius:12px; box-shadow:0 18px 40px rgba(31,50,94,.18); overflow:hidden; }
  .preview-stage.is-empty{ width:100%; min-width:0; height:auto; min-height:0; display:flex; align-items:center; justify-content:center; }
  .preview-stage.is-empty .preview-placeholder{ width:100%; }
  .preview-placeholder{ position:relative; width:100%; padding:48px 24px; text-align:center; font-size:12px; color:#6b789d; line-height:1.6; display:flex; align-items:center; justify-content:center; }
  .preview-page .print-document{ width:794px; min-height:1123px; padding:70px 40px 70px; box-sizing:border-box; position:relative; background:#fff; }
  .preview-page .print-header,
  .preview-page .print-footer{ position:absolute; left:40px; right:40px; display:flex; flex-direction:column; gap:8px; color:#1f2a3d; font-size:11px; line-height:1.4; }
  .preview-page .print-header{ top:20px; }
  .preview-page .print-footer{ bottom:20px; }
  .preview-page .print-body{ margin-top:90px; margin-bottom:70px; font-size:13px; line-height:1.7; color:#1f2a3d; }
  .preview-page .print-title{ font-size:20px; font-weight:700; margin:0 0 12px; text-align:center; }
  .preview-page .print-subtitle{ font-size:14px; margin:0 0 18px; text-align:center; }
  .branding-row{ display:flex; flex-wrap:nowrap; gap:var(--branding-gap, 16px); align-items:flex-start; justify-content:space-between; }
  .branding-row .branding-block{ flex:1 1 0; min-width:0; display:flex; justify-content:flex-start; align-items:center; word-break:break-word; }
  .branding-row .branding-block.align-center{ justify-content:center; text-align:center; }
  .branding-row .branding-block.align-right{ justify-content:flex-end; text-align:right; }
  .branding-row .branding-block img{ max-height:64px; width:auto; max-width:100%; object-fit:contain; margin-inline:auto; }
  .letter-body{ font-size:13px; line-height:1.7; white-space:normal; color:#1f2a3d; }
  .letter-body p{ margin:0 0 12px; }
  .letter-body p:last-child{ margin-bottom:0; }
  .letter-body strong{ font-weight:700; }
  .letter-body em{ font-style:italic; }
  .letter-body u{ text-decoration:underline; }
  .letter-body table{ width:100%; border-collapse:collapse; margin:12px 0; }
  .letter-body table th,
  .letter-body table td{ border:1px solid rgba(31,50,94,.25); padding:6px 8px; text-align:left; vertical-align:top; }
  .letter-body.formatted-letter{ color:#1f2a3d; }
  .letter-body.formatted-letter .letter-rows{ display:flex; flex-direction:column; gap:6px; margin-bottom:18px; }
  .letter-body.formatted-letter .letter-row{ display:flex; gap:18px; align-items:flex-start; }
  .letter-body.formatted-letter .letter-label{ min-width:150px; font-weight:700; }
  .letter-body.formatted-letter .letter-value{ flex:1; font-weight:400; }
  .letter-body.formatted-letter .letter-gap{ height:12px; }
  .letter-body.formatted-letter .letter-paragraphs{ display:flex; flex-direction:column; gap:12px; }
  .letter-body.formatted-letter .letter-paragraphs p{ margin:0; }
  .letter-body.formatted-letter .letter-signatures{ display:flex; flex-wrap:wrap; gap:48px; margin-top:48px; }
  .letter-body.formatted-letter .letter-signature-block{ flex:1; min-width:180px; display:flex; flex-direction:column; gap:6px; }
  .letter-body.formatted-letter .letter-signature-title{ font-weight:700; text-transform:uppercase; }
  .letter-body.formatted-letter .letter-signature-name{ font-weight:600; }
  @media (max-width:900px){
    .preview-frame{ --preview-scale:.42; }
  }
  @media (max-width:720px){
    .preview-frame{ --preview-scale:.36; padding:12px; }
  }
  .editor-actions{ display:flex; justify-content:flex-end; gap:12px; }
  .editor-actions button{ appearance:none; border:none; border-radius:12px; padding:10px 20px; font-size:13px; font-weight:600; cursor:pointer; transition:background .2s, box-shadow .2s, color .2s; }
  .editor-actions button.primary{ background:#2f55d4; color:#fff; box-shadow:0 6px 16px rgba(47,85,212,.35); }
  .editor-actions button.primary:hover{ background:#2446b1; }
  .editor-actions button.secondary{ background:#e2e8fb; color:#1f2a3d; }
  .editor-actions button.secondary:hover{ background:#ccd7f5; }
  @media (max-width:720px){
    .editor-shell{ padding:20px; }
    .size-control{ width:100%; justify-content:space-between; }
    .toolbar{ gap:6px; }
  }
</style>
</head>
<body>
  <div class="editor-shell">
    <header>
      <h1 id="editorTitle"></h1>
      <p class="subtitle" id="editorSubtitle"></p>
    </header>
    <p class="hint">Folose»ôte editorul pentru a formata adresa. ModificƒÉrile sunt salvate »ôi reutilizate la dosarele viitoare. TasteazƒÉ <strong>Ctrl+S</strong> sau apasƒÉ ‚ÄûSalveazƒÉ‚Äù pentru a aplica schimbƒÉrile.</p>
    <div class="toolbar">
      <button type="button" class="toolbar-button" data-align="left">Aliniere st√¢nga</button>
      <button type="button" class="toolbar-button" data-align="center">Centrare</button>
      <button type="button" class="toolbar-button" id="toggleBold">Text √Ængro»ôat</button>
      <label class="size-control">Dimensiune text
        <input type="range" id="fontSizeInput" min="10" max="36" step="1" />
        <span id="fontSizeValue"></span>
      </label>
    </div>
    <div id="letterEditor" class="editor-area is-empty" contenteditable="true" spellcheck="false" data-placeholder="Introdu textul adresei aici..." aria-label="Con»õinut adresƒÉ"></div>
    <div class="preview-wrapper">
      <div class="preview-header">Previzualizare</div>
      <div class="preview-frame">
        <div class="preview-stage is-empty" id="previewStage">
          <div class="preview-placeholder">Introduce»õi textul adresei pentru a vedea pagina generatƒÉ cu antet »ôi subsol.</div>
        </div>
      </div>
    </div>
    <div class="editor-actions">
      <button type="button" class="secondary" id="btnCancel">Renun»õƒÉ</button>
      <button type="button" class="primary" id="btnSave">SalveazƒÉ</button>
    </div>
  </div>
<script>
const CONFIG = ${configJson};
const LETTER_ALLOWED_TAGS = new Set(${allowedTagsJson});
const LETTER_ALLOWED_CLASSES = new Set(${allowedClassesJson});
const LETTER_ALLOWED_STYLES = new Set(${allowedStylesJson});
(function(){
  const defaultSize = ${DEFAULT_LETTER_STYLE.size};
  function escapeHtml(value){
    return String(value || '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
  function sanitizeLetterStyle(value){
    if(typeof value !== 'string'){ return ''; }
    return value.split(';')
      .map(part => part.trim())
      .filter(Boolean)
      .map(part => {
        const index = part.indexOf(':');
        if(index === -1){
          return '';
        }
        const property = part.slice(0, index).trim().toLowerCase();
        const rawValue = part.slice(index + 1).trim();
        if(!LETTER_ALLOWED_STYLES.has(property)){
          return '';
        }
        if(/url\\s*\\(/i.test(rawValue)){
          return '';
        }
        const lower = rawValue.toLowerCase();
        if(property === 'text-align' && !['left','center','right','justify','start','end'].includes(lower)){
          return '';
        }
        return property + ':' + rawValue;
      })
      .filter(Boolean)
      .join(';');
  }
  function sanitizeHtml(html){
    const raw = typeof html === 'string' ? html : '';
    if(!raw.trim()){
      return '';
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString('<div>' + raw + '</div>', 'text/html');
    const container = doc.body.firstElementChild || doc.body;
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, null);
    const unwrap = [];
    while(walker.nextNode()){
      let element = walker.currentNode;
      if(!element || element === container){
        continue;
      }
      if(element.tagName === 'B'){
        const strong = doc.createElement('strong');
        while(element.firstChild){
          strong.appendChild(element.firstChild);
        }
        element.parentNode.replaceChild(strong, element);
        element = strong;
      } else if(element.tagName === 'I'){
        const em = doc.createElement('em');
        while(element.firstChild){
          em.appendChild(element.firstChild);
        }
        element.parentNode.replaceChild(em, element);
        element = em;
      }
      const tag = element.tagName.toUpperCase();
      if(!LETTER_ALLOWED_TAGS.has(tag)){
        unwrap.push(element);
        continue;
      }
      if(element.hasAttribute('class')){
        const classes = element.className.split(/\\s+/).map(token => token.trim()).filter(token => LETTER_ALLOWED_CLASSES.has(token));
        if(classes.length){
          element.className = classes.join(' ');
        } else {
          element.removeAttribute('class');
        }
      }
      Array.from(element.attributes).forEach(attr => {
        const name = attr.name.toLowerCase();
        if(name === 'style'){
          const sanitizedStyle = sanitizeLetterStyle(attr.value);
          if(sanitizedStyle){
            element.setAttribute('style', sanitizedStyle);
          } else {
            element.removeAttribute('style');
          }
          return;
        }
        if(name === 'class'){
          return;
        }
        if(name === 'align'){
          const value = attr.value ? String(attr.value).toLowerCase() : '';
          if(['left','center','right','justify'].includes(value)){
            element.style.textAlign = value;
          }
          element.removeAttribute('align');
          return;
        }
        element.removeAttribute(attr.name);
      });
    }
    while(unwrap.length){
      const node = unwrap.pop();
      if(!node || !node.parentNode){
        continue;
      }
      while(node.firstChild){
        node.parentNode.insertBefore(node.firstChild, node);
      }
      node.parentNode.removeChild(node);
    }
    return (container.innerHTML || '').trim();
  }
  function isLikelyHtml(value){
    return typeof value === 'string' && /<[^>]+>/.test(value);
  }
  function plainTextToHtml(text){
    if(typeof text !== 'string'){
      return '';
    }
    const normalized = text.replace(/\\r\\n/g, '\\n').trim();
    if(!normalized){
      return '';
    }
    return normalized.split(/\\n{2,}/)
      .map(block => block.trim())
      .filter(Boolean)
      .map(block => '<p>' + escapeHtml(block).replace(/\\n/g, '<br />') + '</p>')
      .join('');
  }
  function plainTextToLetterHtml(text){
    return plainTextToHtml(text);
  }
  function splitSignatureColumns(lines){
    if(!Array.isArray(lines)){
      return [];
    }
    const trimmed = lines.map(line => line.trim()).filter(Boolean);
    if(trimmed.length === 0){
      return [];
    }
    const twoColumnRows = trimmed
      .map(line => line.split(/\s{2,}/).map(part => part.trim()).filter(Boolean));
    const hasTwoColumns = twoColumnRows.every(row => row.length >= 2);
    if(hasTwoColumns){
      const columns = [];
      twoColumnRows.forEach(row => {
        row.slice(0, 2).forEach((value, index) => {
          if(!columns[index]){
            columns[index] = [];
          }
          columns[index].push(value);
        });
      });
      return columns.filter(column => Array.isArray(column) && column.length);
    }
    const separated = trimmed.join('\\n').split(/\\n\\s*\\n/).map(block => block.trim()).filter(Boolean);
    if(separated.length >= 2){
      return separated.slice(0, 2).map(block => block.split('\\n').map(line => line.trim()).filter(Boolean));
    }
    if(trimmed.length >= 4){
      return [trimmed.slice(0, 2), trimmed.slice(2, 4)];
    }
    if(trimmed.length >= 2){
      const mid = Math.ceil(trimmed.length / 2);
      return [trimmed.slice(0, mid), trimmed.slice(mid)];
    }
    return [trimmed];
  }
  function formatAsmeLetterHtml(text){
    const normalized = typeof text === 'string' ? text.replace(/\\r\\n/g, '\\n').trim() : '';
    if(!normalized){
      return '<p>AdresƒÉ necompletatƒÉ.</p>';
    }
    const blocks = [];
    const lines = normalized.split('\\n');
    let current = [];
    lines.forEach(line => {
      if(line.trim() === ''){
        if(current.length){
          blocks.push(current);
          current = [];
        }
      } else {
        current.push(line);
      }
    });
    if(current.length){
      blocks.push(current);
    }
    const headerLines = blocks.length ? blocks.shift() : [];
    let bodyBlocks = blocks.slice();
    let signatureLines = [];
    if(bodyBlocks.length){
      const lastBlock = bodyBlocks[bodyBlocks.length - 1];
      const signatureHint = Array.isArray(lastBlock)
        && lastBlock.some(line => /director|rts|ing\./i.test(line));
      if(signatureHint){
        signatureLines = bodyBlocks.pop();
      }
    }
    const headerHtml = headerLines
      .map(line => {
        const trimmed = line.trim();
        if(!trimmed){
          return '';
        }
        const colonIndex = trimmed.indexOf(':');
        if(colonIndex === -1){
          return '<div class="letter-row"><span class="letter-value">' + escapeHtml(trimmed) + '</span></div>';
        }
        const label = trimmed.slice(0, colonIndex + 1).trim();
        const value = trimmed.slice(colonIndex + 1).trim();
        return '<div class="letter-row"><span class="letter-label">' + escapeHtml(label) + '</span><span class="letter-value">' + escapeHtml(value) + '</span></div>';
      })
      .filter(Boolean)
      .join('');
    const paragraphHtml = bodyBlocks
      .map(block => block.map(line => line.trim()).filter(Boolean))
      .filter(block => block.length)
      .map(block => '<p>' + block.map(line => escapeHtml(line)).join(' ') + '</p>')
      .join('');
    const signatureColumns = splitSignatureColumns(signatureLines);
    const signaturesHtml = signatureColumns
      .map(column => {
        if(!column || column.length === 0){
          return '';
        }
        const [title, ...rest] = column;
        const nameHtml = rest.map(line => '<span class="letter-signature-name">' + escapeHtml(line) + '</span>').join('');
        return '<div class="letter-signature-block"><span class="letter-signature-title">' + escapeHtml(title) + '</span>' + nameHtml + '</div>';
      })
      .filter(Boolean)
      .join('');
    const sections = [];
    if(headerHtml){
      sections.push('<div class="letter-rows">' + headerHtml + '</div>');
    }
    if(paragraphHtml){
      if(headerHtml){
        sections.push('<div class="letter-gap"></div>');
      }
      sections.push('<div class="letter-paragraphs">' + paragraphHtml + '</div>');
    }
    if(signaturesHtml){
      sections.push('<div class="letter-signatures">' + signaturesHtml + '</div>');
    }
    return sections.join('') || '<p>AdresƒÉ necompletatƒÉ.</p>';
  }
  function normalizeLetterInput(value, standard, phase){
    const raw = typeof value === 'string' ? value.trim() : '';
    if(!raw){
      return '';
    }
    if(isLikelyHtml(raw)){
      const sanitized = sanitizeHtml(raw);
      if(sanitized){
        return sanitized;
      }
    }
    if(standard === 'ASME_IX'){
      return formatAsmeLetterHtml(raw);
    }
    return plainTextToLetterHtml(raw);
  }
  function normalizeInput(value){
    const raw = typeof value === 'string' ? value.trim() : '';
    if(!raw){
      return '';
    }
    if(isLikelyHtml(raw)){
      const sanitized = sanitizeHtml(raw);
      if(sanitized){
        return sanitized;
      }
    }
    return plainTextToHtml(raw);
  }
  function detectAlignment(selection){
    if(!selection || selection.rangeCount === 0){
      return state.currentAlign || state.baseAlign || 'left';
    }
    let node = selection.anchorNode;
    if(!node){
      return state.currentAlign || state.baseAlign || 'left';
    }
    if(node.nodeType === Node.TEXT_NODE){
      node = node.parentElement;
    }
    while(node && node !== editor){
      if(node.nodeType === Node.ELEMENT_NODE){
        if(node.style && node.style.textAlign){
          return node.style.textAlign.toLowerCase();
        }
        const computed = window.getComputedStyle(node);
        if(computed && computed.textAlign){
          const value = computed.textAlign.toLowerCase();
          if(['left','center','right','justify'].includes(value)){
            return value;
          }
        }
      }
      node = node.parentElement;
    }
    return state.currentAlign || state.baseAlign || 'left';
  }
  const state = {
    baseSize: (() => {
      const numeric = Number(CONFIG.style && CONFIG.style.size);
      return Number.isFinite(numeric) ? Math.min(36, Math.max(10, Math.round(numeric))) : defaultSize;
    })(),
    currentSize: 0,
    baseAlign: (CONFIG.style && CONFIG.style.align) || 'left',
    baseBold: CONFIG.style ? CONFIG.style.bold === true : false,
    currentAlign: (CONFIG.style && CONFIG.style.align) || 'left',
    currentBold: CONFIG.style ? CONFIG.style.bold === true : false,
  };
  state.currentSize = state.baseSize;
  const editor = document.getElementById('letterEditor');
  const previewStage = document.getElementById('previewStage');
  const sizeInput = document.getElementById('fontSizeInput');
  const sizeValue = document.getElementById('fontSizeValue');
  const boldButton = document.getElementById('toggleBold');
  const alignButtons = Array.from(document.querySelectorAll('[data-align]'));
  const titleEl = document.getElementById('editorTitle');
  const subtitleEl = document.getElementById('editorSubtitle');
  if(titleEl){
    titleEl.textContent = CONFIG.title || 'Editor adresƒÉ dosar';
  }
  if(subtitleEl){
    subtitleEl.textContent = CONFIG.standardLabel ? ('Standard: ' + CONFIG.standardLabel) : '';
  }
  function clampFontSize(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)){
      return state.baseSize;
    }
    return Math.min(36, Math.max(10, Math.round(numeric)));
  }
  function parseFontSize(value){
    if(typeof value !== 'string'){
      return null;
    }
    const match = value.match(/([0-9]+(?:\.[0-9]+)?)\s*(px|pt)/i);
    if(!match){
      return null;
    }
    let numeric = parseFloat(match[1]);
    if(!Number.isFinite(numeric)){
      return null;
    }
    const unit = match[2].toLowerCase();
    if(unit === 'pt'){
      numeric = numeric * (96 / 72);
    } else if(unit !== 'px'){
      return null;
    }
    return clampFontSize(numeric);
  }
  function getSanitizedHtml(){
    return sanitizeHtml(editor.innerHTML);
  }
  function updateEditorEmptyState(){
    const html = getSanitizedHtml();
    editor.classList.toggle('is-empty', !html);
  }
  function detectSelectionFontSize(selection){
    if(!selection || selection.rangeCount === 0){
      return null;
    }
    let node = selection.anchorNode;
    if(!node){
      return null;
    }
    if(node.nodeType === Node.TEXT_NODE){
      node = node.parentElement;
    }
    while(node && node !== editor){
      if(node.nodeType === Node.ELEMENT_NODE){
        const computed = window.getComputedStyle(node);
        if(computed && computed.fontSize){
          const parsed = parseFontSize(computed.fontSize);
          if(parsed){
            return parsed;
          }
        }
      }
      node = node.parentElement;
    }
    return null;
  }
  function applyFontSizeToSelection(size){
    editor.focus();
    document.execCommand('fontSize', false, '7');
    const fonts = editor.querySelectorAll('font[size="7"]');
    if(fonts.length === 0){
      return false;
    }
    fonts.forEach(font => {
      const span = document.createElement('span');
      span.style.fontSize = size + 'px';
      while(font.firstChild){
        span.appendChild(font.firstChild);
      }
      font.parentNode.replaceChild(span, font);
    });
    return true;
  }
  function updateSizeDisplay(value){
    const target = clampFontSize(value !== undefined ? value : (state.currentSize || state.baseSize));
    if(sizeInput){
      sizeInput.value = target;
    }
    if(sizeValue){
      sizeValue.textContent = target + ' px';
    }
  }
  function buildLetterPreviewContent(html){
    const standard = CONFIG.standard || '';
    const phase = CONFIG.phase === 'final' ? 'final' : 'preliminary';
    const baseSize = standard === 'ASME_IX' ? Math.max(13, state.baseSize) : state.baseSize;
    const className = standard === 'ASME_IX' ? 'letter-body formatted-letter' : 'letter-body';
    const styles = [
      'font-size:' + baseSize + 'px',
      'line-height:1.6',
      'text-align:' + (state.baseAlign || 'left'),
      'font-weight:' + (state.baseBold ? 600 : 400),
    ];
    const inner = normalizeLetterInput(html, standard, phase) || '<p>AdresƒÉ necompletatƒÉ.</p>';
    return '<div class="' + className + '" style="' + styles.join(';') + '">' + inner + '</div>';
  }
  function buildLetterPreviewPage(contentHtml){
    const heading = CONFIG.heading ? '<h1 class="print-title">' + escapeHtml(CONFIG.heading) + '</h1>' : '';
    const subheading = CONFIG.subheading ? '<p class="print-subtitle">' + escapeHtml(CONFIG.subheading) + '</p>' : '';
    const header = CONFIG.headerHtml || '';
    const footer = CONFIG.footerHtml || '';
    return '<section class="print-document portrait"><header class="print-header">' + header + '</header><footer class="print-footer">' + footer + '</footer><div class="print-body">' + heading + subheading + contentHtml + '</div></section>';
  }
  function renderPreview(){
    if(!previewStage){
      editor.style.fontSize = state.baseSize + 'px';
      return;
    }
    const html = getSanitizedHtml();
    if(!html){
      previewStage.classList.add('is-empty');
      previewStage.innerHTML = '<div class="preview-placeholder">Introduce»õi textul adresei pentru a vedea pagina generatƒÉ cu antet »ôi subsol.</div>';
      editor.style.fontSize = state.baseSize + 'px';
      return;
    }
    const contentHtml = buildLetterPreviewContent(html);
    const pageHtml = buildLetterPreviewPage(contentHtml);
    previewStage.classList.remove('is-empty');
    previewStage.innerHTML = '<div class="preview-page">' + pageHtml + '</div>';
    editor.style.fontSize = state.baseSize + 'px';
  }
  function updateToolbarState(){
    const selection = document.getSelection();
    const inEditor = selection && selection.rangeCount > 0 && editor.contains(selection.anchorNode);
    if(boldButton){
      const isActive = inEditor ? document.queryCommandState('bold') : state.currentBold;
      state.currentBold = !!isActive;
      boldButton.classList.toggle('active', !!isActive);
    }
    const align = inEditor ? detectAlignment(selection) : (state.currentAlign || state.baseAlign || 'left');
    state.currentAlign = align;
    alignButtons.forEach(button => {
      const buttonAlign = (button.getAttribute('data-align') || 'left').toLowerCase();
      button.classList.toggle('active', buttonAlign === align);
    });
    let size = state.baseSize;
    if(inEditor){
      const selectionSize = detectSelectionFontSize(selection);
      if(selectionSize){
        size = selectionSize;
      }
    } else if(state.currentSize){
      size = clampFontSize(state.currentSize);
    }
    state.currentSize = size;
    updateSizeDisplay(size);
  }
  function applyCommand(command){
    editor.focus();
    document.execCommand(command, false, null);
    const contentTrimmed = (editor.textContent || '').trim();
    if(!contentTrimmed){
      if(command === 'bold'){
        state.baseBold = !state.baseBold;
        state.currentBold = state.baseBold;
      } else {
        const alignMap = {
          justifycenter: 'center',
          justifyright: 'right',
          justifyfull: 'justify',
          justifyleft: 'left',
        };
        const normalizedCommand = command.toLowerCase();
        if(alignMap[normalizedCommand]){
          state.baseAlign = alignMap[normalizedCommand];
          state.currentAlign = state.baseAlign;
        }
      }
    }
    updateEditorEmptyState();
    renderPreview();
    updateToolbarState();
  }
  const initialHtml = normalizeInput(CONFIG.text);
  if(initialHtml){
    editor.innerHTML = initialHtml;
    editor.classList.remove('is-empty');
  } else {
    editor.innerHTML = '';
    editor.classList.add('is-empty');
  }
  if(sizeInput){
    sizeInput.value = state.baseSize;
    sizeInput.addEventListener('input', () => {
      const numeric = clampFontSize(sizeInput.value);
      const selection = document.getSelection();
      const inEditor = selection && selection.rangeCount > 0 && editor.contains(selection.anchorNode);
      let applied = false;
      if(inEditor){
        const range = selection.getRangeAt(0);
        if(range && !range.collapsed){
          applied = applyFontSizeToSelection(numeric);
        }
      }
      if(!applied){
        state.baseSize = numeric;
        editor.style.fontSize = state.baseSize + 'px';
      }
      state.currentSize = numeric;
      updateSizeDisplay(numeric);
      updateEditorEmptyState();
      renderPreview();
      updateToolbarState();
    });
  }
  if(boldButton){
    boldButton.addEventListener('click', () => applyCommand('bold'));
  }
  alignButtons.forEach(button => {
    button.addEventListener('click', () => {
      const align = (button.getAttribute('data-align') || 'left').toLowerCase();
      if(align === 'center'){
        applyCommand('justifyCenter');
      } else if(align === 'right'){
        applyCommand('justifyRight');
      } else if(align === 'justify'){
        applyCommand('justifyFull');
      } else {
        applyCommand('justifyLeft');
      }
    });
  });
  editor.addEventListener('input', () => {
    updateEditorEmptyState();
    renderPreview();
  });
  editor.addEventListener('keyup', updateToolbarState);
  editor.addEventListener('mouseup', updateToolbarState);
  document.addEventListener('selectionchange', updateToolbarState);
  editor.addEventListener('paste', event => {
    event.preventDefault();
    const text = event.clipboardData ? event.clipboardData.getData('text/plain') : window.clipboardData && window.clipboardData.getData('Text');
    if(text){
      document.execCommand('insertText', false, text);
    }
  });
  const cancelBtn = document.getElementById('btnCancel');
  if(cancelBtn){
    cancelBtn.addEventListener('click', () => window.close());
  }
  function saveAndClose(){
    if(!window.opener || window.opener.closed){
      alert('Nu existƒÉ o fereastrƒÉ principalƒÉ deschisƒÉ pentru salvare.');
      return;
    }
    const sanitized = getSanitizedHtml();
    window.opener.postMessage({
      type: 'authorization-letter-update',
      phase: CONFIG.phase === 'final' ? 'final' : 'preliminary',
      text: sanitized,
      html: sanitized,
      style: { align: state.baseAlign, bold: state.baseBold, size: state.baseSize },
    }, '*');
    window.close();
  }
  const saveBtn = document.getElementById('btnSave');
  if(saveBtn){
    saveBtn.addEventListener('click', saveAndClose);
  }
  window.addEventListener('keydown', event => {
    const key = event.key ? event.key.toLowerCase() : '';
    if((event.ctrlKey || event.metaKey) && key === 's'){
      event.preventDefault();
      saveAndClose();
    }
  });
  updateSizeDisplay();
  renderPreview();
  updateToolbarState();
  updateEditorEmptyState();
  editor.focus();
})();
<\/script>
</body>
</html>`;
}
function openAuthorizationLetterEditor(phase){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('Nu existƒÉ un dosar de autorizare activ.');
    return;
  }
  const normalizedPhase = phase === 'final' ? 'final' : 'preliminary';
  const standard = dossier.standard || DEFAULT_AUTH_STANDARD;
  const finalPhase = ensureFinalPhase(dossier);
  const style = normalizedPhase === 'final'
    ? normalizeLetterStyle(finalPhase && finalPhase.letterStyle)
    : normalizeLetterStyle(dossier.letterStyle);
  const text = normalizedPhase === 'final'
    ? (finalPhase && finalPhase.address ? finalPhase.address : '')
    : (dossier.letter || '');
  const heading = normalizedPhase === 'final' ? 'AdresƒÉ documenta»õie finalƒÉ' : 'AdresƒÉ documenta»õie preliminarƒÉ';
  const subheading = getStandardLabel(standard) || '';
  let headerHtml = '';
  let footerHtml = '';
  if(company){
    const branding = ensureReportBranding(company);
    headerHtml = buildBrandingHtml(branding.header, company);
    footerHtml = buildBrandingHtml(branding.footer, company);
  }
  const editorConfig = {
    phase: normalizedPhase,
    text,
    style,
    title: heading,
    standardLabel: getStandardLabel(standard),
    standard,
    heading,
    subheading,
    headerHtml,
    footerHtml,
  };
  const html = buildLetterEditorHtml(editorConfig);
  const editorWindow = window.open('', '_blank', 'width=900,height=720,resizable=yes,scrollbars=yes');
  if(!editorWindow){
    alert('Nu s-a putut deschide editorul. Permite ferestrele pop-up pentru aceastƒÉ aplica»õie.');
    return;
  }
  editorWindow.document.write(html);
  editorWindow.document.close();
}

function applyAuthorizationLetterUpdate(phase, payload){
  if(!payload){
    return;
  }
  const normalizedPhase = phase === 'final' ? 'final' : 'preliminary';
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const standard = dossier.standard || DEFAULT_AUTH_STANDARD;
  const style = normalizeLetterStyle(payload.style);
  if(standard === 'ASME_IX' && style.size < 13){
    style.size = 13;
  }
  const rawContent = typeof payload.html === 'string' ? payload.html : payload.text;
  const text = normalizeLetterInput(rawContent, standard, normalizedPhase);
  if(normalizedPhase === 'final'){
    const finalPhase = ensureFinalPhase(dossier);
    finalPhase.address = text;
    finalPhase.letterStyle = style;
    updateAuthorizationLetterTemplate(standard, 'final', { text, style });
    persistState();
    renderAuthorizationDossierDetail(dossier);
    refreshFinalPhaseOpis(dossier, company);
    return;
  }
  ensureDossierLetterStyle(dossier);
  dossier.letter = text;
  dossier.letterStyle = style;
  updateAuthorizationLetterTemplate(standard, 'preliminary', { text, style });
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function handleAuthorizationLetterEditorMessage(event){
  if(!event || !event.data || typeof event.data !== 'object'){
    return;
  }
  const data = event.data;
  if(data.type === 'authorization-letter-update'){
    applyAuthorizationLetterUpdate(data.phase === 'final' ? 'final' : 'preliminary', data);
  }
}

function normalizeAttachment(raw, fallbackName){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const name = typeof raw.name === 'string' ? raw.name.trim() : '';
  const data = typeof raw.data === 'string' ? raw.data.trim() : '';
  const type = typeof raw.type === 'string' ? raw.type : '';
  if(!data){
    return null;
  }
  return {
    name: name || (fallbackName || 'document'),
    data,
    type,
  };
}

function normalizeWelderAttachment(raw, fallbackName){
  return normalizeAttachment(raw, fallbackName);
}

function clampBrandingTextSize(value){
  const numeric = Number(value);
  if(!Number.isFinite(numeric)){
    return 11;
  }
  return Math.min(Math.max(Math.round(numeric), 5), 28);
}

function clampBrandingSpacing(value){
  const numeric = Number(value);
  if(!Number.isFinite(numeric)){
    return 16;
  }
  return Math.min(Math.max(Math.round(numeric), 0), 120);
}

function clampInactivityMinutes(value){
  const numeric = Number(value);
  if(!Number.isFinite(numeric)){
    return 10;
  }
  return Math.min(Math.max(Math.round(numeric), 1), 120);
}

function normalizeBrandingItem(raw, fallbackName){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim()
    ? raw.id.trim()
    : generateDocumentId('branding');
  const type = raw.type === 'image' ? 'image' : 'text';
  if(type === 'image'){
    const attachment = normalizeAttachment(raw, fallbackName || 'branding');
    if(!attachment){
      return null;
    }
    const align = raw && (raw.align === 'center' || raw.align === 'right')
      ? raw.align
      : 'left';
    const rowValue = Number(raw && raw.row);
    const row = Number.isInteger(rowValue) && rowValue > 0 ? rowValue : 1;
    return {
      id,
      type: 'image',
      name: attachment.name,
      data: attachment.data,
      mime: attachment.type || raw.mime || '',
      align,
      row,
    };
  }
  const content = typeof raw.content === 'string' ? raw.content.trim() : '';
  if(!content){
    return null;
  }
  const align = raw && (raw.align === 'center' || raw.align === 'right') ? raw.align : 'left';
  const size = clampBrandingTextSize(raw.size);
  const rowValue = Number(raw && raw.row);
  const row = Number.isInteger(rowValue) && rowValue > 0 ? rowValue : 1;
  return {
    id,
    type: 'text',
    content,
    align,
    size,
    row,
  };
}

function normalizeReportBranding(raw){
  const base = { header: [], footer: [] };
  if(!raw || typeof raw !== 'object'){
    return base;
  }
  ['header', 'footer'].forEach(section => {
    const entries = Array.isArray(raw[section]) ? raw[section] : [];
    base[section] = entries
      .map(item => normalizeBrandingItem(item, `${section}_branding`))
      .filter(Boolean);
  });
  return base;
}

function normalizeLetterAlignment(value){
  const align = typeof value === 'string' ? value.trim().toLowerCase() : '';
  if(align === 'center' || align === 'right'){
    return align;
  }
  return 'left';
}

function normalizeLetterStyle(raw){
  const style = { ...DEFAULT_LETTER_STYLE };
  if(!raw || typeof raw !== 'object'){
    return style;
  }
  style.align = normalizeLetterAlignment(raw.align);
  style.bold = raw.bold === true;
  const sizeValue = Number(raw.size);
  style.size = Number.isFinite(sizeValue)
    ? Math.min(36, Math.max(10, Math.round(sizeValue)))
    : DEFAULT_LETTER_STYLE.size;
  return style;
}

function createLetterTemplate(base){
  const template = { text: '', style: { ...DEFAULT_LETTER_STYLE } };
  if(base && typeof base === 'object'){
    if(typeof base.text === 'string'){
      template.text = base.text;
    }
    if(base.style){
      template.style = normalizeLetterStyle(base.style);
    }
  }
  return template;
}

function createLetterTemplateEntry(preliminaryBase, finalBase){
  return {
    preliminary: createLetterTemplate(preliminaryBase),
    final: createLetterTemplate(finalBase),
  };
}

function cloneLetterTemplateEntry(entry){
  if(!entry || typeof entry !== 'object'){
    return createLetterTemplateEntry();
  }
  return createLetterTemplateEntry(entry.preliminary, entry.final);
}

function normalizeAuthorizationLetterTemplates(raw){
  const templates = {};
  if(raw && typeof raw === 'object'){
    Object.keys(raw).forEach(key => {
      const value = raw[key];
      if(value && typeof value === 'object'){
        templates[key] = createLetterTemplateEntry(value.preliminary, value.final);
      }
    });
  }
  if(!templates.default){
    templates.default = createLetterTemplateEntry();
  }
  return templates;
}

function normalizeGeneralSettings(raw){
  const settings = {
    inactivityMinutes: 10,
    storageMode: STORAGE_MODE_BROWSER,
    storageFileName: '',
    storageDirectoryName: '',
    suspendLogin: false,
  };
  if(!raw || typeof raw !== 'object'){
    settings.authorizationLetterTemplates = normalizeAuthorizationLetterTemplates();
    return settings;
  }
  settings.inactivityMinutes = clampInactivityMinutes(raw.inactivityMinutes);
  if(raw.storageMode === STORAGE_MODE_FILE){
    settings.storageMode = STORAGE_MODE_FILE;
  }
  if(typeof raw.storageFileName === 'string'){
    settings.storageFileName = raw.storageFileName;
  }
  if(typeof raw.storageDirectoryName === 'string'){
    settings.storageDirectoryName = raw.storageDirectoryName;
  }
  settings.suspendLogin = raw.suspendLogin === true;
  settings.authorizationLetterTemplates = normalizeAuthorizationLetterTemplates(raw.authorizationLetterTemplates);
  return settings;
}

function ensureAuthorizationLetterTemplates(){
  if(typeof state === 'undefined' || !state){
    return normalizeAuthorizationLetterTemplates();
  }
  if(!state.generalSettings || typeof state.generalSettings !== 'object'){
    state.generalSettings = normalizeGeneralSettings();
  }
  if(!state.generalSettings.authorizationLetterTemplates || typeof state.generalSettings.authorizationLetterTemplates !== 'object'){
    state.generalSettings.authorizationLetterTemplates = normalizeAuthorizationLetterTemplates();
  }
  return state.generalSettings.authorizationLetterTemplates;
}

function ensureAuthorizationLetterTemplateEntry(standard){
  const templates = ensureAuthorizationLetterTemplates();
  const key = typeof standard === 'string' && standard.trim() ? standard.trim() : 'default';
  if(!templates[key]){
    templates[key] = cloneLetterTemplateEntry(templates.default);
  }
  return templates[key];
}

function getAuthorizationLetterTemplate(standard, phase){
  const templates = ensureAuthorizationLetterTemplates();
  const key = typeof standard === 'string' && templates[standard] ? standard : 'default';
  const entry = templates[key] || templates.default;
  const phaseKey = phase === 'final' ? 'final' : 'preliminary';
  const template = entry && entry[phaseKey] ? entry[phaseKey] : createLetterTemplate();
  const style = normalizeLetterStyle(template.style);
  let text = typeof template.text === 'string' ? template.text : '';
  if(!text && standard === 'ASME_IX'){
    text = phaseKey === 'final' ? DEFAULT_ASME_FINAL_LETTER : DEFAULT_ASME_PRELIMINARY_LETTER;
  }
  text = normalizeLetterInput(text, standard, phaseKey);
  if(standard === 'ASME_IX' && style.size < 13){
    style.size = 13;
  }
  return { text, style };
}

function getAuthorizationLetterTemplateHtml(standard, phase){
  const template = getAuthorizationLetterTemplate(standard, phase);
  return template && typeof template.text === 'string' ? template.text : '';
}

function isAuthorizationLetterUsingTemplate(standard, html, phase){
  const normalizedCurrent = normalizeLetterInput(html, standard, phase);
  const templateHtml = getAuthorizationLetterTemplateHtml(standard, phase);
  if(!normalizedCurrent && !templateHtml){
    return true;
  }
  return normalizedCurrent === templateHtml;
}

function updateAuthorizationLetterTemplate(standard, phase, template){
  const entry = ensureAuthorizationLetterTemplateEntry(standard);
  const phaseKey = phase === 'final' ? 'final' : 'preliminary';
  entry[phaseKey] = createLetterTemplate(template);
}

function normalizeMaterialDocumentMap(raw, prefix){
  const result = {};
  if(raw && typeof raw === 'object'){
    Object.keys(raw).forEach(key => {
      const list = Array.isArray(raw[key]) ? raw[key] : [];
      const normalized = list
        .map(item => normalizeDossierItem(item, `${prefix}_${key}`))
        .filter(Boolean);
      if(normalized.length > 0){
        result[key] = normalized;
      }
    });
  }
  return result;
}

function normalizeWelderDocumentMap(raw){
  const result = {};
  if(raw && typeof raw === 'object'){
    Object.keys(raw).forEach(key => {
      const list = Array.isArray(raw[key]) ? raw[key] : [];
      const normalized = list
        .map(item => normalizeDossierItem(item, 'autorizatie_curenta'))
        .filter(Boolean);
      if(normalized.length > 0){
        result[String(key)] = normalized;
      }
    });
  }
  return result;
}

function createEmptyWeldingLog(){
  return { number: '', entries: [], include_in_dossier: true, attachment: null };
}

function normalizeWeldingLogEntry(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim()
    ? raw.id.trim()
    : generateDocumentId('wlog');
  return {
    id,
    date: typeof raw.date === 'string' ? raw.date.trim() : '',
    contract: typeof raw.contract === 'string' ? raw.contract.trim() : '',
    work: typeof raw.work === 'string' ? raw.work.trim() : '',
    material: typeof raw.material === 'string' ? raw.material.trim() : '',
    thickness: typeof raw.thickness === 'string' ? raw.thickness.trim() : '',
    process: typeof raw.process === 'string' ? raw.process.trim() : '',
    position: typeof raw.position === 'string' ? raw.position.trim() : '',
    ndt: typeof raw.ndt === 'string' ? raw.ndt.trim() : '',
    dt: typeof raw.dt === 'string' ? raw.dt.trim() : '',
    remarks: typeof raw.remarks === 'string' ? raw.remarks.trim() : '',
  };
}

function normalizeWeldingLog(raw){
  const log = createEmptyWeldingLog();
  if(!raw || typeof raw !== 'object'){
    return log;
  }
  if(typeof raw.number === 'string'){
    log.number = raw.number.trim();
  }
  if(raw.include_in_dossier === false || raw.includeInDossier === false){
    log.include_in_dossier = false;
  }
  if(raw.include_in_dossier === true || raw.includeInDossier === true){
    log.include_in_dossier = true;
  }
  const entries = Array.isArray(raw.entries) ? raw.entries : [];
  log.entries = entries.map(normalizeWeldingLogEntry).filter(Boolean);
  if(raw.attachment){
    const attachment = normalizeAttachment(raw.attachment, 'fisa_sudare.pdf');
    if(attachment){
      if(raw.attachment.pageCount && Number.isFinite(Number(raw.attachment.pageCount))){
        attachment.pageCount = Math.max(1, Math.round(Number(raw.attachment.pageCount)));
      }
      log.attachment = attachment;
    }
  }
  return log;
}

function hasWeldingLogEntries(log){
  return Array.isArray(log && log.entries) && log.entries.length > 0;
}

function isWeldingLogIncluded(log){
  return !log || log.include_in_dossier !== false;
}

function createEmptyWeldingLogEntry(){
  return {
    id: generateDocumentId('wlog'),
    date: '',
    contract: '',
    work: '',
    material: '',
    thickness: '',
    process: '',
    position: '',
    ndt: '',
    dt: '',
    remarks: '',
  };
}

function normalizeAttachmentList(raw, fallbackName){
  const list = Array.isArray(raw) ? raw : [];
  return list.map(item => normalizeDossierItem(item, fallbackName)).filter(Boolean);
}

function normalizeNamedAttachmentMap(raw, fallbackName){
  const result = {};
  if(raw && typeof raw === 'object'){
    Object.keys(raw).forEach(key => {
      const normalized = normalizeAttachmentList(raw[key], fallbackName);
      if(normalized.length > 0){
        result[String(key)] = normalized;
      }
    });
  }
  return result;
}

function createDefaultFinalPhase(){
  return {
    address: '',
    letterStyle: normalizeLetterStyle(),
    closed: false,
    welderDocuments: {
      examReports: {},
      writtenWorks: {},
      ndtBulletins: {},
      destructiveReports: {},
    },
    labAuthorizations: [],
    inspectorReports: [],
    customSteps: [],
  };
}

function normalizeFinalPhase(raw, standard){
  const source = raw && typeof raw === 'object' ? raw : {};
  const finalPhase = createDefaultFinalPhase();
  const addressRaw = typeof source.address === 'string'
    ? source.address
    : (typeof source.letter === 'string' ? source.letter : '');
  finalPhase.address = normalizeLetterInput(addressRaw, standard || DEFAULT_AUTH_STANDARD, 'final');
  finalPhase.closed = source.closed === true || source.finalized === true;
  finalPhase.letterStyle = normalizeLetterStyle(source.letterStyle || source.letter_style);
  finalPhase.welderDocuments.examReports = normalizeNamedAttachmentMap(source.examReports || source.exam_reports, FINAL_WELDER_FALLBACK.examReports);
  finalPhase.welderDocuments.writtenWorks = normalizeNamedAttachmentMap(source.writtenWorks || source.written_works, FINAL_WELDER_FALLBACK.writtenWorks);
  finalPhase.welderDocuments.ndtBulletins = normalizeNamedAttachmentMap(source.ndtBulletins || source.ndt_bulletins, FINAL_WELDER_FALLBACK.ndtBulletins);
  finalPhase.welderDocuments.destructiveReports = normalizeNamedAttachmentMap(source.destructiveReports || source.destructive_reports, FINAL_WELDER_FALLBACK.destructiveReports);
  finalPhase.labAuthorizations = normalizeAttachmentList(source.labAuthorizations || source.lab_authorizations, FINAL_GENERAL_FALLBACK.labAuthorizations);
  finalPhase.inspectorReports = normalizeAttachmentList(source.inspectorReports || source.inspector_reports, FINAL_GENERAL_FALLBACK.inspectorReports);
  finalPhase.customSteps = Array.isArray(source.customSteps)
    ? source.customSteps.map(normalizeCustomStep).filter(Boolean)
    : [];
  return finalPhase;
}

function normalizeCustomStep(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim()
    ? raw.id.trim()
    : generateDocumentId('custep');
  const name = typeof raw.name === 'string' ? raw.name.trim() : '';
  const opis = typeof raw.opis === 'string' ? raw.opis.trim() : '';
  const attachments = Array.isArray(raw.attachments)
    ? raw.attachments.map(item => normalizeDossierItem(item, name || 'document_personalizat')).filter(Boolean)
    : [];
  const include = raw.include === false || raw.include === 'false' ? false : true;
  return { id, name, opis, attachments, include };
}

function normalizeDossierEntry(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim()
    ? raw.id.trim()
    : generateDocumentId('dosrow');
  let welderId = null;
  if(raw.welder_id !== undefined && raw.welder_id !== null){
    const numeric = Number(raw.welder_id);
    welderId = Number.isNaN(numeric) ? null : numeric;
  }
  let qualificationId = null;
  if(raw.qualification_id !== undefined && raw.qualification_id !== null){
    const numeric = Number(raw.qualification_id);
    qualificationId = Number.isNaN(numeric) ? null : numeric;
  }
  let procedureId = null;
  if(raw.procedure_id !== undefined && raw.procedure_id !== null){
    const numeric = Number(raw.procedure_id);
    procedureId = Number.isNaN(numeric) ? null : numeric;
  }
  return {
    id,
    welder_id: welderId,
    welder_name: typeof raw.welder_name === 'string' ? raw.welder_name : '',
    panson_code: typeof raw.panson_code === 'string' ? raw.panson_code : '',
    process: raw && raw.process ? String(raw.process) : '',
    base_quality: raw && raw.base_quality ? String(raw.base_quality) : '',
    base_material: raw && raw.base_material ? String(raw.base_material) : '',
    filler_material: raw && raw.filler_material ? String(raw.filler_material) : '',
    position: raw && raw.position ? String(raw.position) : '',
    base_dimension: raw && raw.base_dimension ? String(raw.base_dimension) : '',
    diameter: raw && raw.diameter ? String(raw.diameter) : '',
    thickness_domain: raw && raw.thickness_domain ? String(raw.thickness_domain) : '',
    observation: raw && raw.observation ? String(raw.observation) : '',
    source: raw && raw.source ? String(raw.source) : 'manual',
    qualification_id: qualificationId,
    procedure_id: procedureId,
  };
}

function normalizeVisibilityMap(source){
  const result = {};
  if(!source){
    return result;
  }
  if(Array.isArray(source)){
    source.forEach(entry => {
      if(typeof entry === 'string' && entry.trim()){
        result[entry.trim()] = false;
      }
    });
    return result;
  }
  if(typeof source === 'object'){
    Object.keys(source).forEach(key => {
      const value = source[key];
      if(value === false || value === 'false' || value === 0){
        result[key] = false;
      }
    });
  }
  return result;
}

function normalizeStepVisibility(raw){
  const result = { preliminary: {}, final: {} };
  if(!raw || typeof raw !== 'object'){
    return result;
  }
  result.preliminary = normalizeVisibilityMap(raw.preliminary || raw.primary || raw.preliminar);
  result.final = normalizeVisibilityMap(raw.final || raw.secondary || raw.finalPhase || raw.final_phase);
  return result;
}

function normalizeAuthorizationDossier(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim()
    ? raw.id.trim()
    : generateDocumentId('authdos');
  const standard = typeof raw.standard === 'string' && raw.standard.trim()
    ? raw.standard.trim()
    : DEFAULT_AUTH_STANDARD;
  const entries = Array.isArray(raw.entries)
    ? raw.entries.map(normalizeDossierEntry).filter(Boolean)
    : [];
  const letter = normalizeLetterInput(raw.letter, standard, 'preliminary');
  const preliminaryClosed = raw.preliminaryClosed === true || raw.preliminary_phase_closed === true;
  const finalPhase = normalizeFinalPhase(raw.finalPhase || raw.final_phase, standard);
  const styleRaw = raw && raw.letterStyle && typeof raw.letterStyle === 'object' ? raw.letterStyle : null;
  const letterStyle = normalizeLetterStyle(styleRaw);
  const materialDocuments = {
    base: normalizeMaterialDocumentMap(raw && raw.materialDocuments && raw.materialDocuments.base
      ? raw.materialDocuments.base
      : raw && raw.baseMaterialDocuments, 'base'),
    filler: normalizeMaterialDocumentMap(raw && raw.materialDocuments && raw.materialDocuments.filler
      ? raw.materialDocuments.filler
      : raw && raw.fillerMaterialDocuments, 'filler'),
  };
  const welderDocuments = normalizeWelderDocumentMap(
    raw && raw.welderDocuments ? raw.welderDocuments : raw && raw.welder_documents
  );
  const name = typeof raw.name === 'string' ? raw.name : '';
  const createdAt = raw && raw.created_at ? raw.created_at : new Date().toISOString();
  const customSteps = Array.isArray(raw.customSteps)
    ? raw.customSteps.map(normalizeCustomStep).filter(Boolean)
    : [];
  const stepVisibility = normalizeStepVisibility(raw.stepVisibility || raw.step_visibility);
  return {
    id,
    standard,
    entries,
    letter,
    letterStyle,
    materialDocuments,
    welderDocuments,
    name,
    created_at: createdAt,
    customSteps,
    preliminaryClosed,
    finalPhase,
    stepVisibility,
  };
}

function readFileAsDataURL(file){
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error || new Error('Eroare la citirea fi»ôierului.'));
    reader.readAsDataURL(file);
  });
}

let state = loadState();
ensureStateStandards();
syncStandardsFromState();
ensureGeneralSettings();
let isAuthenticated = false;
let storageDirectoryHandle = null;
let storageFileHandle = null;
let storageNeedsReconnect = false;
let fileStorageMissingFileWarned = false;
let selectedWelder = null;
let selectedWelderPosition = null;
let welderModalMode = 'create';
let welderSearchTerm = '';
let archiveVisible = false;
let archiveSearchTerm = '';
let pansonArchiveVisible = false;
let activeAuthGroup = getAuthorizationGroups()[0] || 'ALTE';
let activeAuthorizationExistingGroup = null;
let activeAuthorizationDossierId = null;
let brandingModalCompanyId = null;
let inactivityTimer = null;
let inactivityListenersBound = false;

function updateAuthorizationFieldLabels(){
  const select = document.getElementById('auth_standard');
  const standard = select && select.value ? select.value : DEFAULT_AUTH_STANDARD;
  const config = getFieldLabelsForStandard(standard);
  const processLabel = document.getElementById('auth_process_label');
  if(processLabel){
    processLabel.textContent = config && config.process ? config.process : 'Proces';
  }
  const positionLabel = document.getElementById('auth_position_label');
  if(positionLabel){
    positionLabel.textContent = config && config.position ? config.position : 'Pozi»õie';
  }
}

function populateAuthStandardSelect(){
  const select = document.getElementById('auth_standard');
  if(!select){
    return;
  }
  const standards = getStandardsForType('authorization').filter(item => {
    const group = item && item.group ? item.group : 'ALTE';
    return group === activeAuthGroup;
  });
  const currentValue = select.value;
  select.innerHTML = '';
  if(standards.length === 0){
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = '‚Äî';
    select.appendChild(placeholder);
    select.value = '';
    updateAuthorizationFieldLabels();
    return;
  }
  standards.forEach(item => {
    const option = document.createElement('option');
    option.value = item.id;
    option.textContent = item.label || item.id;
    select.appendChild(option);
  });
  let targetValue = standards.find(item => item.id === currentValue)?.id
    || (standards[0] ? standards[0].id : DEFAULT_AUTH_STANDARD);
  select.value = targetValue;
  updateAuthorizationFieldLabels();
}

function setActiveAuthGroup(group){
  const groups = getAuthorizationGroups();
  const next = groups.includes(group) ? group : (groups[0] || 'ALTE');
  activeAuthGroup = next;
  const tabContainer = document.getElementById('auth_standard_tabs');
  if(tabContainer){
    tabContainer.querySelectorAll('button').forEach(button => {
      const value = button.getAttribute('data-group');
      const isActive = value === next;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }
  populateAuthStandardSelect();
  loadAuthorizations();
}

function renderAuthStandardTabs(){
  const container = document.getElementById('auth_standard_tabs');
  if(!container){
    return;
  }
  container.innerHTML = '';
  const groups = getAuthorizationGroups();
  if(groups.length === 0){
    container.classList.add('hidden');
    activeAuthGroup = 'ALTE';
    populateAuthStandardSelect();
    return;
  }
  container.classList.remove('hidden');
  groups.forEach(group => {
    const button = document.createElement('button');
    button.type = 'button';
    button.textContent = group;
    button.dataset.group = group;
    button.addEventListener('click', () => setActiveAuthGroup(group));
    container.appendChild(button);
  });
  if(!groups.includes(activeAuthGroup)){
    activeAuthGroup = groups[0];
  }
  setActiveAuthGroup(activeAuthGroup);
}

function activateSubTab(containerId, tabName){
  const container = document.getElementById(containerId);
  if(!container || !tabName){
    return;
  }
  const prefix = tabName.includes('_') ? tabName.split('_')[0] : '';
  container.querySelectorAll('button').forEach(button => {
    const value = button.getAttribute('data-tab');
    const isActive = value === tabName;
    button.classList.toggle('active', isActive);
    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
  const host = container.closest('.content');
  if(!host){
    return;
  }
  host.querySelectorAll('.subtab-panel').forEach(panel => {
    const panelName = panel.getAttribute('data-panel');
    if(prefix && panelName && !panelName.startsWith(prefix)){
      return;
    }
    const match = panelName === tabName;
    panel.classList.toggle('active', match);
    panel.setAttribute('aria-hidden', match ? 'false' : 'true');
  });
}

function initSubTabs(containerId, defaultTab){
  const container = document.getElementById(containerId);
  if(!container){
    return;
  }
  container.querySelectorAll('button').forEach(button => {
    button.addEventListener('click', () => {
      const value = button.getAttribute('data-tab');
      if(value){
        activateSubTab(containerId, value);
      }
    });
  });
  const initial = defaultTab
    || (container.querySelector('button.active') && container.querySelector('button.active').getAttribute('data-tab'))
    || (container.querySelector('button') && container.querySelector('button').getAttribute('data-tab'));
  if(initial){
    activateSubTab(containerId, initial);
  }
}

function generateDocumentId(prefix){
  const base = prefix || 'doc';
  const random = Math.random().toString(36).slice(2, 8);
  return `${base}_${Date.now().toString(36)}_${random}`;
}

function joinRomanianList(items){
  const filtered = (Array.isArray(items) ? items : []).map(item => item && item.trim ? item.trim() : String(item || '')).filter(Boolean);
  if(filtered.length === 0){
    return '';
  }
  if(filtered.length === 1){
    return filtered[0];
  }
  if(filtered.length === 2){
    return `${filtered[0]} »ôi ${filtered[1]}`;
  }
  const leading = filtered.slice(0, -1).join(', ');
  return `${leading} »ôi ${filtered[filtered.length - 1]}`;
}

function setAuthenticationState(flag){
  const overlay = document.getElementById('auth_overlay');
  if(flag){
    isAuthenticated = true;
    if(overlay){
      overlay.classList.add('hidden');
      overlay.setAttribute('aria-hidden', 'true');
    }
    document.body.classList.remove('auth-locked');
    updateAuthNotice('');
    bindInactivityListeners();
    if(isLoginSuspended()){
      clearInactivityTimer();
    } else {
      scheduleInactivityTimer();
    }
  } else {
    isAuthenticated = false;
    if(overlay){
      overlay.classList.remove('hidden');
      overlay.setAttribute('aria-hidden', 'false');
    }
    document.body.classList.add('auth-locked');
    clearInactivityTimer();
  }
}

function initAuthentication(){
  const overlay = document.getElementById('auth_overlay');
  const form = document.getElementById('auth_form');
  if(!overlay || !form){
    return;
  }
  if(isLoginSuspended()){
    setAuthenticationState(true);
    updateAuthNotice('Acces fƒÉrƒÉ parolƒÉ activat din setƒÉri generale.');
    return;
  }
  const errorBox = document.getElementById('auth_error');
  const userInput = document.getElementById('auth_user');
  const passInput = document.getElementById('auth_pass');
  let sessionValue = null;
  try {
    if(window.sessionStorage){
      sessionValue = window.sessionStorage.getItem(AUTH_SESSION_KEY);
    }
  } catch (err) {
    console.warn('Session storage indisponibil pentru autentificare.', err);
  }
  if(sessionValue === '1'){
    setAuthenticationState(true);
  } else {
    setAuthenticationState(false);
    updateAuthNotice('');
  }
  form.addEventListener('submit', event => {
    event.preventDefault();
    const username = userInput && typeof userInput.value === 'string' ? userInput.value.trim() : '';
    const password = passInput && typeof passInput.value === 'string' ? passInput.value : '';
    if(username === AUTH_USERNAME && password === AUTH_PASSWORD){
      try {
        if(window.sessionStorage){
          window.sessionStorage.setItem(AUTH_SESSION_KEY, '1');
        }
      } catch (err) {
        console.warn('Nu s-a putut salva sesiunea de autentificare.', err);
      }
      if(errorBox){
        errorBox.classList.remove('visible');
      }
      setAuthenticationState(true);
      return;
    }
    if(errorBox){
      errorBox.textContent = 'Utilizator sau parolƒÉ incorecte.';
      errorBox.classList.add('visible');
    }
    if(passInput){
      passInput.value = '';
      passInput.focus();
    }
  });
  if(!isAuthenticated && userInput){
    setTimeout(() => {
      try { userInput.focus(); } catch (err) { /* ignore */ }
    }, 100);
  }
}

function normalizeDossierItem(raw, fallbackName){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const attachment = normalizeAttachment(raw, fallbackName);
  if(!attachment){
    return null;
  }
  const id = typeof raw.id === 'string' && raw.id.trim()
    ? raw.id.trim()
    : generateDocumentId('doc');
  const addedAt = raw && raw.added_at ? raw.added_at : new Date().toISOString();
  return {
    id,
    ...attachment,
    added_at: addedAt,
  };
}

function normalizeAuthorizationArchiveEntry(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const idValue = Number(raw.id);
  const id = Number.isInteger(idValue) && idValue > 0 ? idValue : 0;
  const name = typeof raw.name === 'string' && raw.name.trim() ? raw.name.trim() : 'Dosar PDF';
  const standard = typeof raw.standard === 'string' && raw.standard.trim() ? raw.standard.trim() : null;
  const savedAt = raw.saved_at || raw.savedAt || null;
  const filename = typeof raw.filename === 'string' && raw.filename.trim() ? raw.filename.trim() : null;
  const data = typeof raw.data === 'string' ? raw.data : null;
  const pageCount = Number.isFinite(Number(raw.page_count)) && Number(raw.page_count) > 0
    ? Number(raw.page_count)
    : (Number.isFinite(Number(raw.pages)) && Number(raw.pages) > 0 ? Number(raw.pages) : null);
  const details = Array.isArray(raw.details)
    ? raw.details.map(detail => ({
      label: detail && detail.label ? String(detail.label) : 'Sec»õiune',
      startPage: Number.isFinite(Number(detail && detail.startPage)) ? Number(detail.startPage) : null,
      endPage: Number.isFinite(Number(detail && detail.endPage)) ? Number(detail.endPage) : null,
      pageCount: Number.isFinite(Number(detail && detail.pageCount)) ? Number(detail.pageCount) : null,
    }))
    : [];
  let snapshot = null;
  if(raw && raw.snapshot && typeof raw.snapshot === 'object'){
    try {
      snapshot = JSON.parse(JSON.stringify(raw.snapshot));
    } catch (error) {
      console.warn('Nu s-a putut normaliza structura snapshot-ului din arhivƒÉ.', error);
      snapshot = null;
    }
  }
  return {
    id,
    dossier_id: raw && raw.dossier_id !== undefined ? raw.dossier_id : null,
    name,
    standard,
    saved_at: savedAt,
    filename,
    data,
    page_count: pageCount,
    details,
    snapshot,
  };
}

function isBaseStandard(id){
  return BASE_STANDARDS.some(entry => entry.id === id);
}

function renderStandardManagerList(){
  const container = document.getElementById('auth_standard_list');
  if(!container){
    return;
  }
  const standards = getStandardsForType('authorization')
    .slice()
    .sort((a, b) => (a.label || a.id || '').localeCompare(b.label || b.id || '', 'ro', { sensitivity: 'base' }));
  container.innerHTML = '';
  if(standards.length === 0){
    const empty = document.createElement('p');
    empty.className = 'dossier-empty';
    empty.textContent = 'Nu existƒÉ standarde definite.';
    container.appendChild(empty);
    return;
  }
  standards.forEach(entry => {
    const row = document.createElement('div');
    row.className = 'standard-row';
    const info = document.createElement('div');
    info.innerHTML = `
      <strong>${escapeHtml(entry.label || entry.id)}</strong>
      <div class="standard-meta">
        <span>Cod: ${escapeHtml(entry.id)}</span>
        <span>Grup: ${escapeHtml(entry.group || 'ALTE')}</span>
      </div>
    `;
    row.appendChild(info);
    const actions = document.createElement('div');
    actions.className = 'attachment-actions';
    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'btn ghost small';
    editBtn.textContent = 'EditeazƒÉ';
    editBtn.addEventListener('click', () => editAuthorizationStandard(entry.id));
    actions.appendChild(editBtn);
    if(!isBaseStandard(entry.id)){
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.className = 'btn ghost small';
      deleteBtn.textContent = '»òterge';
      deleteBtn.addEventListener('click', () => deleteAuthorizationStandard(entry.id));
      actions.appendChild(deleteBtn);
    }
    row.appendChild(actions);
    container.appendChild(row);
  });
}

function toggleStandardManager(forceState){
  const panel = document.getElementById('auth_standard_manager');
  if(!panel){
    return;
  }
  const shouldShow = typeof forceState === 'boolean'
    ? forceState
    : !panel.classList.contains('visible');
  panel.classList.toggle('visible', shouldShow);
  panel.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
  if(shouldShow){
    renderStandardManagerList();
  }
}

function sanitizeStandardId(label){
  const raw = label.toUpperCase().replace(/[^A-Z0-9]+/g, '_').replace(/^_+|_+$/g, '');
  return raw || 'STD';
}

function createUniqueStandardId(baseId){
  const standards = ensureStateStandards();
  let candidate = baseId;
  let counter = 1;
  while(standards.some(entry => entry.id === candidate)){
    candidate = `${baseId}_${++counter}`;
  }
  return candidate;
}

function addAuthorizationStandard(){
  const namePrompt = prompt('Denumirea noului standard de autorizare:');
  if(namePrompt === null){
    return;
  }
  const label = namePrompt.trim();
  if(!label){
    alert('Denumirea standardului este obligatorie.');
    return;
  }
  const groupPrompt = prompt('Grupul √Æn care sƒÉ fie afi»ôat (ex: ASME, ISO, AWS, ALTE):', activeAuthGroup || 'ALTE');
  if(groupPrompt === null){
    return;
  }
  const group = groupPrompt.trim() || 'ALTE';
  const baseId = sanitizeStandardId(label);
  const id = createUniqueStandardId(baseId);
  const standards = ensureStateStandards();
  standards.push({
    id,
    label,
    type: 'authorization',
    group,
    fieldLabels: { process: 'Proces sudare', position: 'Pozi»õie' },
  });
  activeAuthGroup = group;
  syncStandardsFromState();
  persistState();
  renderAuthStandardTabs();
  renderStandardManagerList();
  alert(`Standardul ${label} a fost adƒÉugat.`);
}

function editAuthorizationStandard(id){
  const standard = getStandardById(id);
  if(!standard){
    return;
  }
  const namePrompt = prompt('ActualizeazƒÉ denumirea standardului:', standard.label || standard.id);
  if(namePrompt === null){
    return;
  }
  const label = namePrompt.trim();
  if(!label){
    alert('Denumirea standardului este obligatorie.');
    return;
  }
  const groupPrompt = prompt('ActualizeazƒÉ grupul:', standard.group || 'ALTE');
  if(groupPrompt === null){
    return;
  }
  const group = groupPrompt.trim() || 'ALTE';
  standard.label = label;
  standard.group = group;
  activeAuthGroup = group;
  syncStandardsFromState();
  persistState();
  renderAuthStandardTabs();
  renderStandardManagerList();
}

function deleteAuthorizationStandard(id){
  if(isBaseStandard(id)){
    alert('Standardele implicite nu pot fi »ôterse.');
    return;
  }
  const standards = ensureStateStandards();
  const index = standards.findIndex(entry => entry.id === id);
  if(index === -1){
    return;
  }
  const inUse = state.companies.some(company => Array.isArray(company.qualifications)
    && company.qualifications.some(q => q && q.category === 'autorizatii' && q.standard === id));
  if(inUse){
    alert('Standardul este folosit de autoriza»õii existente »ôi nu poate fi »ôters.');
    return;
  }
  if(!confirm('»òtergi acest standard personalizat?')){
    return;
  }
  standards.splice(index, 1);
  syncStandardsFromState();
  persistState();
  renderAuthStandardTabs();
  renderStandardManagerList();
}


function ensureAuthorizationDossiers(company){
  if(!company.authorizationDossiers || !Array.isArray(company.authorizationDossiers)){
    company.authorizationDossiers = [];
  }
  return company.authorizationDossiers;
}

function ensureAuthorizationDossierArchive(company){
  if(!company.authorizationDossierArchive || !Array.isArray(company.authorizationDossierArchive)){
    company.authorizationDossierArchive = [];
  }
  if(typeof company.nextAuthorizationDossierArchiveId !== 'number' || company.nextAuthorizationDossierArchiveId < 1){
    company.nextAuthorizationDossierArchiveId = 1;
  }
  return company.authorizationDossierArchive;
}

const AUTH_DOSSIER_PHASES = ['preliminary', 'final'];

function createDefaultAuthorizationDossierSettings(){
  return {
    preliminary: { pageNumbering: true, startPage: 1, pageOffset: 0 },
    final: { pageNumbering: true, startPage: 1, pageOffset: 0 },
  };
}

function clampAuthorizationStartPage(value){
  const numeric = Number(value);
  if(Number.isFinite(numeric)){
    const rounded = Math.max(1, Math.floor(numeric));
    return rounded;
  }
  return 1;
}

function clampAuthorizationPageOffset(value){
  const numeric = Number(value);
  if(Number.isFinite(numeric) && numeric >= 0){
    return Math.min(1, Math.floor(numeric));
  }
  return 0;
}

function normalizeAuthorizationDossierPhaseSettings(raw){
  const result = { pageNumbering: true, startPage: 1, pageOffset: 0 };
  if(raw && typeof raw === 'object'){
    if(raw.pageNumbering !== undefined){
      result.pageNumbering = raw.pageNumbering !== false;
    } else if(raw.page_numbering !== undefined){
      result.pageNumbering = raw.page_numbering !== false;
    } else if(raw.numbering !== undefined){
      result.pageNumbering = raw.numbering !== false;
    }
    const startCandidate = raw.startPage !== undefined
      ? raw.startPage
      : (raw.start_page !== undefined ? raw.start_page : raw.start);
    if(startCandidate !== undefined){
      result.startPage = clampAuthorizationStartPage(startCandidate);
    }
    const offsetCandidate = raw.pageOffset !== undefined
      ? raw.pageOffset
      : (raw.page_offset !== undefined ? raw.page_offset : raw.offset);
    if(offsetCandidate !== undefined){
      result.pageOffset = clampAuthorizationPageOffset(offsetCandidate);
    }
  } else if(typeof raw === 'boolean'){
    result.pageNumbering = raw !== false;
  }
  return result;
}

function normalizeAuthorizationDossierSettings(raw){
  const defaults = createDefaultAuthorizationDossierSettings();
  if(!raw || typeof raw !== 'object'){
    return { ...defaults, preliminary: { ...defaults.preliminary }, final: { ...defaults.final } };
  }
  const result = {
    preliminary: normalizeAuthorizationDossierPhaseSettings(raw.preliminary || raw.primary || raw),
    final: normalizeAuthorizationDossierPhaseSettings(raw.final || raw.secondary || raw.finalPhase || raw.final_phase),
  };
  if(raw.pageNumbering !== undefined){
    result.preliminary.pageNumbering = raw.pageNumbering !== false;
  }
  if(raw.startPage !== undefined){
    result.preliminary.startPage = clampAuthorizationStartPage(raw.startPage);
  }
  if(raw.finalPageNumbering !== undefined){
    result.final.pageNumbering = raw.finalPageNumbering !== false;
  }
  if(raw.finalStartPage !== undefined){
    result.final.startPage = clampAuthorizationStartPage(raw.finalStartPage);
  }
  AUTH_DOSSIER_PHASES.forEach(phase => {
    if(!result[phase] || typeof result[phase] !== 'object'){
      result[phase] = { ...defaults[phase] };
    } else {
      result[phase].pageNumbering = result[phase].pageNumbering !== false;
      result[phase].startPage = clampAuthorizationStartPage(result[phase].startPage);
      result[phase].pageOffset = clampAuthorizationPageOffset(result[phase].pageOffset);
    }
  });
  return result;
}

function ensureAuthorizationDossierSettings(company){
  if(!company.authorizationDossierSettings || typeof company.authorizationDossierSettings !== 'object'){
    company.authorizationDossierSettings = createDefaultAuthorizationDossierSettings();
  }
  if(company.authorizationDossierSettings.pageNumbering !== undefined){
    const legacy = company.authorizationDossierSettings.pageNumbering !== false;
    company.authorizationDossierSettings = {
      ...createDefaultAuthorizationDossierSettings(),
      ...company.authorizationDossierSettings,
    };
    company.authorizationDossierSettings.preliminary.pageNumbering = legacy;
    delete company.authorizationDossierSettings.pageNumbering;
  }
  company.authorizationDossierSettings = normalizeAuthorizationDossierSettings(company.authorizationDossierSettings);
  return company.authorizationDossierSettings;
}

function getAuthorizationDossierPhaseSettings(company, phase){
  const settings = ensureAuthorizationDossierSettings(company);
  if(!phase || !settings[phase]){
    return createDefaultAuthorizationDossierSettings()[phase] || { pageNumbering: true, startPage: 1 };
  }
  return settings[phase];
}

function updateAuthorizationDossierPhaseNumbering(company, phase, flag){
  const settings = ensureAuthorizationDossierSettings(company);
  const target = settings[phase];
  if(!target){
    return;
  }
  const next = flag === true;
  if(target.pageNumbering !== next){
    target.pageNumbering = next;
    persistState();
  }
}

function updateAuthorizationDossierPhaseStartPage(company, phase, value){
  const settings = ensureAuthorizationDossierSettings(company);
  const target = settings[phase];
  if(!target){
    return 1;
  }
  const next = clampAuthorizationStartPage(value);
  if(target.startPage !== next){
    target.startPage = next;
    persistState();
  }
  return next;
}

function updateAuthorizationDossierPhaseOffset(company, phase, value){
  const settings = ensureAuthorizationDossierSettings(company);
  const target = settings[phase];
  if(!target){
    return 0;
  }
  const next = clampAuthorizationPageOffset(value);
  if(target.pageOffset !== next){
    target.pageOffset = next;
    persistState();
  }
  return next;
}

function ensureAuthorizationStepVisibility(dossier){
  if(!dossier.stepVisibility || typeof dossier.stepVisibility !== 'object'){
    dossier.stepVisibility = { preliminary: {}, final: {} };
  }
  if(!dossier.stepVisibility.preliminary || typeof dossier.stepVisibility.preliminary !== 'object'){
    dossier.stepVisibility.preliminary = {};
  }
  if(!dossier.stepVisibility.final || typeof dossier.stepVisibility.final !== 'object'){
    dossier.stepVisibility.final = {};
  }
  return dossier.stepVisibility;
}

function isAuthorizationStepVisible(dossier, phase, key){
  if(!dossier || !phase || !key){
    return true;
  }
  const visibility = ensureAuthorizationStepVisibility(dossier);
  const map = phase === 'final' ? visibility.final : visibility.preliminary;
  if(!map || typeof map !== 'object'){
    return true;
  }
  if(map[key] === false){
    return false;
  }
  return true;
}

function setAuthorizationStepVisibility(dossier, phase, key, include){
  if(!dossier || !phase || !key){
    return false;
  }
  const visibility = ensureAuthorizationStepVisibility(dossier);
  const map = phase === 'final' ? visibility.final : visibility.preliminary;
  if(!map || typeof map !== 'object'){
    return false;
  }
  const wantsInclude = include === true;
  if(wantsInclude){
    if(map[key] !== undefined){
      delete map[key];
      persistState();
      return true;
    }
    return false;
  }
  if(map[key] === false){
    return false;
  }
  map[key] = false;
  persistState();
  return true;
}

function updateAuthorizationStepVisibilityControls(dossier){
  const detail = document.getElementById('auth_dossier_detail');
  if(!detail){
    return;
  }
  detail.querySelectorAll('input[data-step-visibility]').forEach(input => {
    const phase = input.getAttribute('data-phase') === 'final' ? 'final' : 'preliminary';
    const stepKey = input.getAttribute('data-step');
    const included = isAuthorizationStepVisible(dossier, phase, stepKey);
    if(input.checked !== included){
      input.checked = included;
    }
    const stepElement = input.closest('.dossier-step');
    if(stepElement){
      if(included){
        stepElement.classList.remove('step-excluded');
      } else {
        stepElement.classList.add('step-excluded');
      }
    }
  });
}

function getActiveAuthorizationDossier(company){
  const dossiers = ensureAuthorizationDossiers(company);
  if(dossiers.length === 0){
    activeAuthorizationDossierId = null;
    return null;
  }
  if(!activeAuthorizationDossierId || !dossiers.some(d => d && d.id === activeAuthorizationDossierId)){
    activeAuthorizationDossierId = dossiers[0].id;
  }
  return dossiers.find(d => d && d.id === activeAuthorizationDossierId) || null;
}

function handleAuthorizationStepVisibilityChange(input){
  if(!input){
    return;
  }
  const phase = input.getAttribute('data-phase') === 'final' ? 'final' : 'preliminary';
  const stepKey = input.getAttribute('data-step');
  if(!stepKey){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const changed = setAuthorizationStepVisibility(dossier, phase, stepKey, input.checked);
  if(changed){
    renderAuthorizationDossierDetail(dossier);
  } else {
    updateAuthorizationStepVisibilityControls(dossier);
  }
}

function handleCreateAuthorizationDossier(){
  const select = document.getElementById('auth_dossier_standard_select');
  if(!select){
    return;
  }
  const standard = select.value || DEFAULT_AUTH_STANDARD;
  const company = getActiveCompany();
  const preliminaryTemplate = getAuthorizationLetterTemplate(standard, 'preliminary');
  const finalTemplate = getAuthorizationLetterTemplate(standard, 'final');
  const finalPhase = createDefaultFinalPhase();
  finalPhase.address = finalTemplate.text || '';
  finalPhase.letterStyle = normalizeLetterStyle(finalTemplate.style);
  const dossier = normalizeAuthorizationDossier({
    id: generateDocumentId('authdos'),
    standard,
    entries: [],
    letter: preliminaryTemplate.text || '',
    letterStyle: normalizeLetterStyle(preliminaryTemplate.style),
    materialDocuments: { base: {}, filler: {} },
    customSteps: [],
    created_at: new Date().toISOString(),
    preliminaryClosed: false,
    finalPhase,
    stepVisibility: { preliminary: {}, final: {} },
  });
  ensureAuthorizationDossiers(company).push(dossier);
  activeAuthorizationDossierId = dossier.id;
  persistState();
  renderAuthorizationDossierControls();
}

function renderAuthorizationDossierControls(){
  const company = getActiveCompany();
  const dossiers = ensureAuthorizationDossiers(company);
  renderAuthorizationDossierArchive();
  const standardSelect = document.getElementById('auth_dossier_standard_select');
  if(standardSelect){
    const previous = standardSelect.value;
    standardSelect.innerHTML = '';
    const standards = getStandardsForType('authorization');
    standards.forEach(standard => {
      const option = document.createElement('option');
      option.value = standard.id;
      option.textContent = standard.label || standard.id;
      standardSelect.appendChild(option);
    });
    if(previous && Array.from(standardSelect.options).some(opt => opt.value === previous)){
      standardSelect.value = previous;
    }
  }
  const switcher = document.getElementById('auth_dossier_switcher');
  const emptyState = document.getElementById('auth_dossier_empty_state');
  const detail = document.getElementById('auth_dossier_detail');
  if(!switcher || !emptyState || !detail){
    return;
  }
  switcher.innerHTML = '';
  if(dossiers.length === 0){
    emptyState.classList.remove('hidden');
    renderAuthorizationDossierDetail(null);
    return;
  }
  emptyState.classList.add('hidden');
  detail.classList.remove('hidden');
  dossiers.forEach(dossier => {
    if(!dossier || !dossier.id){
      return;
    }
    const button = document.createElement('button');
    button.type = 'button';
    const label = dossier.name && dossier.name.trim()
      ? dossier.name.trim()
      : `${getStandardLabel(dossier.standard)} ¬∑ ${new Date(dossier.created_at || Date.now()).toLocaleDateString('ro-RO')}`;
    button.textContent = label;
    button.dataset.id = dossier.id;
    const isActive = dossier.id === activeAuthorizationDossierId;
    button.classList.toggle('active', isActive);
    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    button.addEventListener('click', () => {
      activeAuthorizationDossierId = dossier.id;
      renderAuthorizationDossierControls();
    });
    switcher.appendChild(button);
  });
  const active = getActiveAuthorizationDossier(company);
  renderAuthorizationDossierDetail(active);
}

function renderAuthorizationDossierDetail(dossier){
  const detail = document.getElementById('auth_dossier_detail');
  renderAuthorizationDossierArchive();
  if(!detail){
    return;
  }
  const editorBody = document.getElementById('auth_dossier_editor_body');
  const titleEl = document.getElementById('auth_dossier_title');
  const opisTitle = document.getElementById('auth_dossier_opis_title');
  const standardLabel = document.getElementById('auth_dossier_standard_label');
  const headerBar = detail.querySelector('.dossier-header-bar');
  if(!dossier){
    if(editorBody){
      editorBody.classList.add('hidden');
    }
    if(headerBar){
      headerBar.classList.add('hidden');
    }
    if(titleEl){
      titleEl.textContent = 'Nu existƒÉ dosar activ';
    }
    if(standardLabel){
      standardLabel.textContent = '';
    }
    if(opisTitle){
      opisTitle.innerHTML = '<div>OPIS</div><div>SelecteazƒÉ sau creeazƒÉ un dosar nou.</div>';
    }
    detail.classList.remove('hidden');
    return;
  }
  detail.classList.remove('hidden');
  if(editorBody){
    editorBody.classList.remove('hidden');
  }
  if(headerBar){
    headerBar.classList.remove('hidden');
  }
  const company = getActiveCompany();
  ensureAuthorizationStepVisibility(dossier);
  ensureDossierMaterialDocuments(dossier);
  ensureDossierWelderDocuments(dossier);
  ensureDossierCustomSteps(dossier);
  const finalPhase = ensureFinalPhase(dossier);
  ensureFinalPhaseCustomSteps(dossier);
  ensureDossierLetterStyle(dossier);
  ensureFinalPhaseLetterStyle(dossier);
  const standard = dossier.standard || DEFAULT_AUTH_STANDARD;
  const preliminaryTemplate = getAuthorizationLetterTemplate(standard, 'preliminary');
  const finalTemplate = getAuthorizationLetterTemplate(standard, 'final');
  let defaultsApplied = false;
  if((!dossier.letter || !dossier.letter.trim()) && preliminaryTemplate.text){
    dossier.letter = preliminaryTemplate.text;
    defaultsApplied = true;
  }
  if((!finalPhase.address || !finalPhase.address.trim()) && finalTemplate.text){
    finalPhase.address = finalTemplate.text;
    defaultsApplied = true;
  }
  if(standard === 'ASME_IX'){
    if(dossier.letterStyle && dossier.letterStyle.size < 13){
      dossier.letterStyle.size = 13;
      defaultsApplied = true;
    }
    if(finalPhase.letterStyle && finalPhase.letterStyle.size < 13){
      finalPhase.letterStyle.size = 13;
      defaultsApplied = true;
    }
  }
  if(defaultsApplied){
    persistState();
  }
  if(titleEl){
    titleEl.textContent = computeDossierTitle(dossier);
  }
  if(opisTitle){
    const subtitle = computeDossierSubtitle(dossier);
    opisTitle.innerHTML = `<div>OPIS</div><div>${escapeHtml(subtitle)}</div>`;
  }
  if(standardLabel){
    standardLabel.textContent = getStandardLabel(dossier.standard);
  }
  const prelimSettings = getAuthorizationDossierPhaseSettings(company, 'preliminary');
  const finalSettings = getAuthorizationDossierPhaseSettings(company, 'final');
  const numberingCheckbox = document.getElementById('auth_dossier_page_numbers');
  if(numberingCheckbox){
    const shouldNumber = prelimSettings && prelimSettings.pageNumbering !== false;
    if(numberingCheckbox.checked !== shouldNumber){
      numberingCheckbox.checked = shouldNumber;
    }
  }
  const prelimStartInput = document.getElementById('auth_dossier_start_page');
  if(prelimStartInput){
    const current = prelimSettings && prelimSettings.startPage ? prelimSettings.startPage : 1;
    if(Number(prelimStartInput.value) !== current){
      prelimStartInput.value = current;
    }
  }
  const prelimOffsetInput = document.getElementById('auth_dossier_page_offset');
  if(prelimOffsetInput){
    const offset = prelimSettings && prelimSettings.pageOffset ? prelimSettings.pageOffset : 0;
    if(Number(prelimOffsetInput.value) !== offset){
      prelimOffsetInput.value = offset;
    }
  }
  const finalCheckbox = document.getElementById('auth_final_page_numbers');
  if(finalCheckbox){
    const shouldNumberFinal = finalSettings && finalSettings.pageNumbering !== false;
    if(finalCheckbox.checked !== shouldNumberFinal){
      finalCheckbox.checked = shouldNumberFinal;
    }
  }
  const finalStartInput = document.getElementById('auth_final_start_page');
  if(finalStartInput){
    const finalStart = finalSettings && finalSettings.startPage ? finalSettings.startPage : 1;
    if(Number(finalStartInput.value) !== finalStart){
      finalStartInput.value = finalStart;
    }
  }
  const finalOffsetInput = document.getElementById('auth_final_page_offset');
  if(finalOffsetInput){
    const finalOffset = finalSettings && finalSettings.pageOffset ? finalSettings.pageOffset : 0;
    if(Number(finalOffsetInput.value) !== finalOffset){
      finalOffsetInput.value = finalOffset;
    }
  }
  refreshAuthorizationDossierOpisList(dossier, company, prelimSettings);
  const letterField = document.getElementById('auth_dossier_letter');
  if(letterField){
    const shouldShowLetter = !isAuthorizationLetterUsingTemplate(standard, dossier.letter, 'preliminary');
    const letterPlain = shouldShowLetter ? letterHtmlToPlainText(dossier.letter) : '';
    if(letterField.value !== letterPlain){
      letterField.value = letterPlain;
    }
  }
  const finalLetterField = document.getElementById('auth_final_letter');
  if(finalLetterField){
    const shouldShowFinalLetter = !isAuthorizationLetterUsingTemplate(standard, finalPhase.address, 'final');
    const finalLetterPlain = shouldShowFinalLetter ? letterHtmlToPlainText(finalPhase.address) : '';
    if(finalLetterField.value !== finalLetterPlain){
      finalLetterField.value = finalLetterPlain;
    }
  }
  const prelimToggle = document.getElementById('auth_phase_preliminary_closed');
  if(prelimToggle && prelimToggle.checked !== !!dossier.preliminaryClosed){
    prelimToggle.checked = !!dossier.preliminaryClosed;
  }
  const finalToggle = document.getElementById('auth_phase_final_closed');
  if(finalToggle && finalToggle.checked !== !!finalPhase.closed){
    finalToggle.checked = !!finalPhase.closed;
  }
  populateAuthorizationDossierFormOptions(company);
  renderAuthorizationDossierTable(dossier, company);
  renderAuthorizationDossierProcedureDocs(dossier, company);
  renderAuthorizationDossierWelderDocs(dossier, company);
  renderAuthorizationDossierMaterialSections(dossier);
  renderAuthorizationDossierCustomSteps(dossier);
  renderFinalPhaseSections(dossier, company);
  refreshFinalPhaseOpis(dossier, company);
  updateAuthorizationStepVisibilityControls(dossier);
  renderAuthorizationDossierArchive();
}

let authorizationOpisRenderToken = 0;
let finalOpisRenderToken = 0;

function refreshAuthorizationDossierOpisList(dossier, company, prelimSettings){
  const opisList = document.getElementById('auth_dossier_opis_list');
  if(!opisList){
    return;
  }
  const token = ++authorizationOpisRenderToken;
  opisList.innerHTML = '';
  const placeholder = document.createElement('li');
  placeholder.className = 'muted';
  placeholder.textContent = 'Se calculeazƒÉ paginile dosarului‚Ä¶';
  opisList.appendChild(placeholder);
  const options = {
    phase: 'preliminary',
    startPage: prelimSettings && prelimSettings.startPage ? prelimSettings.startPage : 1,
    pageOffset: prelimSettings && prelimSettings.pageOffset ? prelimSettings.pageOffset : 0,
  };
  computeDossierOpis(dossier, company, options).then(items => {
    if(token !== authorizationOpisRenderToken){
      return;
    }
    opisList.innerHTML = '';
    if(!items || items.length === 0){
      const emptyItem = document.createElement('li');
      emptyItem.className = 'muted';
      emptyItem.textContent = 'Dosarul nu con»õine sec»õiuni.';
      opisList.appendChild(emptyItem);
      return;
    }
    items.forEach(item => {
      const li = document.createElement('li');
      const info = document.createElement('div');
      info.className = 'opis-info';
      const label = document.createElement('div');
      label.className = 'opis-label';
      const labelSpan = document.createElement('span');
      labelSpan.textContent = item.label;
      label.appendChild(labelSpan);
      info.appendChild(label);
      const page = document.createElement('span');
      page.className = 'opis-page';
      page.textContent = item.pageCount > 1
        ? `Pagina ${item.startPage}-${item.endPage}`
        : `Pagina ${item.startPage}`;
      li.appendChild(info);
      li.appendChild(page);
      opisList.appendChild(li);
    });
  }).catch(error => {
    if(token !== authorizationOpisRenderToken){
      return;
    }
    console.error('Nu s-a putut actualiza opisul dosarului.', error);
    opisList.innerHTML = '';
    const errorItem = document.createElement('li');
    errorItem.className = 'muted';
    errorItem.textContent = 'Nu s-a putut calcula opisul.';
    opisList.appendChild(errorItem);
  });
}

function resolveProcedureLabel(company, procedureId){
  if(!procedureId){
    return '';
  }
  const numericId = Number(procedureId);
  if(Number.isNaN(numericId)){
    return '';
  }
  const procedure = company.qualifications.find(item => item && item.category === 'procedee' && item.id === numericId);
  if(!procedure){
    return '';
  }
  const parts = [getStandardLabel(procedure.standard)];
  if(procedure.process){
    parts.push(procedure.process);
  }
  if(procedure.position){
    parts.push(procedure.position);
  }
  return parts.filter(Boolean).join(' ¬∑ ');
}

function getAttachmentMimeType(attachment){
  if(!attachment || typeof attachment !== 'object'){
    return '';
  }
  if(attachment.type && typeof attachment.type === 'string' && attachment.type.trim()){
    return attachment.type.trim().toLowerCase();
  }
  if(attachment.data && typeof attachment.data === 'string'){
    const match = attachment.data.match(/^data:([^;,]+)[;,]/i);
    if(match && match[1]){
      return match[1].toLowerCase();
    }
  }
  return '';
}

function isPdfAttachment(attachment){
  const mime = getAttachmentMimeType(attachment);
  if(mime){
    return mime === 'application/pdf';
  }
  return Boolean(attachment && typeof attachment.data === 'string' && attachment.data.startsWith('data:application/pdf'));
}

function createPrintAttachmentEmbed(attachment, options){
  if(!attachment || !attachment.data){
    return '<p class="section-text">Document indisponibil pentru afi»ôare.</p>';
  }
  const mime = getAttachmentMimeType(attachment);
  const data = attachment.data;
  const objectUrl = dataUrlToObjectUrl(data);
  const source = objectUrl || data;
  const safeName = escapeHtml(attachment.name || 'document');
  const bare = Boolean(options && options.bare);
  const frameClasses = ['attachment-frame'];
  if(bare){
    frameClasses.push('bare');
  }
  if(mime && mime.startsWith('image/')){
    return `<div class="${frameClasses.join(' ')}"><img src="${source}" alt="${safeName}" /></div>`;
  }
  if(mime === 'application/pdf' || data.startsWith('data:application/pdf')){
    const hasHash = source.includes('#');
    const pdfSrc = `${source}${hasHash ? '&' : '#'}toolbar=0&navpanes=0&scrollbar=0&zoom=page-fit`;
    return `<div class="${frameClasses.join(' ')}"><object data="${pdfSrc}" type="application/pdf" aria-label="${safeName}"><embed src="${pdfSrc}" type="application/pdf" /></object></div>`;
  }
  return `<div class="${frameClasses.join(' ')}"><iframe src="${source}" title="${safeName}"></iframe></div>`;
}

function decodePdfSampleData(dataUrl){
  if(!dataUrl || typeof dataUrl !== 'string'){
    return '';
  }
  const commaIndex = dataUrl.indexOf(',');
  let base64 = commaIndex >= 0 ? dataUrl.slice(commaIndex + 1) : dataUrl;
  if(!base64){
    return '';
  }
  base64 = base64.replace(/\s+/g, '');
  if(!base64){
    return '';
  }
  const SAMPLE_LIMIT = 500000;
  let sample = base64.slice(0, SAMPLE_LIMIT);
  const padding = sample.length % 4;
  if(padding){
    sample = sample.padEnd(sample.length + (4 - padding), '=');
  }
  try {
    return atob(sample);
  } catch (error) {
    console.warn('Nu s-a putut decoda e»ôantionul PDF pentru orientare.', error);
    return '';
  }
}

function detectPdfOrientation(attachment){
  if(!isPdfAttachment(attachment)){
    return null;
  }
  const binary = decodePdfSampleData(attachment.data);
  if(!binary){
    return null;
  }
  const mediaBoxRegex = /\/MediaBox\s*\[\s*([-+]?\d*\.?\d+)\s+([-+]?\d*\.?\d+)\s+([-+]?\d*\.?\d+)\s+([-+]?\d*\.?\d+)\s*\]/g;
  let orientation = null;
  let match;
  let inspected = 0;
  while((match = mediaBoxRegex.exec(binary)) !== null){
    inspected += 1;
    const x1 = parseFloat(match[1]);
    const y1 = parseFloat(match[2]);
    const x2 = parseFloat(match[3]);
    const y2 = parseFloat(match[4]);
    if(!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)){
      continue;
    }
    const width = Math.abs(x2 - x1);
    const height = Math.abs(y2 - y1);
    if(width <= 0 || height <= 0){
      continue;
    }
    const pageOrientation = width > height ? 'landscape' : 'portrait';
    if(!orientation){
      orientation = pageOrientation;
    } else if(orientation !== pageOrientation){
      orientation = null;
      break;
    }
    if(inspected > 12){
      break;
    }
  }
  if(!orientation){
    return null;
  }
  const rotateMatch = /\/Rotate\s+(-?\d+)/.exec(binary);
  if(rotateMatch){
    const rotation = Math.abs(parseInt(rotateMatch[1], 10) || 0) % 360;
    if(rotation === 90 || rotation === 270){
      orientation = orientation === 'portrait' ? 'landscape' : 'portrait';
    }
  }
  return orientation;
}

function getAttachmentPrintOrientation(attachment){
  if(isPdfAttachment(attachment)){
    return detectPdfOrientation(attachment);
  }
  return null;
}

function createPrintAttachmentSection(options){
  const attachment = options && options.attachment ? options.attachment : null;
  const bare = Boolean(options && options.bare);
  const title = !bare && options && options.title ? `<h2 class="section-heading">${escapeHtml(options.title)}</h2>` : '';
  const details = [];
  if(!bare && options && options.subtitle){
    details.push(`<span>${escapeHtml(options.subtitle)}</span>`);
  }
  if(!bare && attachment && attachment.name){
    details.push(`<span>Fi»ôier: ${escapeHtml(attachment.name)}</span>`);
  }
  const meta = details.length ? `<div class="attachment-meta">${details.join('')}</div>` : '';
  const classes = ['attachment-section'];
  if(bare){
    classes.push('bare');
  }
  if(isPdfAttachment(attachment)){
    classes.push('pdf-attachment');
  }
  return `<div class="${classes.join(' ')}">${title}${meta}${createPrintAttachmentEmbed(attachment, { bare })}</div>`;
}

function gatherProceduresForEntries(entries, company){
  const map = new Map();
  (Array.isArray(entries) ? entries : []).forEach(entry => {
    if(!entry || !entry.procedure_id){
      return;
    }
    if(map.has(entry.procedure_id)){
      return;
    }
    const procedure = company.qualifications.find(q => q && q.category === 'procedee' && q.id === entry.procedure_id);
    if(procedure){
      map.set(entry.procedure_id, procedure);
    }
  });
  return Array.from(map.values()).sort((a, b) => {
    const labelA = resolveProcedureLabel(company, a.id) || '';
    const labelB = resolveProcedureLabel(company, b.id) || '';
    return labelA.localeCompare(labelB, 'ro', { sensitivity: 'base' });
  });
}

function findWelderRecordForDossier(welderId, company){
  if(!welderId){
    return null;
  }
  if(company){
    const active = Array.isArray(company.welders)
      ? company.welders.find(w => w && w.id === welderId)
      : null;
    if(active){
      return { welder: active, archived: false, company };
    }
    const archived = Array.isArray(company.archivedWelders)
      ? company.archivedWelders.find(entry => entry && entry.welder && entry.welder.id === welderId)
      : null;
    if(archived && archived.welder){
      return { welder: archived.welder, archived: true, company };
    }
  }
  if(state && Array.isArray(state.companies)){
    for(const otherCompany of state.companies){
      if(!otherCompany || otherCompany === company){
        continue;
      }
      const active = Array.isArray(otherCompany.welders)
        ? otherCompany.welders.find(w => w && w.id === welderId)
        : null;
      if(active){
        return { welder: active, archived: false, company: otherCompany };
      }
      const archived = Array.isArray(otherCompany.archivedWelders)
        ? otherCompany.archivedWelders.find(entry => entry && entry.welder && entry.welder.id === welderId)
        : null;
      if(archived && archived.welder){
        return { welder: archived.welder, archived: true, company: otherCompany };
      }
    }
  }
  return null;
}

function gatherWelderRecords(entries, company){
  const ids = new Set();
  (Array.isArray(entries) ? entries : []).forEach(entry => {
    if(entry && entry.welder_id){
      ids.add(entry.welder_id);
    }
  });
  const records = Array.from(ids).map(id => findWelderRecordForDossier(id, company)).filter(Boolean);
  records.sort((a, b) => {
    const nameA = a && a.welder && a.welder.name ? a.welder.name : '';
    const nameB = b && b.welder && b.welder.name ? b.welder.name : '';
    return nameA.localeCompare(nameB, 'ro', { sensitivity: 'base' });
  });
  return records;
}

function welderRequiresWeldingLog(dossier, welderId, welder, company){
  if(!dossier || !Number.isInteger(welderId)){
    return false;
  }
  const standard = typeof dossier.standard === 'string' ? dossier.standard : '';
  if(standard !== 'ASME_IX'){
    return false;
  }
  const entries = Array.isArray(dossier.entries) ? dossier.entries : [];
  const hasExtension = entries.some(entry => entry && entry.welder_id === welderId && entry.source === 'prelungire');
  if(!hasExtension){
    return false;
  }
  let targetWelder = welder && welder.id === welderId ? welder : null;
  if(!targetWelder){
    const record = findWelderRecordForDossier(welderId, company || getActiveCompany());
    if(record && record.welder){
      targetWelder = record.welder;
    }
  }
  if(targetWelder){
    const log = ensureWelderWeldingLog(targetWelder);
    if(!isWeldingLogIncluded(log)){
      return false;
    }
  }
  return true;
}

function welderRequiresAuthorizationAttachment(dossier, welderId){
  if(!dossier || !Number.isInteger(welderId)){
    return false;
  }
  const entries = Array.isArray(dossier.entries) ? dossier.entries : [];
  return entries.some(entry => entry && entry.welder_id === welderId && entry.source === 'prelungire');
}

function getWelderMissingDocuments(welder){
  if(!welder){
    return ['documente personale'];
  }
  if(welder.bundle && welder.bundle.data){
    return [];
  }
  const missing = [];
  if(!welder.id_card || !welder.id_card.data){
    missing.push('carte identitate');
  }
  if(!welder.diploma || !welder.diploma.data){
    missing.push('diplomƒÉ');
  }
  if(!welder.contract || !welder.contract.data){
    missing.push('contract');
  }
  if(!welder.aptitude || !welder.aptitude.data){
    missing.push('fi»ôƒÉ aptitudini');
  }
  return missing;
}

function gatherExtensionAuthorizationDocs(entries, company){
  const map = new Map();
  const seen = new Set();
  (Array.isArray(entries) ? entries : []).forEach(entry => {
    if(!entry || entry.source !== 'prelungire'){
      return;
    }
    const qualificationId = entry.qualification_id;
    if(!qualificationId){
      return;
    }
    const welderId = entry.welder_id || null;
    if(!welderId){
      return;
    }
    const key = `${welderId}_${qualificationId}`;
    if(seen.has(key)){
      return;
    }
    const qualification = company.qualifications.find(q => q && q.id === qualificationId && q.category === 'autorizatii');
    if(!qualification || !qualification.attachment || !qualification.attachment.data){
      return;
    }
    seen.add(key);
    if(!map.has(welderId)){
      map.set(welderId, []);
    }
    map.get(welderId).push(qualification);
  });
  return map;
}

function collectProcedureAttachmentSections(entries, company){
  const sections = [];
  const procedures = gatherProceduresForEntries(entries, company);
  procedures.forEach(proc => {
    if(!proc || !proc.attachment || !proc.attachment.data){
      return;
    }
    const label = resolveProcedureLabel(company, proc.id) || getStandardLabel(proc.standard) || 'Procedeu omologat';
    const orientation = getAttachmentPrintOrientation(proc.attachment) || 'portrait';
    sections.push({
      id: `procedure_attachment_${proc.id}`,
      label: `Procedeu omologat ‚Äì ${label}`,
      orientation,
      getContent: () => createPrintAttachmentSection({
        attachment: proc.attachment,
        bare: true,
      }),
      fullBleed: true,
      showBranding: false,
      attachment: proc.attachment,
    });
  });
  return sections;
}

function collectWelderAttachmentSections(entries, company, dossier){
  const sections = [];
  const records = gatherWelderRecords(entries, company);
  const extensionDocsMap = gatherExtensionAuthorizationDocs(entries, company);
  const welderDocsMap = dossier ? ensureDossierWelderDocuments(dossier) : {};
  records.forEach(record => {
    const welder = record.welder;
    if(!welder){
      return;
    }
    const welderName = welder.name || 'Sudor';
    const needsAuthorizationAttachment = dossier ? welderRequiresAuthorizationAttachment(dossier, welder.id) : false;
    if(welder.bundle && welder.bundle.data){
      const bundleOrientation = getAttachmentPrintOrientation(welder.bundle) || 'portrait';
      sections.push({
        id: `welder_attachment_${welder.id}_bundle`,
        label: `Documente personale ‚Äì ${welderName}`,
        orientation: bundleOrientation,
        getContent: () => createPrintAttachmentSection({
          attachment: welder.bundle,
          bare: true,
        }),
        fullBleed: true,
        showBranding: false,
        attachment: welder.bundle,
      });
      return;
    }
    const attachmentKeys = [
      { key: 'id_card', label: 'Carte de identitate' },
      { key: 'diploma', label: 'DiplomƒÉ' },
      { key: 'contract', label: 'Contract de muncƒÉ' },
      { key: 'aptitude', label: 'Fi»ôƒÉ de aptitudini' },
    ];
    attachmentKeys.forEach(descriptor => {
      const attachment = welder[descriptor.key];
      if(!attachment || !attachment.data){
        return;
      }
      const orientation = getAttachmentPrintOrientation(attachment) || 'portrait';
      sections.push({
        id: `welder_attachment_${welder.id}_${descriptor.key}`,
        label: `${descriptor.label} ‚Äì ${welderName}`,
        orientation,
        getContent: () => createPrintAttachmentSection({
          attachment,
          bare: true,
        }),
        fullBleed: true,
        showBranding: false,
        attachment,
      });
    });
    const extensionDocs = needsAuthorizationAttachment && extensionDocsMap && extensionDocsMap.has(welder.id)
      ? extensionDocsMap.get(welder.id)
      : [];
    if(extensionDocs && extensionDocs.length){
      extensionDocs.forEach(qualification => {
        if(!qualification || !qualification.attachment || !qualification.attachment.data){
          return;
        }
        const orientation = getAttachmentPrintOrientation(qualification.attachment) || 'portrait';
        const standardLabel = getStandardLabel(qualification.standard);
        sections.push({
          id: `welder_extension_${welder.id}_${qualification.id}`,
          label: `Autoriza»õie existentƒÉ ‚Äì ${welderName}${standardLabel ? ` ¬∑ ${standardLabel}` : ''}`,
          orientation,
          getContent: () => createPrintAttachmentSection({
            attachment: qualification.attachment,
            bare: true,
          }),
          fullBleed: true,
          showBranding: false,
          attachment: qualification.attachment,
        });
      });
    }
    const manualDocs = needsAuthorizationAttachment && welderDocsMap && welderDocsMap[String(welder.id)]
      ? welderDocsMap[String(welder.id)]
      : [];
    if(Array.isArray(manualDocs)){
      manualDocs.forEach(doc => {
        if(!doc || !doc.data){
          return;
        }
        const orientation = getAttachmentPrintOrientation(doc) || 'portrait';
        sections.push({
          id: `welder_manual_${welder.id}_${doc.id}`,
          label: `Autoriza»õie ata»ôatƒÉ √Æn dosar ‚Äì ${welderName}`,
          orientation,
          getContent: () => createPrintAttachmentSection({
            attachment: doc,
            bare: true,
          }),
          fullBleed: true,
          showBranding: false,
          attachment: doc,
        });
      });
    }
  });
  return sections;
}

function collectMaterialAttachmentSections(dossier){
  if(!dossier){
    return [];
  }
  ensureDossierMaterialDocuments(dossier);
  const sections = [];
  const configs = [
    { key: 'base', label: 'Material de bazƒÉ', step: 'Pasul 6' },
    { key: 'filler', label: 'Material de adaos', step: 'Pasul 7' },
  ];
  configs.forEach(config => {
    const documentsMap = dossier.materialDocuments[config.key] || {};
    Object.keys(documentsMap).sort((a, b) => a.localeCompare(b, 'ro', { sensitivity: 'base' })).forEach(materialName => {
      const docs = Array.isArray(documentsMap[materialName]) ? documentsMap[materialName] : [];
      docs.forEach((doc, index) => {
        if(!doc || !doc.data){
          return;
        }
        const docId = doc.id ? String(doc.id) : `${materialName.replace(/\W+/g, '_')}_${index}`;
        const orientation = getAttachmentPrintOrientation(doc) || 'portrait';
        sections.push({
          id: `material_${config.key}_${docId}`,
          label: `${config.label} ‚Äì ${materialName}`,
          orientation,
          getContent: () => createPrintAttachmentSection({
            attachment: doc,
            bare: true,
          }),
          fullBleed: true,
          showBranding: false,
          attachment: doc,
        });
      });
    });
  });
  return sections;
}

function collectCustomStepSections(dossier){
  const sections = [];
  if(!dossier){
    return sections;
  }
  const steps = ensureDossierCustomSteps(dossier);
  steps.forEach(step => {
    if(step && step.include === false){
      return;
    }
    const attachments = Array.isArray(step.attachments) ? step.attachments.filter(att => att && att.data) : [];
    if(attachments.length === 0){
      return;
    }
    const label = step.opis ? step.opis : (step.name || 'Pas suplimentar');
    sections.push({
      id: `custom_step_${step.id}`,
      label,
      attachments,
      fullBleed: true,
      showBranding: false,
    });
  });
  return sections;
}

function renderWeldingLogPrintHtml(welder, log){
  const welderName = welder && welder.name ? welder.name : 'Sudor';
  const numberLabel = log && log.number ? `<span class="muted">Nr. fi»ôƒÉ: ${escapeHtml(log.number)}</span>` : '';
  const entries = Array.isArray(log && log.entries) ? log.entries : [];
  const rows = entries.length > 0
    ? entries.map(entry => {
      return `<tr>
        <td>${escapeHtml(entry.date || '')}</td>
        <td>${escapeHtml(entry.contract || '')}</td>
        <td>${escapeHtml(entry.work || '')}</td>
        <td>${escapeHtml(entry.material || '')}</td>
        <td>${escapeHtml(entry.thickness || '')}</td>
        <td>${escapeHtml(entry.process || '')}</td>
        <td>${escapeHtml(entry.position || '')}</td>
        <td>${escapeHtml(entry.ndt || '')}</td>
        <td>${escapeHtml(entry.dt || '')}</td>
        <td>${escapeHtml(entry.remarks || '')}</td>
      </tr>`;
    }).join('')
    : '<tr><td colspan="10" class="muted">Nu existƒÉ √ÆnregistrƒÉri √Æn fi»ôa de eviden»õƒÉ.</td></tr>';
  return `
    <div class="welding-log-print">
      <div class="welding-log-print-header"><strong>${escapeHtml(welderName)}</strong>${numberLabel}</div>
      <table class="welding-log-print-table">
        <thead>
          <tr>
            <th>Data</th>
            <th>Nr. contract</th>
            <th>Lucrare</th>
            <th>Material / piesƒÉ</th>
            <th>Grosime</th>
            <th>Procedeu / WPS</th>
            <th>Pozi»õie</th>
            <th>Rezultate ND</th>
            <th>Rezultate D</th>
            <th>Observa»õii inspector</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;
}

async function buildWeldingLogPdfAttachment(welderName, log, company){
  if(!log){
    return null;
  }
  if(!window.PDFLib || !window.PDFLib.PDFDocument || !window.html2canvas){
    console.warn('Generarea PDF pentru fi»ôa de eviden»õƒÉ nu este disponibilƒÉ.');
    return null;
  }
  const displayName = welderName && welderName.trim() ? welderName.trim() : 'Sudor';
  const targetCompany = company || getActiveCompany();
  const pageHtml = renderPrintPage({
    company: targetCompany,
    orientation: 'portrait',
    heading: `${escapeHtml(displayName)} ‚Äì Fi»ôa de eviden»õƒÉ a lucrƒÉrilor de sudare`,
    content: renderWeldingLogPrintHtml({ name: displayName }, log),
    showBranding: true,
  });
  try {
    const rendered = await renderHtmlPageToCanvas(pageHtml, 'portrait');
    const pdfDoc = await window.PDFLib.PDFDocument.create();
    await appendCanvasToPdf(pdfDoc, rendered.canvas, rendered.orientation);
    const bytes = await pdfDoc.save();
    const base64 = uint8ArrayToBase64(bytes);
    const baseName = slugifyForFilename(displayName, 'sudor') || 'sudor';
    const numberSuffix = log && log.number ? `-${slugifyForFilename(log.number, 'fisa')}` : '';
    const filename = `${baseName}${numberSuffix}-fisa-sudare.pdf`;
    return {
      name: filename,
      data: `data:application/pdf;base64,${base64}`,
      type: 'application/pdf',
      pageCount: 1,
    };
  } catch (error) {
    console.error('Nu s-a putut genera PDF-ul pentru fi»ôa de eviden»õƒÉ.', error);
    return null;
  }
}

async function attachWeldingLogPdf(welderName, log, company){
  if(!log){
    return createEmptyWeldingLog();
  }
  if(!isWeldingLogIncluded(log)){
    log.attachment = null;
    return log;
  }
  if(!hasWeldingLogEntries(log)){
    log.attachment = null;
    return log;
  }
  if(!window.PDFLib || !window.PDFLib.PDFDocument || !window.html2canvas){
    return log;
  }
  try {
    const attachment = await buildWeldingLogPdfAttachment(welderName, log, company);
    if(attachment){
      log.attachment = attachment;
    }
  } catch (error) {
    console.error('Nu s-a putut actualiza PDF-ul pentru fi»ôa de eviden»õƒÉ.', error);
  }
  return log;
}

function collectFinalPhaseWelderAttachmentSections(dossier, company){
  const sections = [];
  if(!dossier || !company){
    return sections;
  }
  const records = getFinalPhaseWelderRecords(dossier, company);
  FINAL_WELDER_DOC_CONFIG.forEach(config => {
    if(!isAuthorizationStepVisible(dossier, 'final', config.key)){
      return;
    }
    const docsMap = ensureFinalPhaseWelderDocs(dossier, config.key);
    records.forEach(record => {
      if(!record || !record.welder || !Number.isInteger(record.welder.id)){
        return;
      }
      const welder = record.welder;
      const welderName = welder.name || 'Sudor';
      const list = Array.isArray(docsMap[String(welder.id)]) ? docsMap[String(welder.id)] : [];
      let counter = 1;
      list.forEach(doc => {
        if(!doc || !doc.data){
          return;
        }
        const orientation = getAttachmentPrintOrientation(doc) || 'portrait';
        const labelSuffix = list.length > 1 ? ` #${counter}` : '';
        sections.push({
          id: `final_${config.key}_${welder.id}_${doc.id}`,
          label: `${config.opisLabel} ‚Äì ${welderName}${labelSuffix}`,
          orientation,
          getContent: () => createPrintAttachmentSection({
            attachment: doc,
            bare: true,
          }),
          fullBleed: true,
          showBranding: false,
          attachment: doc,
        });
        counter += 1;
      });
    });
  });
  return sections;
}

function collectFinalPhaseGeneralAttachmentSections(dossier){
  const sections = [];
  if(!dossier){
    return sections;
  }
  const company = getActiveCompany();
  const records = getFinalPhaseWelderRecords(dossier, company);
  FINAL_GENERAL_DOC_CONFIG.forEach(config => {
    if(!isAuthorizationStepVisible(dossier, 'final', config.key)){
      return;
    }
    const list = ensureFinalPhaseGeneralList(dossier, config.key);
    let counter = 1;
    list.forEach(doc => {
      if(!doc || !doc.data){
        return;
      }
      const orientation = getAttachmentPrintOrientation(doc) || 'portrait';
      const labelSuffix = list.length > 1 ? ` #${counter}` : '';
      sections.push({
        id: `final_${config.key}_${doc.id}`,
        label: `${config.opisLabel}${labelSuffix}`,
        orientation,
        getContent: () => createPrintAttachmentSection({
          attachment: doc,
          bare: true,
        }),
        fullBleed: true,
        showBranding: false,
        attachment: doc,
      });
      counter += 1;
    });
  });
  if(!isAuthorizationStepVisible(dossier, 'final', 'examReports')){
    return sections;
  }
  records.forEach(record => {
    const welder = record && record.welder ? record.welder : null;
    if(!welder || !Number.isInteger(welder.id)){
      return;
    }
    if(!welderRequiresWeldingLog(dossier, welder.id, welder, company)){
      return;
    }
    const log = ensureWelderWeldingLog(welder);
    if(!hasWeldingLogEntries(log)){
      return;
    }
    const welderName = welder.name || 'Sudor';
    const attachment = log && log.attachment && log.attachment.data ? log.attachment : null;
    const section = {
      id: `final_welding_log_${welder.id}`,
      label: `${welderName} ‚Äì Fi»ôa de eviden»õƒÉ a lucrƒÉrilor de sudare`,
      orientation: 'portrait',
      showBranding: true,
    };
    if(attachment){
      section.attachment = attachment;
    } else {
      section.getContent = () => renderWeldingLogPrintHtml(welder, log);
      section.pageCount = 1;
    }
    sections.push(section);
  });
  return sections;
}

function collectFinalPhaseCustomStepSections(dossier){
  const sections = [];
  if(!dossier){
    return sections;
  }
  const steps = ensureFinalPhaseCustomSteps(dossier);
  steps.forEach(step => {
    if(step && step.include === false){
      return;
    }
    const attachments = Array.isArray(step.attachments) ? step.attachments.filter(att => att && att.data) : [];
    if(attachments.length === 0){
      return;
    }
    const label = step.opis ? step.opis : (step.name || 'Pas final');
    sections.push({
      id: `final_custom_step_${step.id}`,
      label,
      attachments,
      fullBleed: true,
      showBranding: false,
    });
  });
  return sections;
}

function describeAuthorizationDossierSections(dossier, company, options){
  const phase = options && options.phase ? options.phase : 'complete';
  const includePreliminary = phase === 'preliminary' || phase === 'complete';
  const includeFinal = phase === 'final' || phase === 'complete';
  ensureDossierMaterialDocuments(dossier);
  ensureDossierWelderDocuments(dossier);
  const entries = Array.isArray(dossier && dossier.entries) ? dossier.entries.filter(Boolean) : [];
  const sections = [];

  if(includePreliminary){
    if(isAuthorizationStepVisible(dossier, 'preliminary', 'letter')){
      const letterContent = buildAuthorizationLetterContent(dossier, { phase: 'preliminary' });
      sections.push({
        id: 'letter',
        label: 'AdresƒÉ documenta»õie preliminarƒÉ',
        heading: 'AdresƒÉ documenta»õie preliminarƒÉ',
        orientation: 'portrait',
        getContent: () => letterContent,
        showBranding: true,
        pageCount: 1,
      });
    }

    if(isAuthorizationStepVisible(dossier, 'preliminary', 'table')){
      const tableLabel = entries.length > 0
        ? 'Tabel autoriza»õii sudori'
        : 'Tabel autoriza»õii sudori (√Æn curs de completare)';
      sections.push({
        id: 'table',
        label: tableLabel,
        heading: 'Tabel autoriza»õii sudori',
        orientation: 'landscape',
        getContent: () => buildAuthorizationDossierTablePrintHtml(entries, company),
        showBranding: true,
        pageCount: 1,
      });
    }

    if(isAuthorizationStepVisible(dossier, 'preliminary', 'procedures')){
      collectProcedureAttachmentSections(entries, company).forEach(section => sections.push(section));
    }
    if(isAuthorizationStepVisible(dossier, 'preliminary', 'welderDocs')){
      collectWelderAttachmentSections(entries, company, dossier).forEach(section => sections.push(section));
    }
    const materialSections = collectMaterialAttachmentSections(dossier);
    if(isAuthorizationStepVisible(dossier, 'preliminary', 'baseMaterials')){
      materialSections.filter(section => section && section.id && section.id.startsWith('material_base_'))
        .forEach(section => sections.push(section));
    }
    if(isAuthorizationStepVisible(dossier, 'preliminary', 'fillerMaterials')){
      materialSections.filter(section => section && section.id && section.id.startsWith('material_filler_'))
        .forEach(section => sections.push(section));
    }
    collectCustomStepSections(dossier).forEach(section => sections.push(section));
  }

  if(includeFinal){
    ensureFinalPhase(dossier);
    if(isAuthorizationStepVisible(dossier, 'final', 'letter')){
      const finalLetterContent = buildAuthorizationLetterContent(dossier, { phase: 'final' });
      sections.push({
        id: 'final_letter',
        label: 'AdresƒÉ documenta»õie finalƒÉ',
        heading: 'AdresƒÉ documenta»õie finalƒÉ',
        orientation: 'portrait',
        getContent: () => finalLetterContent,
        showBranding: true,
        pageCount: 1,
      });
    }
    collectFinalPhaseWelderAttachmentSections(dossier, company).forEach(section => sections.push(section));
    collectFinalPhaseGeneralAttachmentSections(dossier).forEach(section => sections.push(section));
    collectFinalPhaseCustomStepSections(dossier).forEach(section => sections.push(section));
  }

  if(phase === 'final'){
    sections.subtitle = 'Documenta»õie finalƒÉ';
  } else {
    sections.subtitle = computeDossierSubtitle(dossier);
  }
  return sections;
}

async function getAttachmentPageCount(attachment){
  if(!attachment || !attachment.data){
    return 1;
  }
  if(typeof attachment.pageCount === 'number' && attachment.pageCount > 0){
    return Math.max(1, Math.round(attachment.pageCount));
  }
  const mime = getAttachmentMimeType(attachment);
  if(mime === 'application/pdf' && window.PDFLib && window.PDFLib.PDFDocument){
    try {
      const bytes = dataUrlToUint8Array(attachment.data);
      const externalDoc = await window.PDFLib.PDFDocument.load(bytes);
      const pages = externalDoc.getPageCount ? externalDoc.getPageCount() : externalDoc.getPageIndices().length;
      if(pages && pages > 0){
        attachment.pageCount = pages;
        return pages;
      }
    } catch (error) {
      console.warn('Nu s-a putut detecta numƒÉrul de pagini al unui document PDF.', error);
    }
  }
  attachment.pageCount = 1;
  return 1;
}

async function resolveSectionPageCount(section){
  if(!section){
    return 1;
  }
  if(typeof section.pageCount === 'number' && section.pageCount > 0){
    return Math.max(1, Math.round(section.pageCount));
  }
  if(section.attachment){
    return Math.max(1, await getAttachmentPageCount(section.attachment));
  }
  if(Array.isArray(section.attachments) && section.attachments.length > 0){
    let total = 0;
    for(const attachment of section.attachments){
      total += Math.max(1, await getAttachmentPageCount(attachment));
    }
    return total || 1;
  }
  return 1;
}

async function buildAuthorizationDossierPagePlan(dossier, company, options){
  const phase = options && options.phase ? options.phase : 'complete';
  const startPage = clampAuthorizationStartPage(options && options.startPage !== undefined ? options.startPage : 1);
  const pageOffset = clampAuthorizationPageOffset(options && options.pageOffset !== undefined ? options.pageOffset : 0);
  const sections = describeAuthorizationDossierSections(dossier, company, { phase }) || [];
  const subtitle = sections.subtitle || computeDossierSubtitle(dossier);
  const details = [];
  for(const section of sections){
    const pageCount = await resolveSectionPageCount(section);
    const rawLabel = section && section.label ? section.label : 'Sec»õiune';
    const label = cleanDossierSectionLabel(rawLabel);
    details.push({
      section,
      label,
      pageCount,
    });
  }
  let currentPage = startPage + (pageOffset <= 0 ? 1 : 0);
  details.forEach(detail => {
    detail.startPage = currentPage;
    detail.endPage = currentPage + detail.pageCount - 1;
    currentPage = detail.endPage + 1;
  });
  return { sections, details, subtitle, phase, startPage, pageOffset };
}

async function ensureWeldingLogPdfAttachments(dossier, company){
  if(!dossier || !company){
    return;
  }
  const records = getFinalPhaseWelderRecords(dossier, company);
  if(!Array.isArray(records) || records.length === 0){
    return;
  }
  let updated = false;
  for(const record of records){
    const welder = record && record.welder ? record.welder : null;
    if(!welder || !Number.isInteger(welder.id)){
      continue;
    }
    const needsLog = welderRequiresWeldingLog(dossier, welder.id, welder, company);
    const log = ensureWelderWeldingLog(welder);
    if(!needsLog || !hasWeldingLogEntries(log) || !isWeldingLogIncluded(log)){
      if(log && log.attachment){
        log.attachment = null;
        updated = true;
      }
      continue;
    }
    if(!log.attachment || !log.attachment.data){
      try {
        const attachment = await buildWeldingLogPdfAttachment(welder.name || 'Sudor', log, company);
        if(attachment){
          log.attachment = attachment;
          updated = true;
        }
      } catch (error) {
        console.error('Nu s-a putut pregƒÉti PDF-ul fi»ôei de eviden»õƒÉ pentru dosar.', error);
      }
    }
  }
  if(updated){
    persistState();
  }
}

function computeDossierSubtitle(dossier){
  const entries = Array.isArray(dossier && dossier.entries) ? dossier.entries : [];
  const flags = new Set();
  entries.forEach(entry => {
    const observation = entry && entry.observation ? String(entry.observation).toLowerCase() : '';
    if(observation.includes('omolog')){
      flags.add('omologare');
    }
    if(observation.includes('prelung')){
      flags.add('prelungire');
    }
    if(observation.includes('autoriz')){
      flags.add('autorizare');
    }
  });
  if(flags.size === 0){
    return 'Dosar de autorizare sudori';
  }
  const hasOmolog = flags.has('omologare');
  const hasAutorizare = flags.has('autorizare');
  const hasPrelungire = flags.has('prelungire');
  if(flags.size === 1){
    if(hasOmolog){
      return 'Dosar de omologare procedee de sudare';
    }
    if(hasPrelungire){
      return 'Dosar de prelungire autoriza»õii sudori';
    }
    return 'Dosar de autorizare sudori';
  }
  const parts = [];
  if(hasOmolog){
    parts.push('omologare procedee de sudare');
  }
  if(hasAutorizare){
    parts.push('autorizare sudori');
  }
  if(hasPrelungire){
    parts.push('prelungire autoriza»õii sudori');
  }
  return `Dosar de ${joinRomanianList(parts)}`;
}

function computeDossierTitle(dossier){
  if(!dossier){
    return 'Dosar autorizare';
  }
  if(dossier.name && dossier.name.trim()){
    return dossier.name.trim();
  }
  const subtitle = computeDossierSubtitle(dossier);
  const standardLabel = getStandardLabel(dossier.standard);
  return `${subtitle} ‚Äì ${standardLabel}`;
}

async function computeDossierOpis(dossier, company, options){
  const plan = await buildAuthorizationDossierPagePlan(dossier, company, options || {});
  return plan.details.map(detail => ({
    label: detail.label,
    pageCount: detail.pageCount,
    startPage: detail.startPage,
    endPage: detail.endPage,
  }));
}

function buildAuthorizationDossierTableRows(entries, company){
  const list = Array.isArray(entries) ? entries.filter(Boolean) : [];
  return list.map((entry, index) => {
    const welderName = entry && entry.welder_name ? entry.welder_name : (entry && entry.welder_id ? findWelderNameById(entry.welder_id) : '');
    const pansonCode = entry && entry.panson_code ? entry.panson_code : '';
    const welderCell = welderName
      ? (pansonCode ? `${welderName}\n${pansonCode}` : welderName)
      : (pansonCode ? `‚Äî\n${pansonCode}` : '‚Äî');
    const processParts = [];
    if(entry && entry.process){
      processParts.push(entry.process);
    }
    const procedureLabel = resolveProcedureLabel(company, entry && entry.procedure_id);
    if(procedureLabel){
      processParts.push(`Procedeu: ${procedureLabel}`);
    }
    const processCell = processParts.length ? processParts.join('\n') : '‚Äî';
    const baseQualityParts = [];
    if(entry && entry.base_quality){
      baseQualityParts.push(entry.base_quality);
    }
    if(entry && entry.base_material){
      baseQualityParts.push(`Material: ${entry.base_material}`);
    }
    const baseQualityCell = baseQualityParts.length ? baseQualityParts.join('\n') : '‚Äî';
    const fillerCell = entry && entry.filler_material ? entry.filler_material : '‚Äî';
    const positionCell = entry && entry.position ? entry.position : '‚Äî';
    const baseDimensionCell = entry && entry.base_dimension ? entry.base_dimension : '‚Äî';
    const diameterCell = entry && entry.diameter ? entry.diameter : '‚Äî';
    const domainParts = [];
    if(entry && entry.thickness_domain){
      domainParts.push(`Domeniu: ${entry.thickness_domain}`);
    }
    if(entry && entry.observation){
      domainParts.push(`Obs: ${entry.observation}`);
    }
    const domainCell = domainParts.length ? domainParts.join('\n') : '‚Äî';
    return {
      number: String(index + 1),
      welder: welderCell,
      process: processCell,
      baseQuality: baseQualityCell,
      filler: fillerCell,
      position: positionCell,
      baseDimension: baseDimensionCell,
      diameter: diameterCell,
      domain: domainCell,
    };
  });
}

function buildAuthorizationDossierTablePrintHtml(entries, company){
  if(!entries || entries.length === 0){
    return '<p class="section-text">Tabelul nu con»õine √ÆncƒÉ √ÆnregistrƒÉri.</p>';
  }
  const rows = entries.map((entry, index) => {
    const welderName = entry && entry.welder_name ? escapeHtml(entry.welder_name) : '‚Äî';
    const panson = entry && entry.panson_code ? `<div class="print-note">${escapeHtml(entry.panson_code)}</div>` : '';
    const procedureLabel = resolveProcedureLabel(company, entry && entry.procedure_id);
    const processParts = [];
    if(entry && entry.process){
      processParts.push(escapeHtml(entry.process));
    }
    if(procedureLabel){
      processParts.push(`<div class="print-note">Procedeu: ${escapeHtml(procedureLabel)}</div>`);
    }
    const processCell = processParts.length ? processParts.join('') : '‚Äî';
    const baseQuality = entry && entry.base_quality ? escapeHtml(entry.base_quality) : '‚Äî';
    const baseMaterial = entry && entry.base_material ? `<div class="print-note">Material: ${escapeHtml(entry.base_material)}</div>` : '';
    const filler = entry && entry.filler_material ? escapeHtml(entry.filler_material) : '‚Äî';
    const position = entry && entry.position ? escapeHtml(entry.position) : '‚Äî';
    const baseDimension = entry && entry.base_dimension ? escapeHtml(entry.base_dimension) : '‚Äî';
    const diameter = entry && entry.diameter ? escapeHtml(entry.diameter) : '‚Äî';
    const domainParts = [];
    if(entry && entry.thickness_domain){
      domainParts.push(`<div>Domeniu: ${escapeHtml(entry.thickness_domain)}</div>`);
    }
    if(entry && entry.observation){
      domainParts.push(`<div class="print-note">Obs: ${escapeHtml(entry.observation)}</div>`);
    }
    const domainCell = domainParts.length ? domainParts.join('') : '‚Äî';
    return `
      <tr>
        <td>${index + 1}</td>
        <td>${welderName}${panson}</td>
        <td>${processCell}</td>
        <td>${baseQuality}${baseMaterial}</td>
        <td>${filler}</td>
        <td>${position}</td>
        <td>${baseDimension}</td>
        <td>${diameter}</td>
        <td>${domainCell}</td>
      </tr>
    `;
  }).join('');
  return `
    <table class="print-table dossier-table">
      <thead>
        <tr>
          <th>Nr. crt.</th>
          <th>Numele »ôi prenumele / Panson</th>
          <th>Procedee de sudare</th>
          <th>Calitatea materialului de bazƒÉ</th>
          <th>Materiale de adaos</th>
          <th>Pozi»õii de sudare</th>
          <th>Grosime material de bazƒÉ</th>
          <th>Diametru »õeavƒÉ</th>
          <th>Domeniu grosimi / Observa»õii</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

function buildAuthorizationDossierProcedurePrintHtml(entries, company){
  const procedures = gatherProceduresForEntries(entries, company);
  if(procedures.length === 0){
    return '<p class="section-text">Nu existƒÉ procedee asociate √Æn tabel.</p>';
  }
  const items = procedures.map(proc => {
    const label = resolveProcedureLabel(company, proc.id) || getStandardLabel(proc.standard);
    const certificate = proc.certificate_no ? `Certificat: ${escapeHtml(proc.certificate_no)}` : 'Certificat: ‚Äî';
    const docInfo = proc.attachment && proc.attachment.name
      ? `Document: ${escapeHtml(proc.attachment.name)}`
      : 'Document: neata»ôat';
    return `
      <div class="doc-item">
        <div class="meta"><strong>${escapeHtml(label)}</strong><span>${certificate}</span></div>
        <div class="meta">${docInfo}</div>
      </div>
    `;
  });
  return `<div class="doc-list">${items.join('')}</div>`;
}

function buildAuthorizationDossierWelderDocsPrintHtml(entries, company){
  const records = gatherWelderRecords(entries, company);
  if(records.length === 0){
    return '<p class="section-text">Nu sunt selecta»õi sudori √Æn tabel.</p>';
  }
  const items = records.map(record => {
    const welder = record.welder;
    if(!welder){
      return '';
    }
    const docs = [];
    const attachmentFields = [
      ['Fotografie', welder.photo],
      ['Carte identitate', welder.id_card],
      ['DiplomƒÉ', welder.diploma],
      ['Contract de muncƒÉ', welder.contract],
      ['Fi»ôƒÉ aptitudini', welder.aptitude],
    ];
    attachmentFields.forEach(([label, attachment]) => {
      if(attachment && attachment.name){
        docs.push(`${label}: ${escapeHtml(attachment.name)}`);
      }
    });
    const docInfo = docs.length ? docs.join('<br>') : 'FƒÉrƒÉ documente disponibile';
    const welderInfo = [];
    if(welder.code){
      welderInfo.push(`Cod: ${escapeHtml(welder.code)}`);
    }
    if(welder.panson_id){
      const pansonCode = getPansonCodeById(welder.panson_id);
      if(pansonCode){
        welderInfo.push(`Panson: ${escapeHtml(pansonCode)}`);
      }
    }
    const subtitle = welderInfo.length ? `<span>${welderInfo.join(' ¬∑ ')}</span>` : '';
    return `
      <div class="doc-item">
        <div class="meta"><strong>${escapeHtml(welder.name || 'Sudor')}</strong>${subtitle}</div>
        <div class="meta">${docInfo}</div>
      </div>
    `;
  }).filter(Boolean);
  return `<div class="doc-list">${items.join('')}</div>`;
}

function buildAuthorizationDossierMaterialPrintHtml(type, dossier){
  ensureDossierMaterialDocuments(dossier);
  const collection = type === 'base' ? dossier.materialDocuments.base : dossier.materialDocuments.filler;
  const keys = Object.keys(collection || {});
  if(keys.length === 0){
    return '<p class="section-text">Nu au fost ata»ôate documente pentru aceastƒÉ categorie.</p>';
  }
  const items = keys.sort((a, b) => a.localeCompare(b, 'ro', { sensitivity: 'base' })).map(material => {
    const docs = Array.isArray(collection[material]) ? collection[material] : [];
    const names = docs.length
      ? docs.map(doc => escapeHtml(doc.name || 'document')).join('<br>')
      : 'FƒÉrƒÉ documente ata»ôate';
    return `
      <div class="doc-item">
        <div class="meta"><strong>${escapeHtml(material)}</strong><span>${type === 'base' ? 'Material de bazƒÉ' : 'Material de adaos'}</span></div>
        <div class="meta">${names}</div>
      </div>
    `;
  });
  return `<div class="doc-list">${items.join('')}</div>`;
}

function populateAuthorizationDossierFormOptions(company){
  const welderSelect = document.getElementById('auth_dossier_row_welder');
  if(welderSelect){
    const previous = welderSelect.value;
    welderSelect.innerHTML = '<option value="">SelecteazƒÉ sudor</option>';
    sortWelders(company.welders).forEach(welder => {
      const option = document.createElement('option');
      option.value = String(welder.id);
      option.textContent = welder.name;
      welderSelect.appendChild(option);
    });
    if(previous && Array.from(welderSelect.options).some(opt => opt.value === previous)){
      welderSelect.value = previous;
    } else {
      welderSelect.value = '';
    }
  }
  const procedureSelect = document.getElementById('auth_dossier_row_procedure');
  if(procedureSelect){
    const previous = procedureSelect.value;
    procedureSelect.innerHTML = '<option value="">FƒÉrƒÉ asociere</option>';
    company.qualifications.filter(q => q && q.category === 'procedee')
      .sort((a, b) => {
        const labelA = `${getStandardLabel(a.standard)} ${a.process || ''}`;
        const labelB = `${getStandardLabel(b.standard)} ${b.process || ''}`;
        return labelA.localeCompare(labelB, 'ro', { sensitivity: 'base' });
      })
      .forEach(proc => {
        const option = document.createElement('option');
        option.value = String(proc.id);
        option.textContent = `${getStandardLabel(proc.standard)} ¬∑ ${proc.process || ''}`;
        procedureSelect.appendChild(option);
      });
    if(previous && Array.from(procedureSelect.options).some(opt => opt.value === previous)){
      procedureSelect.value = previous;
    } else {
      procedureSelect.value = '';
    }
    procedureSelect.disabled = procedureSelect.options.length <= 1;
  }
  clearAuthorizationDossierForm();
}

function clearAuthorizationDossierForm(){
  ['auth_dossier_row_process','auth_dossier_row_base','auth_dossier_row_material','auth_dossier_row_filler','auth_dossier_row_position','auth_dossier_row_dimension','auth_dossier_row_diameter','auth_dossier_row_domain','auth_dossier_row_observation'].forEach(id => {
    const input = document.getElementById(id);
    if(input){
      input.value = '';
    }
  });
  const welderSelect = document.getElementById('auth_dossier_row_welder');
  if(welderSelect){
    welderSelect.value = '';
  }
  const procedureSelect = document.getElementById('auth_dossier_row_procedure');
  if(procedureSelect){
    procedureSelect.value = '';
  }
}

function handleAddAuthorizationDossierRow(){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('CreeazƒÉ mai √Ænt√¢i un dosar de autorizare.');
    return;
  }
  const welderSelect = document.getElementById('auth_dossier_row_welder');
  const procedureSelect = document.getElementById('auth_dossier_row_procedure');
  const getValue = id => {
    const input = document.getElementById(id);
    return input && input.value ? input.value.trim() : '';
  };
  const welderIdValue = welderSelect && welderSelect.value ? Number(welderSelect.value) : NaN;
  const welderId = Number.isNaN(welderIdValue) ? null : welderIdValue;
  const welder = welderId ? company.welders.find(w => w.id === welderId) : null;
  const procedureIdValue = procedureSelect && procedureSelect.value ? Number(procedureSelect.value) : NaN;
  const procedureId = Number.isNaN(procedureIdValue) ? null : procedureIdValue;
  const entryPayload = {
    id: generateDocumentId('dosrow'),
    welder_id: welder ? welder.id : null,
    welder_name: welder ? welder.name : '',
    panson_code: (() => {
      if(!welder){
        return '';
      }
      if(welder.panson_id){
        const panson = company.pansoane.find(p => p && p.id === welder.panson_id);
        if(panson && panson.code){
          return panson.code;
        }
      }
      return welder.code || '';
    })(),
    process: getValue('auth_dossier_row_process'),
    base_quality: getValue('auth_dossier_row_base'),
    base_material: getValue('auth_dossier_row_material'),
    filler_material: getValue('auth_dossier_row_filler'),
    position: getValue('auth_dossier_row_position'),
    base_dimension: getValue('auth_dossier_row_dimension'),
    diameter: getValue('auth_dossier_row_diameter'),
    thickness_domain: getValue('auth_dossier_row_domain'),
    observation: getValue('auth_dossier_row_observation'),
    source: 'manual',
    qualification_id: null,
    procedure_id: procedureId,
  };
  const hasContent = entryPayload.welder_id
    || entryPayload.process
    || entryPayload.base_quality
    || entryPayload.base_material
    || entryPayload.filler_material
    || entryPayload.position
    || entryPayload.base_dimension
    || entryPayload.diameter
    || entryPayload.thickness_domain
    || entryPayload.observation;
  if(!hasContent){
    alert('CompleteazƒÉ cel pu»õin un c√¢mp pentru a adƒÉuga r√¢ndul.');
    return;
  }
  const normalized = normalizeDossierEntry(entryPayload);
  dossier.entries.push(normalized);
  persistState();
  clearAuthorizationDossierForm();
  renderAuthorizationDossierDetail(dossier);
}

function pushAuthorizationToDossier(qualificationId, mode){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('CreeazƒÉ »ôi selecteazƒÉ un dosar de autorizare √Ænainte de a importa autoriza»õii.');
    return;
  }
  const qualification = company.qualifications.find(q => q && q.id === qualificationId && q.category === 'autorizatii');
  if(!qualification){
    alert('Autoriza»õia selectatƒÉ nu a fost gƒÉsitƒÉ.');
    return;
  }
  if(qualification.standard && dossier.standard && qualification.standard !== dossier.standard){
    const standardLabel = getStandardLabel(qualification.standard);
    alert(`Deschide un dosar de autorizare pentru standardul ${standardLabel} √Ænainte de a importa aceastƒÉ autoriza»õie.`);
    return;
  }
  const welder = qualification.welder_id ? company.welders.find(w => w.id === qualification.welder_id) : null;
  const pansonCode = (() => {
    if(!welder){
      return '';
    }
    if(welder.panson_id){
      const panson = company.pansoane.find(p => p && p.id === welder.panson_id);
      if(panson && panson.code){
        return panson.code;
      }
    }
    return welder.code || '';
  })();
  const baseObservation = mode === 'prelungire'
    ? 'Prelungire autoriza»õie'
    : 'Autorizare';
  const observation = qualification.observation
    ? `${baseObservation} ‚Äì ${qualification.observation}`
    : baseObservation;
  const normalized = normalizeDossierEntry({
    id: generateDocumentId('dosrow'),
    welder_id: welder ? welder.id : null,
    welder_name: welder ? welder.name : '',
    panson_code: pansonCode,
    process: qualification.process || '',
    base_quality: qualification.base_quality || '',
    base_material: qualification.base_material || '',
    filler_material: qualification.filler_material || '',
    position: qualification.position || '',
    base_dimension: qualification.base_dimension || '',
    diameter: qualification.diameter || '',
    observation,
    source: mode === 'prelungire' ? 'prelungire' : 'reautorizare',
    qualification_id: qualification.id,
    procedure_id: qualification.procedure_id || null,
    thickness_domain: qualification.thickness_domain || '',
  });
  dossier.entries.push(normalized);
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function updateAuthorizationDossierLetter(value){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  ensureDossierLetterStyle(dossier);
  dossier.letter = normalizeLetterInput(value, dossier.standard || DEFAULT_AUTH_STANDARD, 'preliminary');
  updateAuthorizationLetterTemplate(dossier.standard || DEFAULT_AUTH_STANDARD, 'preliminary', {
    text: dossier.letter,
    style: normalizeLetterStyle(dossier.letterStyle),
  });
  persistState();
  renderAuthorizationLetterPreview(dossier, company, 'preliminary');
}

function handleDeleteAuthorizationDossier(){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  if(!confirm('»òtergi acest dosar de autorizare? Opera»õia nu poate fi anulatƒÉ.')){
    return;
  }
  const dossiers = ensureAuthorizationDossiers(company);
  const index = dossiers.findIndex(entry => entry && entry.id === dossier.id);
  if(index !== -1){
    dossiers.splice(index, 1);
  }
  if(dossiers.length === 0){
    activeAuthorizationDossierId = null;
  } else if(!dossiers.some(entry => entry.id === activeAuthorizationDossierId)){
    activeAuthorizationDossierId = dossiers[0].id;
  }
  persistState();
  renderAuthorizationDossierControls();
}

function resetAuthorizationDossier(dossier){
  if(!dossier){
    return;
  }
  dossier.entries = [];
  dossier.letter = '';
  dossier.letterStyle = { ...DEFAULT_LETTER_STYLE };
  dossier.materialDocuments = { base: {}, filler: {} };
  dossier.welderDocuments = {};
  ensureDossierMaterialDocuments(dossier);
  ensureDossierWelderDocuments(dossier);
  ensureDossierLetterStyle(dossier);
  dossier.customSteps = [];
}

function slugifyForFilename(value, fallback){
  const safeFallback = fallback || 'document';
  if(!value || typeof value !== 'string'){
    return safeFallback;
  }
  const normalized = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  const cleaned = normalized.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-+|-+$/g, '').toLowerCase();
  return cleaned || safeFallback;
}

function dataUrlToUint8Array(dataUrl){
  if(!dataUrl || typeof dataUrl !== 'string'){
    return new Uint8Array();
  }
  const commaIndex = dataUrl.indexOf(',');
  const base64 = (commaIndex >= 0 ? dataUrl.slice(commaIndex + 1) : dataUrl).replace(/\s+/g, '');
  let binary;
  try {
    binary = atob(base64);
  } catch (error) {
    console.error('Conversia datelor √Æn format binar a e»ôuat.', error);
    return new Uint8Array();
  }
  const length = binary.length;
  const bytes = new Uint8Array(length);
  for(let index = 0; index < length; index += 1){
    bytes[index] = binary.charCodeAt(index);
  }
  return bytes;
}

function uint8ArrayToBase64(bytes){
  if(!bytes || typeof bytes.length !== 'number'){
    return '';
  }
  let binary = '';
  const chunk = 0x8000;
  for(let offset = 0; offset < bytes.length; offset += chunk){
    const slice = bytes.subarray(offset, Math.min(offset + chunk, bytes.length));
    binary += String.fromCharCode.apply(null, slice);
  }
  return btoa(binary);
}

function base64ToUint8Array(base64){
  if(!base64 || typeof base64 !== 'string'){
    return new Uint8Array();
  }
  let binary;
  try {
    binary = atob(base64.replace(/\s+/g, ''));
  } catch (error) {
    console.error('Conversia base64 a e»ôuat.', error);
    return new Uint8Array();
  }
  const length = binary.length;
  const bytes = new Uint8Array(length);
  for(let index = 0; index < length; index += 1){
    bytes[index] = binary.charCodeAt(index);
  }
  return bytes;
}

async function renderHtmlPageToCanvas(html, orientation){
  if(typeof html !== 'string' || !window.html2canvas){
    throw new Error('Componenta de randare nu este disponibilƒÉ.');
  }
  const container = document.createElement('div');
  container.className = 'print-render-root';
  container.style.position = 'fixed';
  container.style.left = '-12000px';
  container.style.top = '0';
  container.style.width = '0';
  container.style.height = '0';
  container.style.overflow = 'hidden';
  container.innerHTML = `<style>${PRINT_STYLES}</style>${html}`;
  document.body.appendChild(container);
  try {
    const element = container.querySelector('.print-document');
    if(!element){
      throw new Error('Structura paginii nu a putut fi pregƒÉtitƒÉ.');
    }
    const effectiveOrientation = element.classList.contains('landscape') || orientation === 'landscape'
      ? 'landscape'
      : 'portrait';
    const pixelSize = PDF_PAGE_PIXEL_DIMENSIONS[effectiveOrientation] || PDF_PAGE_PIXEL_DIMENSIONS.portrait;
    element.style.width = `${pixelSize.width}px`;
    element.style.minHeight = `${pixelSize.height}px`;
    element.style.height = `${pixelSize.height}px`;
    if(document.fonts && typeof document.fonts.ready === 'object'){
      try {
        await document.fonts.ready;
      } catch (err) {
        console.warn('Fonturile nu au putut fi verificate √Ænainte de export.', err);
      }
    }
    await new Promise(resolve => requestAnimationFrame(resolve));
    const canvas = await window.html2canvas(element, {
      scale: 2,
      backgroundColor: '#ffffff',
      useCORS: true,
      logging: false,
      windowWidth: pixelSize.width,
      windowHeight: pixelSize.height,
    });
    return { canvas, orientation: effectiveOrientation };
  } finally {
    document.body.removeChild(container);
  }
}

async function appendCanvasToPdf(pdfDoc, canvas, orientation, insertIndex){
  if(!canvas){
    return 0;
  }
  const dims = PDF_PAGE_DIMENSIONS[orientation] || PDF_PAGE_DIMENSIONS.portrait;
  const dataUrl = canvas.toDataURL('image/png');
  const imageBytes = dataUrlToUint8Array(dataUrl);
  const embedded = await pdfDoc.embedPng(imageBytes);
  const insertPosition = typeof insertIndex === 'number' && insertIndex >= 0 && insertIndex <= pdfDoc.getPageCount()
    ? insertIndex
    : null;
  const page = insertPosition !== null
    ? pdfDoc.insertPage(insertPosition, [dims.width, dims.height])
    : pdfDoc.addPage([dims.width, dims.height]);
  const imageWidth = embedded.width;
  const imageHeight = embedded.height;
  const scale = Math.min(dims.width / imageWidth, dims.height / imageHeight);
  const drawWidth = imageWidth * scale;
  const drawHeight = imageHeight * scale;
  page.drawImage(embedded, {
    x: (dims.width - drawWidth) / 2,
    y: (dims.height - drawHeight) / 2,
    width: drawWidth,
    height: drawHeight,
  });
  return 1;
}

async function appendAttachmentSectionToPdf(pdfDoc, section){
  if(!section || !section.attachment){
    return 0;
  }
  const attachment = section.attachment;
  if(!attachment.data){
    return 0;
  }
  const mime = getAttachmentMimeType(attachment);
  try {
    if(mime === 'application/pdf'){
      const bytes = dataUrlToUint8Array(attachment.data);
      const externalDoc = await window.PDFLib.PDFDocument.load(bytes);
      const copiedPages = await pdfDoc.copyPages(externalDoc, externalDoc.getPageIndices());
      copiedPages.forEach(page => pdfDoc.addPage(page));
      return copiedPages.length;
    }
    if(mime && mime.startsWith('image/')){
      const bytes = dataUrlToUint8Array(attachment.data);
      const image = mime === 'image/png' || (attachment.data && attachment.data.startsWith('data:image/png'))
        ? await pdfDoc.embedPng(bytes)
        : await pdfDoc.embedJpg(bytes);
      const orientation = section.orientation === 'landscape' || image.width > image.height
        ? 'landscape'
        : 'portrait';
      const dims = PDF_PAGE_DIMENSIONS[orientation] || PDF_PAGE_DIMENSIONS.portrait;
      const page = pdfDoc.addPage([dims.width, dims.height]);
      const scale = Math.min(dims.width / image.width, dims.height / image.height);
      const drawWidth = image.width * scale;
      const drawHeight = image.height * scale;
      page.drawImage(image, {
        x: (dims.width - drawWidth) / 2,
        y: (dims.height - drawHeight) / 2,
        width: drawWidth,
        height: drawHeight,
      });
      return 1;
    }
  } catch (error) {
    console.error('Nu s-a putut integra automat un ata»ôament √Æn PDF.', error);
  }
  const fallbackHtml = renderPrintPage({
    company: getActiveCompany(),
    orientation: 'portrait',
    heading: escapeHtml(section.label || 'Document anexƒÉ'),
    content: `<p class="section-text">Formatul fi»ôierului ${escapeHtml(attachment.name || 'document')} (${escapeHtml(mime || 'necunoscut')}) nu a putut fi convertit automat. Documentul original rƒÉm√¢ne disponibil √Æn aplica»õie.</p>`,
  });
  const rendered = await renderHtmlPageToCanvas(fallbackHtml, 'portrait');
  await appendCanvasToPdf(pdfDoc, rendered.canvas, rendered.orientation);
  return 1;
}

function wrapTextLines(font, text, fontSize, maxWidth){
  const lines = [];
  if(!font || !maxWidth || maxWidth <= 0){
    return [text || ''];
  }
  const paragraphs = String(text || '').split(/\r?\n/);
  paragraphs.forEach((paragraph, index) => {
    const words = paragraph.split(/\s+/).filter(Boolean);
    if(words.length === 0){
      lines.push('');
    } else {
      let currentLine = '';
      words.forEach(word => {
        const candidate = currentLine ? `${currentLine} ${word}` : word;
        if(font.widthOfTextAtSize(candidate, fontSize) <= maxWidth){
          currentLine = candidate;
        } else {
          if(currentLine){
            lines.push(currentLine);
          }
          if(font.widthOfTextAtSize(word, fontSize) <= maxWidth){
            currentLine = word;
          } else {
            let chunk = '';
            for(const char of word){
              const attempt = chunk ? `${chunk}${char}` : char;
              if(font.widthOfTextAtSize(attempt, fontSize) <= maxWidth){
                chunk = attempt;
              } else {
                if(chunk){
                  lines.push(chunk);
                }
                chunk = char;
              }
            }
            currentLine = chunk;
          }
        }
      });
      if(currentLine){
        lines.push(currentLine);
      }
    }
    if(index < paragraphs.length - 1){
      lines.push('');
    }
  });
  return lines;
}

function triggerPdfDownload(bytes, filename){
  const blob = new Blob([bytes], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  setTimeout(() => {
    try {
      URL.revokeObjectURL(url);
    } catch (err) {
      console.warn('Nu s-a putut elibera URL-ul temporar.', err);
    }
  }, 4000);
}

function openAuthorizationDossierPreviewWindow(){
  try {
    const previewWindow = window.open('', '_blank');
    if(previewWindow){
      previewWindow.document.title = 'Previzualizare dosar PDF';
      previewWindow.document.body.style.margin = '0';
      previewWindow.document.body.style.fontFamily = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      previewWindow.document.body.innerHTML = '<div style="padding:24px;font-size:14px;color:#2b3b63;">Se pregƒÉte»ôte previzualizarea dosarului‚Ä¶</div>';
    }
    return previewWindow;
  } catch (error) {
    console.warn('Nu s-a putut deschide fereastra de previzualizare.', error);
    return null;
  }
}

function renderAuthorizationDossierPreview(previewWindow, bytes, filename){
  if(!previewWindow){
    return false;
  }
  try {
    if(previewWindow.closed){
      return false;
    }
    const blob = new Blob([bytes], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    const doc = previewWindow.document;
    doc.title = filename;
    doc.body.style.margin = '0';
    doc.body.innerHTML = `<embed src="${url}#toolbar=1&navpanes=1&scrollbar=1&view=Fit" type="application/pdf" style="width:100%;height:100vh;" />`;
    try {
      previewWindow.addEventListener('beforeunload', () => {
        try {
          URL.revokeObjectURL(url);
        } catch (cleanupError) {
          console.warn('Nu s-a putut elibera URL-ul previzualizƒÉrii.', cleanupError);
        }
      }, { once: true });
    } catch (listenerError) {
      console.warn('Nu s-a putut ata»ôa handlerul de curƒÉ»õare pentru previzualizare.', listenerError);
      setTimeout(() => {
        try {
          URL.revokeObjectURL(url);
        } catch (cleanupError) {
          console.warn('Nu s-a putut elibera URL-ul previzualizƒÉrii.', cleanupError);
        }
      }, 60000);
    }
    return true;
  } catch (error) {
    console.error('Previzualizarea PDF nu a putut fi afi»ôatƒÉ.', error);
    try {
      previewWindow.document.body.innerHTML = '<div style="padding:24px;font-size:14px;color:#c53030;">Previzualizarea PDF nu a putut fi √ÆncƒÉrcatƒÉ.</div>';
    } catch (updateError) {
      console.warn('Nu s-a putut actualiza fereastra de previzualizare.', updateError);
    }
    return false;
  }
}

async function applyPdfPageNumbers(pdfDoc, options){
  if(!pdfDoc || typeof pdfDoc.getPageCount !== 'function'){
    return;
  }
  const totalPages = pdfDoc.getPageCount();
  if(!totalPages || totalPages <= 0){
    return;
  }
  const startAt = clampAuthorizationStartPage(options && options.startAt !== undefined ? options.startAt : 1);
  const skip = clampAuthorizationPageOffset(options && options.skip !== undefined ? options.skip : 0);
  let font;
  try {
    font = await pdfDoc.embedFont(window.PDFLib.StandardFonts.Helvetica);
  } catch (error) {
    console.warn('Nu s-au putut insera numerele de paginƒÉ.', error);
    return;
  }
  for(let index = 0; index < totalPages; index += 1){
    if(index < skip){
      continue;
    }
    const page = pdfDoc.getPage(index);
    if(!page){
      continue;
    }
    const size = page.getSize();
    const labelIndex = index - skip;
    const label = `Pagina ${startAt + labelIndex}`;
    const fontSize = 10;
    const textWidth = font.widthOfTextAtSize(label, fontSize);
    const marginX = 28;
    const marginY = 24;
    const x = Math.max(marginX, size.width - marginX - textWidth);
    const y = marginY;
    page.drawText(label, {
      x,
      y,
      size: fontSize,
      font,
      color: window.PDFLib.rgb(0.2, 0.2, 0.2),
    });
  }
}

async function composeAuthorizationLetterPdf(dossier, company, phase){
  if(!dossier){
    throw new Error('Dosarul de autorizare nu este disponibil.');
  }
  if(!window.PDFLib || !window.PDFLib.PDFDocument){
    throw new Error('Motorul de generare PDF nu este disponibil.');
  }
  if(!window.html2canvas){
    throw new Error('Componenta de export vizual nu este disponibilƒÉ.');
  }
  const phaseKey = phase === 'final' ? 'final' : 'preliminary';
  const content = buildAuthorizationLetterContent(dossier, { phase: phaseKey });
  const heading = phaseKey === 'final' ? 'AdresƒÉ documenta»õie finalƒÉ' : 'AdresƒÉ documenta»õie preliminarƒÉ';
  const subheading = getStandardLabel(dossier.standard) || '';
  const html = renderPrintPage({
    company,
    orientation: 'portrait',
    heading,
    subheading,
    content,
    showBranding: true,
  });
  const rendered = await renderHtmlPageToCanvas(html, 'portrait');
  const pdfDoc = await window.PDFLib.PDFDocument.create();
  await appendCanvasToPdf(pdfDoc, rendered.canvas, rendered.orientation);
  const bytes = await pdfDoc.save();
  const baseName = slugifyForFilename(computeDossierTitle(dossier) || 'dosar-autorizare', 'dosar-adresa');
  const suffix = phaseKey === 'final' ? '-adresa-documentatie-finala' : '-adresa-documentatie-preliminara';
  const filename = `${baseName}${suffix}.pdf`;
  return { bytes, filename };
}

async function composeAuthorizationDossierPdf(dossier, company, options){
  if(!dossier){
    throw new Error('Dosarul de autorizare nu este disponibil.');
  }
  if(!window.PDFLib || !window.PDFLib.PDFDocument){
    throw new Error('Motorul de generare PDF nu este disponibil.');
  }
  if(!window.html2canvas){
    throw new Error('Componenta de export vizual nu este disponibilƒÉ.');
  }
  ensureDossierMaterialDocuments(dossier);
  ensureDossierCustomSteps(dossier);
  const phase = options && options.phase ? options.phase : 'preliminary';
  const phaseKey = phase === 'final' ? 'final' : 'preliminary';
  const phaseSettings = getAuthorizationDossierPhaseSettings(company, phaseKey);
  const startPage = clampAuthorizationStartPage(options && options.startPage !== undefined ? options.startPage : phaseSettings.startPage);
  const pageOffset = clampAuthorizationPageOffset(options && options.pageOffset !== undefined ? options.pageOffset : phaseSettings.pageOffset);
  const shouldNumber = options && options.pageNumbering !== undefined
    ? options.pageNumbering === true
    : phaseSettings.pageNumbering !== false;
  if(phase === 'final' || phase === 'complete'){
    await ensureWeldingLogPdfAttachments(dossier, company);
  }
  const plan = await buildAuthorizationDossierPagePlan(dossier, company, { phase, startPage, pageOffset });
  const pdfDoc = await window.PDFLib.PDFDocument.create();
  let currentPage = startPage + (pageOffset <= 0 ? 1 : 0);
  for(const detail of plan.details){
    const section = detail.section;
    let pagesAdded = 0;
    if(section){
      if(section.attachment){
        pagesAdded = await appendAttachmentSectionToPdf(pdfDoc, section);
      } else if(Array.isArray(section.attachments) && section.attachments.length > 0){
        for(const attachment of section.attachments){
          if(!attachment || !attachment.data){
            continue;
          }
          const derivedSection = { ...section, attachment };
          delete derivedSection.attachments;
          const appended = await appendAttachmentSectionToPdf(pdfDoc, derivedSection);
          pagesAdded += appended;
        }
      } else {
        const content = typeof section.getContent === 'function' ? section.getContent() : (section.content || '');
        const heading = section.fullBleed ? '' : escapeHtml(section.heading || section.label || '');
        const subheading = section.fullBleed ? '' : (section.subheading ? escapeHtml(section.subheading) : '');
        const pageHtml = renderPrintPage({
          company,
          orientation: section.orientation || 'portrait',
          heading,
          subheading,
          content,
          fullBleed: Boolean(section.fullBleed),
          showBranding: section.showBranding !== undefined ? Boolean(section.showBranding) : true,
        });
        const rendered = await renderHtmlPageToCanvas(pageHtml, section.orientation || 'portrait');
        pagesAdded = await appendCanvasToPdf(pdfDoc, rendered.canvas, rendered.orientation);
      }
    }
    const effectivePages = pagesAdded && pagesAdded > 0 ? pagesAdded : Math.max(1, detail.pageCount || 1);
    detail.startPage = currentPage;
    detail.endPage = currentPage + effectivePages - 1;
    detail.pageCount = effectivePages;
    currentPage = detail.endPage + 1;
  }
  const subtitle = plan.subtitle || computeDossierSubtitle(dossier);
  const opisItems = plan.details.map(detail => {
    const pageLabel = detail.pageCount > 1
      ? `Pagina ${detail.startPage}-${detail.endPage}`
      : `Pagina ${detail.startPage}`;
    return `<li><div class="opis-info"><div class="opis-label"><span>${escapeHtml(detail.label)}</span></div></div><span class="opis-page">${escapeHtml(pageLabel)}</span></li>`;
  }).join('');
  const opisHtml = renderPrintPage({
    company,
    orientation: 'portrait',
    heading: 'OPIS',
    subheading: escapeHtml(subtitle),
    content: `<ol class="opis-list">${opisItems}</ol>`,
    showBranding: true,
  });
  const opisRendered = await renderHtmlPageToCanvas(opisHtml, 'portrait');
  await appendCanvasToPdf(pdfDoc, opisRendered.canvas, opisRendered.orientation, 0);
  if(shouldNumber){
    await applyPdfPageNumbers(pdfDoc, { startAt: startPage, skip: pageOffset });
  }
  const bytes = await pdfDoc.save();
  plan.totalPages = pdfDoc.getPageCount ? pdfDoc.getPageCount() : currentPage - 1;
  plan.pageNumbering = shouldNumber;
  plan.startPage = startPage;
  plan.pageOffset = pageOffset;
  plan.phase = phase;
  const baseName = slugifyForFilename(computeDossierTitle(dossier) || 'dosar-autorizare', 'dosar-autorizare');
  let suffix = '';
  if(phase === 'final'){
    suffix = '-documentatie-finala';
  } else if(phase === 'complete'){
    suffix = '-dosar-complet';
  } else {
    suffix = '-faza-preliminara';
  }
  const filename = `${baseName}${suffix}.pdf`;
  return { bytes, filename, plan };
}

async function runAuthorizationDossierPdfAction(action, options){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('Nu existƒÉ un dosar de autorizare activ.');
    return;
  }
  const phaseOption = options && options.phase ? options.phase : 'preliminary';
  if(action === 'save'){
    const finalPhase = ensureFinalPhase(dossier);
    if(!finalPhase || finalPhase.closed !== true){
      alert('FinalizeazƒÉ documenta»õia finalƒÉ (to»õi pa»ôii marca»õi) √Ænainte de a salva dosarul √Æn arhivƒÉ.');
      return;
    }
    if(dossier.preliminaryClosed !== true){
      alert('√énchide faza preliminarƒÉ √Ænainte de a arhiva dosarul.');
      return;
    }
  }
  const buttonIds = {
    preview: {
      preliminary: 'btn_preview_auth_preliminary_pdf',
      final: 'btn_preview_auth_final_pdf',
    },
    download: {
      preliminary: 'btn_download_auth_preliminary_pdf',
      final: 'btn_download_auth_final_pdf',
    },
    save: 'btn_save_auth_dossier_pdf',
  };
  const triggerMapping = buttonIds[action];
  const phase = action === 'save' ? 'complete' : phaseOption;
  const triggerId = typeof triggerMapping === 'string'
    ? triggerMapping
    : (triggerMapping && triggerMapping[phaseOption]) || null;
  const trigger = triggerId ? document.getElementById(triggerId) : null;
  if(trigger){
    trigger.disabled = true;
    trigger.dataset.loading = 'true';
  }
  let previewWindow = null;
  try {
    if(action === 'preview'){
      previewWindow = openAuthorizationDossierPreviewWindow();
    }
    const { bytes, filename, plan } = await composeAuthorizationDossierPdf(dossier, company, { phase });
    if(action === 'preview'){
      const rendered = renderAuthorizationDossierPreview(previewWindow, bytes, filename);
      if(previewWindow && !rendered){
        try { previewWindow.close(); } catch (closeError) { console.warn('Previzualizarea nu a putut fi √ÆnchisƒÉ.', closeError); }
      }
      return;
    }
    if(action === 'download'){
      triggerPdfDownload(bytes, filename);
      return;
    }
    if(action === 'save'){
      saveAuthorizationDossierArchiveEntry(dossier, plan, bytes, filename);
      const dossiers = ensureAuthorizationDossiers(company);
      const index = dossiers.findIndex(entry => entry && entry.id === dossier.id);
      if(index !== -1){
        dossiers.splice(index, 1);
      }
      if(dossiers.length === 0){
        activeAuthorizationDossierId = null;
      } else if(!dossiers.some(entry => entry && entry.id === activeAuthorizationDossierId)){
        activeAuthorizationDossierId = dossiers[0].id;
      }
      clearAuthorizationDossierForm();
      persistState();
      renderAuthorizationDossierControls();
      alert('Dosarul a fost salvat √Æn arhivƒÉ.');
      return;
    }
  } catch (error) {
    console.error('Generarea dosarului PDF a e»ôuat.', error);
    alert('Nu s-a putut genera dosarul PDF. VerificƒÉ ata»ôamentele »ôi √ÆncearcƒÉ din nou.');
    if(previewWindow){
      try {
        previewWindow.document.body.innerHTML = '<div style="padding:24px;font-size:14px;color:#c53030;">Generarea dosarului a e»ôuat.</div>';
      } catch (updateError) {
        console.warn('Nu s-a putut actualiza fereastra de previzualizare dupƒÉ eroare.', updateError);
      }
    }
  } finally {
    if(trigger){
      trigger.disabled = false;
      delete trigger.dataset.loading;
    }
  }
}

async function previewAuthorizationLetterPdf(phase){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('Nu existƒÉ un dosar de autorizare activ.');
    return;
  }
  const phaseKey = phase === 'final' ? 'final' : 'preliminary';
  const triggerId = phaseKey === 'final' ? 'btn_preview_final_letter_pdf' : 'btn_preview_preliminary_letter_pdf';
  const trigger = document.getElementById(triggerId);
  if(trigger){
    trigger.disabled = true;
    trigger.dataset.loading = 'true';
  }
  let previewWindow = null;
  try {
    previewWindow = openAuthorizationDossierPreviewWindow();
    const { bytes, filename } = await composeAuthorizationLetterPdf(dossier, company, phaseKey);
    const rendered = renderAuthorizationDossierPreview(previewWindow, bytes, filename);
    if(previewWindow && !rendered){
      try { previewWindow.close(); } catch (error) { console.warn('Previzualizarea nu a putut fi √ÆnchisƒÉ.', error); }
    }
  } catch (error) {
    console.error('Previzualizarea adresei a e»ôuat.', error);
    alert('Nu s-a putut genera PDF-ul adresei. VerificƒÉ formatƒÉrile »ôi √ÆncearcƒÉ din nou.');
    if(previewWindow){
      try { previewWindow.close(); } catch (closeError) { console.warn('Fereastra de previzualizare nu a putut fi √ÆnchisƒÉ.', closeError); }
    }
  } finally {
    if(trigger){
      trigger.disabled = false;
      trigger.removeAttribute('data-loading');
    }
  }
}

async function previewPreliminaryAuthorizationDossierPdf(){
  await runAuthorizationDossierPdfAction('preview', { phase: 'preliminary' });
}

async function previewFinalAuthorizationDossierPdf(){
  await runAuthorizationDossierPdfAction('preview', { phase: 'final' });
}

async function downloadPreliminaryAuthorizationDossierPdf(){
  await runAuthorizationDossierPdfAction('download', { phase: 'preliminary' });
}

async function downloadFinalAuthorizationDossierPdf(){
  await runAuthorizationDossierPdfAction('download', { phase: 'final' });
}

async function saveAuthorizationDossierPdf(){
  await runAuthorizationDossierPdfAction('save');
}

function loadAuthorizationDossier(){
  renderAuthorizationDossierControls();
}

function renderAuthorizationDossierTable(dossier, company){
  const tbody = document.getElementById('auth_dossier_table_body');
  const empty = document.getElementById('auth_dossier_table_empty');
  if(!tbody){
    return;
  }
  tbody.innerHTML = '';
  const entries = Array.isArray(dossier && dossier.entries) ? dossier.entries : [];
  if(entries.length === 0){
    if(empty){
      empty.classList.remove('hidden');
    }
    return;
  }
  if(empty){
    empty.classList.add('hidden');
  }
  entries.forEach((entry, index) => {
    const tr = document.createElement('tr');
    const nameHtml = entry && entry.welder_name ? escapeHtml(entry.welder_name) : '<span class="muted">(general)</span>';
    const pansonHtml = entry && entry.panson_code ? `<div class="muted">${escapeHtml(entry.panson_code)}</div>` : '';
    const procedureLabel = resolveProcedureLabel(company, entry && entry.procedure_id);
    const processParts = [];
    if(entry && entry.process){
      processParts.push(`<div>${escapeHtml(entry.process)}</div>`);
    }
    if(procedureLabel){
      processParts.push(`<div class="muted">Procedeu: ${escapeHtml(procedureLabel)}</div>`);
    }
    const processHtml = processParts.length ? processParts.join('') : '<span class="muted">‚Äî</span>';
    const baseParts = [];
    if(entry && entry.base_quality){
      baseParts.push(`<div>${escapeHtml(entry.base_quality)}</div>`);
    }
    if(entry && entry.base_material){
      baseParts.push(`<div class="muted">Material: ${escapeHtml(entry.base_material)}</div>`);
    }
    const baseHtml = baseParts.length ? baseParts.join('') : '<span class="muted">‚Äî</span>';
    const fillerHtml = entry && entry.filler_material ? escapeHtml(entry.filler_material) : '<span class="muted">‚Äî</span>';
    const positionHtml = entry && entry.position ? escapeHtml(entry.position) : '<span class="muted">‚Äî</span>';
    const baseDimHtml = entry && entry.base_dimension ? escapeHtml(entry.base_dimension) : '<span class="muted">‚Äî</span>';
    const diameterHtml = entry && entry.diameter ? escapeHtml(entry.diameter) : '<span class="muted">‚Äî</span>';
    const domainParts = [];
    if(entry && entry.thickness_domain){
      domainParts.push(`<div>Domeniu: ${escapeHtml(entry.thickness_domain)}</div>`);
    }
    if(entry && entry.observation){
      domainParts.push(`<div class="muted">Obs: ${escapeHtml(entry.observation)}</div>`);
    }
    const domainHtml = domainParts.length ? domainParts.join('') : '<span class="muted">‚Äî</span>';
    tr.innerHTML = `
      <td>${index + 1}</td>
      <td>${nameHtml}${pansonHtml}</td>
      <td>${processHtml}</td>
      <td>${baseHtml}</td>
      <td>${fillerHtml}</td>
      <td>${positionHtml}</td>
      <td>${baseDimHtml}</td>
      <td>${diameterHtml}</td>
      <td>${domainHtml}</td>
      <td><button type="button" class="btn ghost small" data-action="remove" data-id="${entry && entry.id ? entry.id : ''}">»òterge</button></td>
    `;
    tbody.appendChild(tr);
  });
  tbody.querySelectorAll('button[data-action="remove"]').forEach(button => {
    button.addEventListener('click', () => {
      const id = button.getAttribute('data-id');
      if(id){
        removeAuthorizationDossierRow(id);
      }
    });
  });
}

function removeAuthorizationDossierRow(entryId){
  if(!entryId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  dossier.entries = (Array.isArray(dossier.entries) ? dossier.entries : []).filter(entry => entry && entry.id !== entryId);
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function renderAuthorizationDossierProcedureDocs(dossier, company){
  const container = document.getElementById('auth_dossier_procedure_docs');
  if(!container){
    return;
  }
  container.innerHTML = '';
  const usedProcedures = new Map();
  (Array.isArray(dossier && dossier.entries) ? dossier.entries : []).forEach(entry => {
    if(entry && entry.procedure_id){
      const procedure = company.qualifications.find(q => q && q.id === entry.procedure_id);
      if(procedure){
        usedProcedures.set(entry.procedure_id, procedure);
      }
    }
  });
  if(usedProcedures.size === 0){
    container.innerHTML = '<p class="muted">Nu existƒÉ procedee asociate r√¢ndurilor din tabel.</p>';
    return;
  }
  usedProcedures.forEach(proc => {
    const item = document.createElement('div');
    item.className = 'doc-item';
    const meta = document.createElement('div');
    meta.className = 'meta';
    const label = resolveProcedureLabel(company, proc.id) || getStandardLabel(proc.standard);
    const notes = [];
    if(proc.certificate_no){
      notes.push(`Certificat: ${escapeHtml(proc.certificate_no)}`);
    }
    meta.innerHTML = `<strong>${escapeHtml(label)}</strong>${notes.length ? `<span>${notes.join(' ‚Ä¢ ')}</span>` : ''}`;
    const actions = document.createElement('div');
    actions.className = 'actions';
    const actionsNode = createAttachmentActionsNode(proc.attachment, { fallbackName: 'procedeu.pdf' });
    if(actionsNode){
      actions.appendChild(actionsNode);
    } else {
      const span = document.createElement('span');
      span.className = 'muted';
      span.textContent = 'FƒÉrƒÉ document ata»ôat';
      actions.appendChild(span);
    }
    item.appendChild(meta);
    item.appendChild(actions);
    container.appendChild(item);
  });
}

function renderAuthorizationDossierWelderDocs(dossier, company){
  const container = document.getElementById('auth_dossier_welder_docs');
  const warning = document.getElementById('auth_dossier_welder_docs_warning');
  if(!container){
    return;
  }
  container.innerHTML = '';
  if(warning){
    warning.classList.add('hidden');
    warning.textContent = '';
  }
  const seen = new Set();
  (Array.isArray(dossier && dossier.entries) ? dossier.entries : []).forEach(entry => {
    if(entry && entry.welder_id){
      seen.add(entry.welder_id);
    }
  });
  if(seen.size === 0){
    container.innerHTML = '<p class="muted">Nu sunt selecta»õi sudori √Æn tabel.</p>';
    return;
  }
  const incomplete = [];
  const welderDocsMap = ensureDossierWelderDocuments(dossier);
  const extensionDocsMap = gatherExtensionAuthorizationDocs(dossier && dossier.entries, company);
  seen.forEach(id => {
    const welder = company.welders.find(w => w.id === id)
      || (company.archivedWelders.find(record => record && record.welder && record.welder.id === id)?.welder);
    if(!welder){
      return;
    }
    const needsAuthorizationAttachment = welderRequiresAuthorizationAttachment(dossier, id);
    const missingDocs = getWelderMissingDocuments(welder);
    if(missingDocs.length){
      const name = welder.name && welder.name.trim() ? welder.name.trim() : 'Sudor';
      incomplete.push(`${name} (${missingDocs.join(', ')})`);
    }
    const item = document.createElement('div');
    item.className = 'doc-item';
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `<strong>${escapeHtml(welder.name || 'Sudor')}</strong>`;
    const actions = document.createElement('div');
    actions.className = 'actions';
    const attachments = welder.bundle && welder.bundle.data
      ? [{ label: 'Documente personale', attachment: welder.bundle }]
      : [
        { label: 'Carte identitate', attachment: welder.id_card },
        { label: 'DiplomƒÉ', attachment: welder.diploma },
        { label: 'Contract', attachment: welder.contract },
        { label: 'Fi»ôƒÉ aptitudini', attachment: welder.aptitude },
      ];
    let hasDocs = false;
    attachments.forEach(record => {
      if(record.attachment && record.attachment.data){
        hasDocs = true;
        const wrapper = document.createElement('div');
        wrapper.className = 'attachment-actions';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'tag-secondary';
        labelSpan.textContent = record.label;
        wrapper.appendChild(labelSpan);
        const node = createAttachmentActionsNode(record.attachment, { fallbackName: `${record.label.toLowerCase().replace(/\s+/g, '_')}.pdf` });
        if(node){
          while(node.firstChild){
            wrapper.appendChild(node.firstChild);
          }
        }
        actions.appendChild(wrapper);
      }
    });
    const extensionDocs = needsAuthorizationAttachment && extensionDocsMap && extensionDocsMap.has(id)
      ? extensionDocsMap.get(id)
      : [];
    if(extensionDocs && extensionDocs.length){
      extensionDocs.forEach(qualification => {
        if(!qualification || !qualification.attachment || !qualification.attachment.data){
          return;
        }
        hasDocs = true;
        const wrapper = document.createElement('div');
        wrapper.className = 'attachment-actions';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'tag-secondary';
        const standardLabel = getStandardLabel(qualification.standard);
        labelSpan.textContent = standardLabel
          ? `Autoriza»õie existentƒÉ ¬∑ ${standardLabel}`
          : 'Autoriza»õie existentƒÉ';
        wrapper.appendChild(labelSpan);
        const node = createAttachmentActionsNode(qualification.attachment, { fallbackName: qualification.attachment.name || 'autorizatie.pdf' });
        if(node){
          while(node.firstChild){
            wrapper.appendChild(node.firstChild);
          }
        }
        actions.appendChild(wrapper);
      });
    }
    const manualDocs = Array.isArray(welderDocsMap && welderDocsMap[String(id)])
      ? welderDocsMap[String(id)]
      : [];
    manualDocs.forEach(doc => {
      if(!doc || !doc.data){
        return;
      }
      hasDocs = true;
      const wrapper = document.createElement('div');
      wrapper.className = 'attachment-actions';
      const labelSpan = document.createElement('span');
      labelSpan.className = 'tag-secondary';
      labelSpan.textContent = 'Autoriza»õie ata»ôatƒÉ √Æn dosar';
      wrapper.appendChild(labelSpan);
      const node = createAttachmentActionsNode(doc, { fallbackName: doc.name || 'autorizatie.pdf' });
      if(node){
        while(node.firstChild){
          wrapper.appendChild(node.firstChild);
        }
      }
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'btn ghost small';
      removeBtn.textContent = '»òterge';
      removeBtn.addEventListener('click', () => removeAuthorizationDossierWelderDoc(id, doc.id));
      wrapper.appendChild(removeBtn);
      if(!needsAuthorizationAttachment){
        const hint = document.createElement('span');
        hint.className = 'muted';
        hint.textContent = 'NeutilizatƒÉ pentru autorizare/omologare';
        wrapper.appendChild(hint);
      }
      actions.appendChild(wrapper);
    });
    if(!hasDocs){
      const span = document.createElement('span');
      span.className = 'muted';
      span.textContent = 'Nu existƒÉ documente ata»ôate';
      actions.appendChild(span);
    }
    if(needsAuthorizationAttachment){
      const uploadWrapper = document.createElement('div');
      uploadWrapper.className = 'attachment-actions';
      const uploadBtn = document.createElement('button');
      uploadBtn.type = 'button';
      uploadBtn.className = 'btn ghost small';
      setButtonTextWithIcon(uploadBtn, hasDocs ? 'AdaugƒÉ document' : 'Ata»ôeazƒÉ autoriza»õie', 'attach');
      const uploadInput = document.createElement('input');
      uploadInput.type = 'file';
      uploadInput.accept = 'application/pdf,image/*';
      uploadInput.style.display = 'none';
      uploadBtn.addEventListener('click', () => uploadInput.click());
      uploadInput.addEventListener('change', () => {
        if(uploadInput.files && uploadInput.files[0]){
          addAuthorizationDossierWelderDoc(id, uploadInput.files[0]);
        }
        uploadInput.value = '';
      });
      uploadWrapper.appendChild(uploadBtn);
      uploadWrapper.appendChild(uploadInput);
      actions.appendChild(uploadWrapper);
    } else if(manualDocs.length === 0 && (!extensionDocs || extensionDocs.length === 0)){
      const info = document.createElement('span');
      info.className = 'muted';
      info.textContent = 'Autoriza»õia nu este necesarƒÉ pentru acest sudor.';
      actions.appendChild(info);
    }
    item.appendChild(meta);
    item.appendChild(actions);
    container.appendChild(item);
  });
  if(incomplete.length && warning){
    warning.textContent = `Aten»õie: lipsesc documentele obligatorii √Æn profilul sudorului pentru ${incomplete.join('; ')}.`;
    warning.classList.remove('hidden');
  }
}

function getUniqueMaterials(entries, key){
  const set = new Set();
  (Array.isArray(entries) ? entries : []).forEach(entry => {
    const value = entry && entry[key] ? String(entry[key]).trim() : '';
    if(value){
      set.add(value);
    }
  });
  return Array.from(set);
}

function renderAuthorizationDossierMaterialSections(dossier){
  ensureDossierMaterialDocuments(dossier);
  const baseMaterials = getUniqueMaterials(dossier.entries, 'base_quality');
  const fillerMaterials = getUniqueMaterials(dossier.entries, 'filler_material');
  const baseSelect = document.getElementById('auth_dossier_base_material_select');
  if(baseSelect){
    const previous = baseSelect.value;
    baseSelect.innerHTML = '<option value="">Alege material de bazƒÉ</option>';
    baseMaterials.forEach(material => {
      const option = document.createElement('option');
      option.value = material;
      option.textContent = material;
      baseSelect.appendChild(option);
    });
    if(previous && baseMaterials.includes(previous)){
      baseSelect.value = previous;
    } else {
      baseSelect.value = '';
    }
    baseSelect.disabled = baseMaterials.length === 0;
  }
  const fillerSelect = document.getElementById('auth_dossier_filler_material_select');
  if(fillerSelect){
    const previous = fillerSelect.value;
    fillerSelect.innerHTML = '<option value="">Alege material de adaos</option>';
    fillerMaterials.forEach(material => {
      const option = document.createElement('option');
      option.value = material;
      option.textContent = material;
      fillerSelect.appendChild(option);
    });
    if(previous && fillerMaterials.includes(previous)){
      fillerSelect.value = previous;
    } else {
      fillerSelect.value = '';
    }
    fillerSelect.disabled = fillerMaterials.length === 0;
  }
  const baseDocsContainer = document.getElementById('auth_dossier_base_material_docs');
  renderAuthorizationDossierMaterialList('base', dossier.materialDocuments.base, baseDocsContainer);
  const fillerDocsContainer = document.getElementById('auth_dossier_filler_material_docs');
  renderAuthorizationDossierMaterialList('filler', dossier.materialDocuments.filler, fillerDocsContainer);
  const baseFileInput = document.getElementById('auth_dossier_base_material_file');
  if(baseFileInput){
    baseFileInput.value = '';
  }
  const fillerFileInput = document.getElementById('auth_dossier_filler_material_file');
  if(fillerFileInput){
    fillerFileInput.value = '';
  }
}

function renderAuthorizationDossierCustomSteps(dossier){
  const list = document.getElementById('auth_custom_steps_list');
  const empty = document.getElementById('auth_custom_steps_empty');
  if(!list || !empty){
    return;
  }
  list.innerHTML = '';
  const steps = ensureDossierCustomSteps(dossier);
  if(!steps || steps.length === 0){
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');
  steps.forEach(step => {
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-step';
    wrapper.setAttribute('data-step-id', step.id);
    if(step && step.include === false){
      wrapper.classList.add('step-excluded');
    }

    const header = document.createElement('div');
    header.className = 'custom-step-header';

    const titleWrap = document.createElement('div');
    titleWrap.className = 'custom-step-titlewrap';
    const title = document.createElement('h5');
    title.textContent = step && step.name ? step.name : 'Pas suplimentar';
    titleWrap.appendChild(title);
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = step && step.opis ? `OPIS: ${step.opis}` : 'FƒÉrƒÉ text pentru OPIS';
    titleWrap.appendChild(meta);

    const controls = document.createElement('div');
    controls.className = 'custom-step-controls';
    const toggleContainer = document.createElement('div');
    toggleContainer.className = 'step-visibility';
    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'checkbox-field';
    const toggleInput = document.createElement('input');
    toggleInput.type = 'checkbox';
    toggleInput.checked = step && step.include === false ? false : true;
    toggleInput.setAttribute('data-step-include-toggle', step.id);
    toggleLabel.appendChild(toggleInput);
    toggleLabel.appendChild(document.createTextNode('Include √Æn OPIS »ôi PDF'));
    toggleContainer.appendChild(toggleLabel);
    controls.appendChild(toggleContainer);

    const actions = document.createElement('div');
    actions.className = 'custom-step-actions';

    const uploadTrigger = document.createElement('button');
    uploadTrigger.type = 'button';
    uploadTrigger.className = 'btn ghost small';
    setButtonTextWithIcon(uploadTrigger, 'Ata»ôeazƒÉ document', 'attach');
    uploadTrigger.setAttribute('data-step-upload-trigger', step.id);
    actions.appendChild(uploadTrigger);

    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'btn ghost small';
    deleteBtn.textContent = '»òterge pasul';
    deleteBtn.setAttribute('data-step-delete', step.id);
    actions.appendChild(deleteBtn);

    controls.appendChild(actions);

    header.appendChild(titleWrap);
    header.appendChild(controls);

    const uploadInput = document.createElement('input');
    uploadInput.type = 'file';
    uploadInput.accept = 'application/pdf,image/*';
    uploadInput.setAttribute('data-step-upload-input', step.id);
    uploadInput.style.display = 'none';

    const docsContainer = document.createElement('div');
    docsContainer.className = 'dossier-doc-list';
    const attachments = Array.isArray(step.attachments) ? step.attachments : [];
    if(attachments.length === 0){
      const emptyDoc = document.createElement('p');
      emptyDoc.className = 'muted';
      emptyDoc.textContent = 'Nu existƒÉ documente ata»ôate pentru acest pas.';
      docsContainer.appendChild(emptyDoc);
    } else {
      attachments.forEach(attachment => {
        if(!attachment || !attachment.data){
          return;
        }
        const item = document.createElement('div');
        item.className = 'doc-item';
        item.setAttribute('data-attachment-id', attachment.id || '');

        const metaBlock = document.createElement('div');
        metaBlock.className = 'meta';
        metaBlock.innerHTML = `<strong>${escapeHtml(attachment.name || 'Document')}</strong>`;
        item.appendChild(metaBlock);

        const actionsBlock = document.createElement('div');
        actionsBlock.className = 'actions';
        const viewNode = createAttachmentActionsNode(attachment, { fallbackName: attachment.name || 'document.pdf' });
        if(viewNode){
          actionsBlock.appendChild(viewNode);
        }
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn ghost small';
        removeBtn.textContent = 'EliminƒÉ';
        removeBtn.setAttribute('data-step-remove-attachment', attachment.id || '');
        removeBtn.setAttribute('data-step-id', step.id);
        actionsBlock.appendChild(removeBtn);
        item.appendChild(actionsBlock);
        docsContainer.appendChild(item);
      });
    }

    wrapper.appendChild(header);
    wrapper.appendChild(uploadInput);
    wrapper.appendChild(docsContainer);
    list.appendChild(wrapper);
  });
}

function renderFinalPhaseCustomSteps(dossier){
  const list = document.getElementById('auth_final_custom_steps_list');
  const empty = document.getElementById('auth_final_custom_steps_empty');
  if(!list || !empty){
    return;
  }
  list.innerHTML = '';
  const steps = ensureFinalPhaseCustomSteps(dossier);
  if(!steps || steps.length === 0){
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');
  steps.forEach(step => {
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-step';
    wrapper.setAttribute('data-step-id', step.id);
    if(step && step.include === false){
      wrapper.classList.add('step-excluded');
    }

    const header = document.createElement('div');
    header.className = 'custom-step-header';

    const titleWrap = document.createElement('div');
    titleWrap.className = 'custom-step-titlewrap';
    const title = document.createElement('h5');
    title.textContent = step && step.name ? step.name : 'Pas final';
    titleWrap.appendChild(title);
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = step && step.opis ? `OPIS: ${step.opis}` : 'FƒÉrƒÉ text pentru OPIS';
    titleWrap.appendChild(meta);

    const controls = document.createElement('div');
    controls.className = 'custom-step-controls';
    const toggleContainer = document.createElement('div');
    toggleContainer.className = 'step-visibility';
    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'checkbox-field';
    const toggleInput = document.createElement('input');
    toggleInput.type = 'checkbox';
    toggleInput.checked = step && step.include === false ? false : true;
    toggleInput.setAttribute('data-final-step-include-toggle', step.id);
    toggleLabel.appendChild(toggleInput);
    toggleLabel.appendChild(document.createTextNode('Include √Æn OPIS »ôi PDF'));
    toggleContainer.appendChild(toggleLabel);
    controls.appendChild(toggleContainer);

    const actions = document.createElement('div');
    actions.className = 'custom-step-actions';

    const uploadTrigger = document.createElement('button');
    uploadTrigger.type = 'button';
    uploadTrigger.className = 'btn ghost small';
    setButtonTextWithIcon(uploadTrigger, 'Ata»ôeazƒÉ document', 'attach');
    uploadTrigger.setAttribute('data-final-step-upload-trigger', step.id);
    actions.appendChild(uploadTrigger);

    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'btn ghost small';
    deleteBtn.textContent = '»òterge pasul';
    deleteBtn.setAttribute('data-final-step-delete', step.id);
    actions.appendChild(deleteBtn);

    controls.appendChild(actions);

    header.appendChild(titleWrap);
    header.appendChild(controls);

    const uploadInput = document.createElement('input');
    uploadInput.type = 'file';
    uploadInput.accept = 'application/pdf,image/*';
    uploadInput.setAttribute('data-final-step-upload-input', step.id);
    uploadInput.style.display = 'none';

    const docsContainer = document.createElement('div');
    docsContainer.className = 'dossier-doc-list';
    const attachments = Array.isArray(step.attachments) ? step.attachments : [];
    if(attachments.length === 0){
      const emptyDoc = document.createElement('p');
      emptyDoc.className = 'muted';
      emptyDoc.textContent = 'Nu existƒÉ documente ata»ôate pentru acest pas.';
      docsContainer.appendChild(emptyDoc);
    } else {
      attachments.forEach(attachment => {
        if(!attachment || !attachment.data){
          return;
        }
        const item = document.createElement('div');
        item.className = 'doc-item';
        item.setAttribute('data-attachment-id', attachment.id || '');

        const metaBlock = document.createElement('div');
        metaBlock.className = 'meta';
        metaBlock.innerHTML = `<strong>${escapeHtml(attachment.name || 'Document')}</strong>`;
        item.appendChild(metaBlock);

        const actionsBlock = document.createElement('div');
        actionsBlock.className = 'actions';
        const viewNode = createAttachmentActionsNode(attachment, { fallbackName: attachment.name || 'document.pdf' });
        if(viewNode){
          actionsBlock.appendChild(viewNode);
        }
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn ghost small';
        removeBtn.textContent = 'EliminƒÉ';
        removeBtn.setAttribute('data-final-step-remove-attachment', attachment.id || '');
        removeBtn.setAttribute('data-final-step-id', step.id);
        actionsBlock.appendChild(removeBtn);
        item.appendChild(actionsBlock);
        docsContainer.appendChild(item);
      });
    }

    wrapper.appendChild(header);
    wrapper.appendChild(uploadInput);
    wrapper.appendChild(docsContainer);
    list.appendChild(wrapper);
  });
}

function handleAddCustomStep(){
  const nameInput = document.getElementById('auth_custom_step_name');
  const opisInput = document.getElementById('auth_custom_step_opis');
  const name = nameInput && typeof nameInput.value === 'string' ? nameInput.value.trim() : '';
  const opis = opisInput && typeof opisInput.value === 'string' ? opisInput.value.trim() : '';
  if(!name){
    alert('Introdu denumirea pasului personalizat.');
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('Nu existƒÉ un dosar activ pentru a adƒÉuga pasul.');
    return;
  }
  const steps = ensureDossierCustomSteps(dossier);
  steps.push({
    id: generateDocumentId('custep'),
    name,
    opis,
    attachments: [],
    include: true,
  });
  if(nameInput){
    nameInput.value = '';
  }
  if(opisInput){
    opisInput.value = '';
  }
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

async function handleCustomStepFileChange(event){
  const input = event.target;
  if(!input){
    return;
  }
  if(input.hasAttribute('data-step-include-toggle')){
    updateCustomStepInclude(input.getAttribute('data-step-include-toggle'), input.checked);
    return;
  }
  if(input.type !== 'file'){
    return;
  }
  const stepId = input.getAttribute('data-step-upload-input');
  if(!stepId || !input.files || !input.files[0]){
    return;
  }
  const file = input.files[0];
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    input.value = '';
    return;
  }
  const steps = ensureDossierCustomSteps(dossier);
  const step = steps.find(entry => entry && entry.id === stepId);
  if(!step){
    input.value = '';
    return;
  }
  try {
    const data = await readFileAsDataURL(file);
    const attachment = normalizeDossierItem({ name: file.name, data, type: file.type }, file.name || 'document_personalizat');
    step.attachments = Array.isArray(step.attachments) ? step.attachments : [];
    step.attachments.push(attachment);
    persistState();
    renderAuthorizationDossierDetail(dossier);
  } catch (error) {
    console.error('Documentul nu a putut fi ata»ôat la pasul personalizat.', error);
    alert('Documentul nu a putut fi ata»ôat. √éncearcƒÉ din nou.');
  } finally {
    input.value = '';
  }
}

function handleCustomStepClick(event){
  const uploadTrigger = event.target.closest('[data-step-upload-trigger]');
  if(uploadTrigger){
    const stepId = uploadTrigger.getAttribute('data-step-upload-trigger');
    const input = document.querySelector(`input[data-step-upload-input="${stepId}"]`);
    if(input){
      input.click();
    }
    return;
  }
  const removeAttachment = event.target.closest('[data-step-remove-attachment]');
  if(removeAttachment){
    const stepId = removeAttachment.getAttribute('data-step-id');
    const attachmentId = removeAttachment.getAttribute('data-step-remove-attachment');
    removeCustomStepAttachment(stepId, attachmentId);
    return;
  }
  const deleteStep = event.target.closest('[data-step-delete]');
  if(deleteStep){
    const stepId = deleteStep.getAttribute('data-step-delete');
    if(stepId && confirm('»òtergi acest pas personalizat?')){
      removeCustomStep(stepId);
    }
  }
}

function removeCustomStep(stepId){
  if(!stepId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const steps = ensureDossierCustomSteps(dossier);
  const index = steps.findIndex(step => step && step.id === stepId);
  if(index === -1){
    return;
  }
  steps.splice(index, 1);
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function updateCustomStepInclude(stepId, include){
  if(!stepId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const steps = ensureDossierCustomSteps(dossier);
  const step = steps.find(entry => entry && entry.id === stepId);
  if(!step){
    return;
  }
  const next = include === true;
  const current = step.include === false ? false : true;
  if(current === next){
    step.include = next;
    updateAuthorizationStepVisibilityControls(dossier);
    return;
  }
  step.include = next;
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function removeCustomStepAttachment(stepId, attachmentId){
  if(!stepId || !attachmentId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const steps = ensureDossierCustomSteps(dossier);
  const step = steps.find(entry => entry && entry.id === stepId);
  if(!step || !Array.isArray(step.attachments)){
    return;
  }
  step.attachments = step.attachments.filter(attachment => attachment && attachment.id !== attachmentId);
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function handleAddFinalCustomStep(){
  const nameInput = document.getElementById('auth_final_custom_step_name');
  const opisInput = document.getElementById('auth_final_custom_step_opis');
  const name = nameInput && typeof nameInput.value === 'string' ? nameInput.value.trim() : '';
  const opis = opisInput && typeof opisInput.value === 'string' ? opisInput.value.trim() : '';
  if(!name){
    alert('Introdu denumirea pasului final.');
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    alert('Nu existƒÉ un dosar activ.');
    return;
  }
  const steps = ensureFinalPhaseCustomSteps(dossier);
  steps.push({
    id: generateDocumentId('fcustep'),
    name,
    opis,
    attachments: [],
    include: true,
  });
  if(nameInput){
    nameInput.value = '';
  }
  if(opisInput){
    opisInput.value = '';
  }
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

async function handleFinalCustomStepFileChange(event){
  const input = event.target;
  if(!input){
    return;
  }
  if(input.hasAttribute('data-final-step-include-toggle')){
    updateFinalCustomStepInclude(input.getAttribute('data-final-step-include-toggle'), input.checked);
    return;
  }
  if(input.type !== 'file'){
    return;
  }
  const stepId = input.getAttribute('data-final-step-upload-input');
  if(!stepId || !input.files || !input.files[0]){
    return;
  }
  const file = input.files[0];
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    input.value = '';
    return;
  }
  const steps = ensureFinalPhaseCustomSteps(dossier);
  const step = steps.find(entry => entry && entry.id === stepId);
  if(!step){
    input.value = '';
    return;
  }
  try {
    const data = await readFileAsDataURL(file);
    const attachment = normalizeDossierItem({ name: file.name, data, type: file.type }, file.name || 'document_final');
    step.attachments = Array.isArray(step.attachments) ? step.attachments : [];
    step.attachments.push(attachment);
    persistState();
    renderAuthorizationDossierDetail(dossier);
  } catch (error) {
    console.error('Documentul nu a putut fi ata»ôat la pasul final.', error);
    alert('Documentul nu a putut fi ata»ôat. √éncearcƒÉ din nou.');
  } finally {
    input.value = '';
  }
}

function handleFinalCustomStepClick(event){
  const uploadTrigger = event.target.closest('[data-final-step-upload-trigger]');
  if(uploadTrigger){
    const stepId = uploadTrigger.getAttribute('data-final-step-upload-trigger');
    const input = document.querySelector(`input[data-final-step-upload-input="${stepId}"]`);
    if(input){
      input.click();
    }
    return;
  }
  const removeAttachment = event.target.closest('[data-final-step-remove-attachment]');
  if(removeAttachment){
    const stepId = removeAttachment.getAttribute('data-final-step-id');
    const attachmentId = removeAttachment.getAttribute('data-final-step-remove-attachment');
    removeFinalCustomStepAttachment(stepId, attachmentId);
    return;
  }
  const deleteBtn = event.target.closest('[data-final-step-delete]');
  if(deleteBtn){
    const stepId = deleteBtn.getAttribute('data-final-step-delete');
    if(stepId && confirm('»òtergi acest pas final personalizat?')){
      removeFinalCustomStep(stepId);
    }
  }
}

function removeFinalCustomStep(stepId){
  if(!stepId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const steps = ensureFinalPhaseCustomSteps(dossier);
  const index = steps.findIndex(step => step && step.id === stepId);
  if(index === -1){
    return;
  }
  steps.splice(index, 1);
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function updateFinalCustomStepInclude(stepId, include){
  if(!stepId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const steps = ensureFinalPhaseCustomSteps(dossier);
  const step = steps.find(entry => entry && entry.id === stepId);
  if(!step){
    return;
  }
  const next = include === true;
  const current = step.include === false ? false : true;
  if(current === next){
    step.include = next;
    updateAuthorizationStepVisibilityControls(dossier);
    return;
  }
  step.include = next;
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function removeFinalCustomStepAttachment(stepId, attachmentId){
  if(!stepId || !attachmentId){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const steps = ensureFinalPhaseCustomSteps(dossier);
  const step = steps.find(entry => entry && entry.id === stepId);
  if(!step){
    return;
  }
  step.attachments = Array.isArray(step.attachments) ? step.attachments : [];
  const index = step.attachments.findIndex(attachment => attachment && attachment.id === attachmentId);
  if(index === -1){
    return;
  }
  step.attachments.splice(index, 1);
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function renderAuthorizationDossierMaterialList(type, documentsMap, container){
  if(!container){
    return;
  }
  container.innerHTML = '';
  const keys = Object.keys(documentsMap || {});
  if(keys.length === 0){
    container.innerHTML = '<p class="muted">Nu existƒÉ documente ata»ôate.</p>';
    return;
  }
  keys.forEach(material => {
    const docs = documentsMap[material] || [];
    if(docs.length === 0){
      return;
    }
    const item = document.createElement('div');
    item.className = 'doc-item';
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `<strong>${escapeHtml(material)}</strong><span>${type === 'base' ? 'Material de bazƒÉ' : 'Material de adaos'}</span>`;
    const actions = document.createElement('div');
    actions.className = 'actions';
    docs.forEach(doc => {
      const row = document.createElement('div');
      row.className = 'attachment-actions';
      const labelSpan = document.createElement('span');
      labelSpan.className = 'tag-secondary';
      labelSpan.textContent = doc.name || 'document';
      row.appendChild(labelSpan);
      const node = createAttachmentActionsNode(doc, { fallbackName: doc.name || 'document.pdf' });
      if(node){
        while(node.firstChild){
          row.appendChild(node.firstChild);
        }
      } else {
        const span = document.createElement('span');
        span.className = 'muted';
        span.textContent = 'Document indisponibil';
        row.appendChild(span);
      }
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'btn ghost small';
      removeBtn.textContent = '»òterge';
      removeBtn.addEventListener('click', () => removeAuthorizationDossierMaterialDoc(type, material, doc.id));
      row.appendChild(removeBtn);
      actions.appendChild(row);
    });
    item.appendChild(meta);
    item.appendChild(actions);
    container.appendChild(item);
  });
}

function ensureDossierMaterialDocuments(dossier){
  if(!dossier.materialDocuments || typeof dossier.materialDocuments !== 'object'){
    dossier.materialDocuments = { base: {}, filler: {} };
  }
  if(!dossier.materialDocuments.base || typeof dossier.materialDocuments.base !== 'object'){
    dossier.materialDocuments.base = {};
  }
  if(!dossier.materialDocuments.filler || typeof dossier.materialDocuments.filler !== 'object'){
    dossier.materialDocuments.filler = {};
  }
  return dossier.materialDocuments;
}

function ensureDossierWelderDocuments(dossier){
  if(!dossier.welderDocuments || typeof dossier.welderDocuments !== 'object'){
    dossier.welderDocuments = {};
  }
  return dossier.welderDocuments;
}

function ensureDossierLetterStyle(dossier){
  if(dossier){
    dossier.letter = normalizeLetterInput(
      dossier.letter,
      dossier.standard || DEFAULT_AUTH_STANDARD,
      'preliminary'
    );
  }
  const style = normalizeLetterStyle(dossier && dossier.letterStyle);
  dossier.letterStyle = style;
  return dossier.letterStyle;
}

function ensureDossierCustomSteps(dossier){
  if(!Array.isArray(dossier.customSteps)){
    dossier.customSteps = [];
  }
  dossier.customSteps = dossier.customSteps.filter(Boolean);
  dossier.customSteps.forEach(step => {
    if(step){
      step.include = step.include === false ? false : true;
    }
  });
  return dossier.customSteps;
}

function ensureFinalPhase(dossier){
  if(!dossier.finalPhase || typeof dossier.finalPhase !== 'object'){
    dossier.finalPhase = createDefaultFinalPhase();
  }
  if(typeof dossier.finalPhase.address !== 'string'){
    dossier.finalPhase.address = '';
  }
  dossier.finalPhase.address = normalizeLetterInput(
    dossier.finalPhase.address,
    dossier.standard || DEFAULT_AUTH_STANDARD,
    'final'
  );
  dossier.finalPhase.closed = dossier.finalPhase.closed === true;
  if(!dossier.finalPhase.welderDocuments || typeof dossier.finalPhase.welderDocuments !== 'object'){
    dossier.finalPhase.welderDocuments = {
      examReports: {},
      writtenWorks: {},
      ndtBulletins: {},
      destructiveReports: {},
    };
  } else {
    FINAL_WELDER_DOC_CONFIG.forEach(config => {
      const key = config.key;
      if(!dossier.finalPhase.welderDocuments[key] || typeof dossier.finalPhase.welderDocuments[key] !== 'object'){
        dossier.finalPhase.welderDocuments[key] = {};
      }
    });
  }
  FINAL_GENERAL_DOC_CONFIG.forEach(config => {
    if(!Array.isArray(dossier.finalPhase[config.key])){
      dossier.finalPhase[config.key] = [];
    }
  });
  if(!Array.isArray(dossier.finalPhase.customSteps)){
    dossier.finalPhase.customSteps = [];
  }
  ensureFinalPhaseLetterStyle(dossier);
  return dossier.finalPhase;
}

function ensureFinalPhaseLetterStyle(dossier){
  const finalPhase = dossier.finalPhase && typeof dossier.finalPhase === 'object'
    ? dossier.finalPhase
    : createDefaultFinalPhase();
  if(!dossier.finalPhase || typeof dossier.finalPhase !== 'object'){
    dossier.finalPhase = finalPhase;
  }
  finalPhase.letterStyle = normalizeLetterStyle(finalPhase.letterStyle);
  return finalPhase.letterStyle;
}

function ensureFinalPhaseWelderDocs(dossier, key){
  const finalPhase = ensureFinalPhase(dossier);
  if(!finalPhase.welderDocuments || typeof finalPhase.welderDocuments !== 'object'){
    finalPhase.welderDocuments = {
      examReports: {},
      writtenWorks: {},
      ndtBulletins: {},
      destructiveReports: {},
    };
  }
  if(!finalPhase.welderDocuments[key] || typeof finalPhase.welderDocuments[key] !== 'object'){
    finalPhase.welderDocuments[key] = {};
  }
  return finalPhase.welderDocuments[key];
}

function ensureFinalPhaseGeneralList(dossier, key){
  const finalPhase = ensureFinalPhase(dossier);
  if(!Array.isArray(finalPhase[key])){
    finalPhase[key] = [];
  }
  return finalPhase[key];
}

function ensureFinalPhaseCustomSteps(dossier){
  const finalPhase = ensureFinalPhase(dossier);
  if(!Array.isArray(finalPhase.customSteps)){
    finalPhase.customSteps = [];
  }
  finalPhase.customSteps = finalPhase.customSteps.filter(Boolean);
  finalPhase.customSteps.forEach(step => {
    if(step){
      step.include = step.include === false ? false : true;
    }
  });
  return finalPhase.customSteps;
}

function getFinalPhaseWelderRecords(dossier, company){
  if(!dossier || !company){
    return [];
  }
  return gatherWelderRecords(dossier.entries, company);
}

function renderFinalPhaseWelderSection(type, dossier, company){
  const config = getFinalWelderConfigByKey(type);
  if(!config){
    return;
  }
  const container = document.getElementById(config.containerId);
  if(!container){
    return;
  }
  container.innerHTML = '';
  const records = getFinalPhaseWelderRecords(dossier, company);
  if(records.length === 0){
    container.innerHTML = '<p class="muted">Nu existƒÉ sudori √Æn tabelul dosarului.</p>';
    return;
  }
  const docsMap = ensureFinalPhaseWelderDocs(dossier, type);
  records.forEach(record => {
    if(!record || !record.welder){
      return;
    }
    const welder = record.welder;
    const welderId = welder.id;
    if(!Number.isInteger(welderId)){
      return;
    }
    const key = String(welderId);
    const docs = Array.isArray(docsMap[key]) ? docsMap[key] : [];
    const item = document.createElement('div');
    item.className = 'doc-item';

    const meta = document.createElement('div');
    meta.className = 'meta';
    const name = document.createElement('strong');
    name.textContent = welder.name || 'Sudor';
    meta.appendChild(name);
    const code = welder.code || (welder.panson_code || '');
    if(code){
      const codeSpan = document.createElement('span');
      codeSpan.className = 'muted';
      codeSpan.textContent = code;
      meta.appendChild(codeSpan);
    }
    const typeTag = document.createElement('span');
    typeTag.className = 'tag-secondary';
    typeTag.textContent = config.tagLabel || 'Document';
    meta.appendChild(typeTag);

    const actions = document.createElement('div');
    actions.className = 'actions';
    if(docs.length === 0){
      const empty = document.createElement('span');
      empty.className = 'muted';
      empty.textContent = config.emptyMessage || 'Nu existƒÉ documente ata»ôate.';
      actions.appendChild(empty);
    } else {
      docs.forEach(doc => {
        if(!doc || !doc.data){
          return;
        }
        const row = document.createElement('div');
        row.className = 'attachment-actions';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'tag-secondary';
        labelSpan.textContent = doc.name || config.tagLabel || 'Document';
        row.appendChild(labelSpan);
        const node = createAttachmentActionsNode(doc, { fallbackName: doc.name || 'document.pdf' });
        if(node){
          while(node.firstChild){
            row.appendChild(node.firstChild);
          }
        }
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn ghost small';
        removeBtn.textContent = '»òterge';
        removeBtn.addEventListener('click', () => removeFinalPhaseWelderDoc(type, welderId, doc.id));
        row.appendChild(removeBtn);
        actions.appendChild(row);
      });
    }

    const uploadWrapper = document.createElement('div');
    uploadWrapper.className = 'attachment-actions';
    const uploadBtn = document.createElement('button');
    uploadBtn.type = 'button';
    uploadBtn.className = 'btn ghost small';
    setButtonTextWithIcon(uploadBtn, config.uploadLabel || 'Ata»ôeazƒÉ document', 'attach');
    const uploadInput = document.createElement('input');
    uploadInput.type = 'file';
    uploadInput.accept = 'application/pdf,image/*';
    uploadInput.style.display = 'none';
    uploadBtn.addEventListener('click', () => uploadInput.click());
    uploadInput.addEventListener('change', () => {
      if(uploadInput.files && uploadInput.files[0]){
        addFinalPhaseWelderDoc(type, welderId, uploadInput.files[0]);
      }
      uploadInput.value = '';
    });
    uploadWrapper.appendChild(uploadBtn);
    uploadWrapper.appendChild(uploadInput);
    actions.appendChild(uploadWrapper);

    if(type === 'examReports'){
      const needsLog = welderRequiresWeldingLog(dossier, welderId, welder, company);
      if(needsLog){
        const log = ensureWelderWeldingLog(welder);
        const hasEntries = Array.isArray(log && log.entries) && log.entries.length > 0;
        const logRow = document.createElement('div');
        logRow.className = 'attachment-actions';
        const label = document.createElement('span');
        label.className = hasEntries ? 'tag-secondary' : 'tag';
        label.textContent = hasEntries
          ? 'Fi»ôa de eviden»õƒÉ este completatƒÉ'
          : 'Fi»ôa de eviden»õƒÉ lipse»ôte';
        logRow.appendChild(label);
        if(!hasEntries){
          const hint = document.createElement('span');
          hint.className = 'muted';
          hint.textContent = 'CompleteazƒÉ fi»ôa √Æn profilul sudorului pentru prelungirea ASME.';
          logRow.appendChild(hint);
        }
        actions.appendChild(logRow);
      }
    }

    item.appendChild(meta);
    item.appendChild(actions);
    container.appendChild(item);
  });
}

function renderFinalPhaseGeneralSection(type, dossier){
  const config = getFinalGeneralConfigByKey(type);
  if(!config){
    return;
  }
  const container = document.getElementById(config.containerId);
  if(!container){
    return;
  }
  const list = ensureFinalPhaseGeneralList(dossier, type);
  container.innerHTML = '';
  if(!list || list.length === 0){
    container.innerHTML = `<p class="muted">${config.emptyMessage || 'Nu existƒÉ documente ata»ôate.'}</p>`;
    return;
  }
  list.forEach(doc => {
    if(!doc || !doc.data){
      return;
    }
    const item = document.createElement('div');
    item.className = 'doc-item';
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `<strong>${escapeHtml(doc.name || config.tagLabel || 'Document')}</strong>`;
    const actions = document.createElement('div');
    actions.className = 'actions';
    const node = createAttachmentActionsNode(doc, { fallbackName: doc.name || 'document.pdf' });
    if(node){
      while(node.firstChild){
        actions.appendChild(node.firstChild);
      }
    }
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn ghost small';
    removeBtn.textContent = '»òterge';
    removeBtn.addEventListener('click', () => removeFinalPhaseGeneralDoc(type, doc.id));
    actions.appendChild(removeBtn);
    item.appendChild(meta);
    item.appendChild(actions);
    container.appendChild(item);
  });
}

function renderFinalPhaseSections(dossier, company){
  FINAL_WELDER_DOC_CONFIG.forEach(config => {
    renderFinalPhaseWelderSection(config.key, dossier, company);
  });
  FINAL_GENERAL_DOC_CONFIG.forEach(config => {
    renderFinalPhaseGeneralSection(config.key, dossier);
    if(config.fileInputId){
      const input = document.getElementById(config.fileInputId);
      if(input){
        input.value = '';
      }
    }
  });
  renderFinalPhaseCustomSteps(dossier);
}

function computeFinalPhaseStepStatuses(dossier, company){
  const finalPhase = ensureFinalPhase(dossier);
  const records = getFinalPhaseWelderRecords(dossier, company);
  const welderIds = records.map(record => record && record.welder && record.welder.id).filter(id => Number.isInteger(id));
  const uniqueWelderIds = Array.from(new Set(welderIds));
  const welderCount = uniqueWelderIds.length;
  const statuses = [];

  const hasAddress = typeof finalPhase.address === 'string' && finalPhase.address.trim().length > 0;
  statuses.push({
    key: 'address',
    label: 'Pasul 2 ¬∑ AdresƒÉ cƒÉtre organism',
    done: hasAddress,
    detail: hasAddress ? 'Text completat' : 'AdaugƒÉ adresa pentru documenta»õia finalƒÉ',
  });

  const welderStatusMap = {};
  FINAL_WELDER_DOC_CONFIG.forEach(config => {
    const docsMap = ensureFinalPhaseWelderDocs(dossier, config.key);
    let covered = 0;
    uniqueWelderIds.forEach(id => {
      const list = Array.isArray(docsMap[String(id)]) ? docsMap[String(id)] : [];
      if(list.length > 0){
        covered += 1;
      }
    });
    const baseDone = welderCount > 0 ? covered === welderCount : false;
    let detail = welderCount > 0
      ? `${covered} din ${welderCount} sudori au documente ata»ôate`
      : 'AdaugƒÉ sudori √Æn tabelul dosarului';
    if(config.key === 'examReports' && welderCount > 0){
      let logReady = 0;
      let logRequired = 0;
      records.forEach(record => {
        if(!record || !record.welder){
          return;
        }
        const welder = record.welder;
        if(!Number.isInteger(welder.id)){
          return;
        }
        if(welderRequiresWeldingLog(dossier, welder.id, welder, company)){
          logRequired += 1;
          const log = ensureWelderWeldingLog(welder);
          if(Array.isArray(log && log.entries) && log.entries.length > 0){
            logReady += 1;
          }
        }
      });
      if(logRequired > 0){
        detail += `. Fi»ôe de eviden»õƒÉ: ${logReady} din ${logRequired}`;
      }
      const logsComplete = logRequired > 0 ? logReady === logRequired : true;
      welderStatusMap[config.key] = { done: baseDone && logsComplete, detail, label: config.opisLabel };
      return;
    }
    welderStatusMap[config.key] = { done: baseDone, detail, label: config.opisLabel };
  });

  const generalStatusMap = {};
  FINAL_GENERAL_DOC_CONFIG.forEach(config => {
    const list = ensureFinalPhaseGeneralList(dossier, config.key);
    const done = Array.isArray(list) && list.length > 0;
    generalStatusMap[config.key] = {
      done,
      detail: done ? `${list.length} documente ata»ôate` : 'AdaugƒÉ documentele necesare pentru acest pas',
      label: config.opisLabel,
    };
  });

  const welderConfigByKey = key => welderStatusMap[key] || { done: false, detail: 'Date lipsƒÉ', label: '' };
  const generalConfigByKey = key => generalStatusMap[key] || { done: false, detail: 'Date lipsƒÉ', label: '' };

  const exam = welderConfigByKey('examReports');
  statuses.push({ key: 'examReports', label: `Pasul 3 ¬∑ ${exam.label || 'Procese verbale examinare sudori'}`, done: exam.done, detail: exam.detail });
  const written = welderConfigByKey('writtenWorks');
  statuses.push({ key: 'writtenWorks', label: `Pasul 4 ¬∑ ${written.label || 'LucrƒÉri scrise sudori'}`, done: written.done, detail: written.detail });
  const lab = generalConfigByKey('labAuthorizations');
  statuses.push({ key: 'labAuthorizations', label: 'Pasul 5 ¬∑ Autoriza»õii ISCIR laborator', done: lab.done, detail: lab.detail });
  const ndt = welderConfigByKey('ndtBulletins');
  statuses.push({ key: 'ndtBulletins', label: `Pasul 6 ¬∑ ${ndt.label || 'Buletine examinare nedistructivƒÉ'}`, done: ndt.done, detail: ndt.detail });
  const destructive = welderConfigByKey('destructiveReports');
  statuses.push({ key: 'destructiveReports', label: `Pasul 7 ¬∑ ${destructive.label || 'Rapoarte √ÆncercƒÉri distructive'}`, done: destructive.done, detail: destructive.detail });
  const inspector = generalConfigByKey('inspectorReports');
  statuses.push({ key: 'inspectorReports', label: 'Pasul 8 ¬∑ Procese verbale inspector', done: inspector.done, detail: inspector.detail });

  return statuses;
}

function refreshFinalPhaseOpis(dossier, company){
  const title = document.getElementById('auth_final_opis_title');
  if(title){
    title.innerHTML = '<div>OPIS</div><div>Documenta»õie finalƒÉ</div>';
  }
  const list = document.getElementById('auth_final_opis_list');
  if(!list){
    return;
  }
  list.innerHTML = '';
  const placeholder = document.createElement('li');
  placeholder.className = 'muted';
  placeholder.textContent = 'Se calculeazƒÉ paginile documenta»õiei finale‚Ä¶';
  list.appendChild(placeholder);
  const settings = getAuthorizationDossierPhaseSettings(company, 'final');
  const options = {
    phase: 'final',
    startPage: settings && settings.startPage ? settings.startPage : 1,
    pageOffset: settings && settings.pageOffset ? settings.pageOffset : 0,
  };
  const statuses = computeFinalPhaseStepStatuses(dossier, company) || [];
  const statusMap = new Map();
  statuses.forEach(status => {
    if(status && status.key){
      statusMap.set(status.key, status);
    }
  });
  const token = ++finalOpisRenderToken;
  computeDossierOpis(dossier, company, options).then(items => {
    if(token !== finalOpisRenderToken){
      return;
    }
    list.innerHTML = '';
    if(!items || items.length === 0){
      const empty = document.createElement('li');
      empty.className = 'muted';
      empty.textContent = 'Documenta»õia finalƒÉ nu con»õine sec»õiuni.';
      list.appendChild(empty);
      return;
    }
    items.forEach(item => {
      const li = document.createElement('li');
      const info = document.createElement('div');
      info.className = 'opis-info';
      const label = document.createElement('div');
      label.className = 'opis-label';
      const labelSpan = document.createElement('span');
      labelSpan.textContent = item.label;
      label.appendChild(labelSpan);
      info.appendChild(label);
      const detail = (() => {
        const lower = item.label.toLowerCase();
        if(lower.includes('adresƒÉ')){
          return statusMap.get('address');
        }
        if(lower.includes('procese verbale') && lower.includes('sudori')){
          return statusMap.get('examReports');
        }
        if(lower.includes('lucrƒÉri scrise')){
          return statusMap.get('writtenWorks');
        }
        if(lower.includes('laborator')){
          return statusMap.get('labAuthorizations');
        }
        if(lower.includes('nedestructiv')){
          return statusMap.get('ndtBulletins');
        }
        if(lower.includes('distructiv')){
          return statusMap.get('destructiveReports');
        }
        if(lower.includes('inspector')){
          return statusMap.get('inspectorReports');
        }
        return null;
      })();
      if(detail && detail.detail){
        const detailLine = document.createElement('div');
        detailLine.className = 'opis-detail';
        detailLine.textContent = detail.detail;
        info.appendChild(detailLine);
      }
      const page = document.createElement('span');
      page.className = 'opis-page';
      page.textContent = item.pageCount > 1
        ? `Pagina ${item.startPage}-${item.endPage}`
        : `Pagina ${item.startPage}`;
      li.appendChild(info);
      li.appendChild(page);
      list.appendChild(li);
    });
  }).catch(error => {
    if(token !== finalOpisRenderToken){
      return;
    }
    console.error('Nu s-a putut calcula opisul fazei finale.', error);
    list.innerHTML = '';
    const errorItem = document.createElement('li');
    errorItem.className = 'muted';
    errorItem.textContent = 'Nu s-a putut calcula opisul documenta»õiei finale.';
    list.appendChild(errorItem);
  });
}

async function addAuthorizationDossierWelderDoc(welderId, file){
  if(!file || !Number.isInteger(welderId) || welderId <= 0){
    return;
  }
  const isValid = !file.type || file.type === 'application/pdf' || file.type.startsWith('image/');
  if(!isValid){
    alert('Sunt acceptate doar fi»ôiere PDF sau imagini.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    const company = getActiveCompany();
    const dossier = getActiveAuthorizationDossier(company);
    if(!dossier){
      alert('CreeazƒÉ mai √Ænt√¢i un dosar de autorizare.');
      return;
    }
    const docsMap = ensureDossierWelderDocuments(dossier);
    const key = String(welderId);
    if(!Array.isArray(docsMap[key])){
      docsMap[key] = [];
    }
    const attachment = normalizeDossierItem({
      name: file.name || 'autorizatie.pdf',
      data: dataUrl,
      type: file.type || 'application/pdf',
    }, file.name || 'autorizatie.pdf');
    if(attachment){
      docsMap[key].push(attachment);
    }
    persistState();
    renderAuthorizationDossierDetail(dossier);
  } catch (err) {
    console.error('Nu s-a putut √ÆncƒÉrca documentul sudorului.', err);
    alert('√éncƒÉrcarea documentului a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function removeAuthorizationDossierWelderDoc(welderId, docId){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const docsMap = ensureDossierWelderDocuments(dossier);
  const key = String(welderId);
  const list = Array.isArray(docsMap[key]) ? docsMap[key] : [];
  docsMap[key] = list.filter(doc => doc && doc.id !== docId);
  if(docsMap[key].length === 0){
    delete docsMap[key];
  }
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function getFinalWelderConfigByKey(key){
  return FINAL_WELDER_DOC_CONFIG.find(entry => entry.key === key) || null;
}

function getFinalGeneralConfigByKey(key){
  return FINAL_GENERAL_DOC_CONFIG.find(entry => entry.key === key) || null;
}

async function addFinalPhaseWelderDoc(type, welderId, file){
  const config = getFinalWelderConfigByKey(type);
  if(!config || !file || !Number.isInteger(welderId) || welderId <= 0){
    return;
  }
  const isValid = !file.type || file.type === 'application/pdf' || file.type.startsWith('image/');
  if(!isValid){
    alert('Sunt acceptate doar fi»ôiere PDF sau imagini.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    const company = getActiveCompany();
    const dossier = getActiveAuthorizationDossier(company);
    if(!dossier){
      alert('CreeazƒÉ mai √Ænt√¢i un dosar de autorizare.');
      return;
    }
    const docsMap = ensureFinalPhaseWelderDocs(dossier, type);
    const key = String(welderId);
    if(!Array.isArray(docsMap[key])){
      docsMap[key] = [];
    }
    const attachment = normalizeDossierItem({
      name: file.name || FINAL_WELDER_FALLBACK[type] || 'document.pdf',
      data: dataUrl,
      type: file.type || 'application/pdf',
    }, file.name || FINAL_WELDER_FALLBACK[type] || 'document.pdf');
    if(attachment){
      docsMap[key].push(attachment);
    }
    persistState();
    renderAuthorizationDossierDetail(dossier);
  } catch (err) {
    console.error('Nu s-a putut √ÆncƒÉrca documentul fazei finale.', err);
    alert('√éncƒÉrcarea documentului a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function removeFinalPhaseWelderDoc(type, welderId, docId){
  const config = getFinalWelderConfigByKey(type);
  if(!config){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const docsMap = ensureFinalPhaseWelderDocs(dossier, type);
  const key = String(welderId);
  const list = Array.isArray(docsMap[key]) ? docsMap[key] : [];
  docsMap[key] = list.filter(doc => doc && doc.id !== docId);
  if(docsMap[key].length === 0){
    delete docsMap[key];
  }
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

async function addFinalPhaseGeneralDoc(type, file){
  const config = getFinalGeneralConfigByKey(type);
  if(!config || !file){
    return;
  }
  const isValid = !file.type || file.type === 'application/pdf' || file.type.startsWith('image/');
  if(!isValid){
    alert('Sunt acceptate doar fi»ôiere PDF sau imagini.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    const company = getActiveCompany();
    const dossier = getActiveAuthorizationDossier(company);
    if(!dossier){
      alert('CreeazƒÉ mai √Ænt√¢i un dosar de autorizare.');
      return;
    }
    const list = ensureFinalPhaseGeneralList(dossier, type);
    const attachment = normalizeDossierItem({
      name: file.name || FINAL_GENERAL_FALLBACK[type] || 'document.pdf',
      data: dataUrl,
      type: file.type || 'application/pdf',
    }, file.name || FINAL_GENERAL_FALLBACK[type] || 'document.pdf');
    if(attachment){
      list.push(attachment);
    }
    persistState();
    renderAuthorizationDossierDetail(dossier);
  } catch (err) {
    console.error('Nu s-a putut √ÆncƒÉrca documentul fazei finale.', err);
    alert('√éncƒÉrcarea documentului a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function removeFinalPhaseGeneralDoc(type, docId){
  const config = getFinalGeneralConfigByKey(type);
  if(!config){
    return;
  }
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const list = ensureFinalPhaseGeneralList(dossier, type);
  const index = list.findIndex(doc => doc && doc.id === docId);
  if(index !== -1){
    list.splice(index, 1);
    persistState();
    renderAuthorizationDossierDetail(dossier);
  }
}

function updateFinalPhaseLetter(value){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const finalPhase = ensureFinalPhase(dossier);
  ensureFinalPhaseLetterStyle(dossier);
  const next = normalizeLetterInput(value, dossier.standard || DEFAULT_AUTH_STANDARD, 'final');
  if(finalPhase.address !== next){
    finalPhase.address = next;
    updateAuthorizationLetterTemplate(dossier.standard || DEFAULT_AUTH_STANDARD, 'final', {
      text: finalPhase.address,
      style: normalizeLetterStyle(finalPhase.letterStyle),
    });
    persistState();
    renderAuthorizationLetterPreview(dossier, company, 'final');
    refreshFinalPhaseOpis(dossier, company);
  }
}

function updateAuthorizationDossierPhaseStatus(phase, value){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  if(phase === 'final' && value){
    const statuses = computeFinalPhaseStepStatuses(dossier, company);
    const incomplete = statuses.filter(status => !status.done);
    if(incomplete.length > 0){
      const labels = incomplete.map(status => status.label.replace(/Pasul \d+ ¬∑\s*/i, '').trim()).join(', ');
      const proceed = confirm(`Faza finalƒÉ are √ÆncƒÉ pa»ôi incomple»õi (${labels || 'elemente necunoscute'}). Sigur marchezi faza ca finalizatƒÉ?`);
      if(!proceed){
        const toggle = document.getElementById('auth_phase_final_closed');
        if(toggle){
          toggle.checked = false;
        }
        return;
      }
    }
  }
  if(phase === 'preliminary'){
    dossier.preliminaryClosed = !!value;
  } else if(phase === 'final'){
    const finalPhase = ensureFinalPhase(dossier);
    finalPhase.closed = !!value;
  }
  persistState();
  const activeCompany = getActiveCompany();
  renderAuthorizationDossierDetail(dossier);
  refreshFinalPhaseOpis(dossier, activeCompany);
}

async function handleAddMaterialDoc(type){
  const validTypes = ['base', 'filler'];
  if(!validTypes.includes(type)){
    return;
  }
  const selectId = type === 'base' ? 'auth_dossier_base_material_select' : 'auth_dossier_filler_material_select';
  const fileId = type === 'base' ? 'auth_dossier_base_material_file' : 'auth_dossier_filler_material_file';
  const select = document.getElementById(selectId);
  const fileInput = document.getElementById(fileId);
  if(!select || !fileInput){
    return;
  }
  const material = select.value ? String(select.value).trim() : '';
  if(!material){
    alert('SelecteazƒÉ materialul pentru care √Æncarci documentul.');
    return;
  }
  if(!fileInput.files || !fileInput.files[0]){
    alert('SelecteazƒÉ un fi»ôier de √ÆncƒÉrcat.');
    return;
  }
  const file = fileInput.files[0];
  const isValid = !file.type || file.type === 'application/pdf' || file.type.startsWith('image/');
  if(!isValid){
    alert('Sunt acceptate doar fi»ôiere PDF sau imagini.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    const company = getActiveCompany();
    const dossier = getActiveAuthorizationDossier(company);
    if(!dossier){
      alert('CreeazƒÉ mai √Ænt√¢i un dosar de autorizare.');
      return;
    }
    const materials = ensureDossierMaterialDocuments(dossier);
    if(!Array.isArray(materials[type][material])){
      materials[type][material] = [];
    }
    materials[type][material].push({
      id: generateDocumentId('matdoc'),
      name: file.name || 'document.pdf',
      data: dataUrl,
      type: file.type || 'application/pdf',
      added_at: new Date().toISOString(),
    });
    persistState();
    renderAuthorizationDossierDetail(dossier);
    fileInput.value = '';
  } catch (err) {
    console.error('Nu s-a putut √ÆncƒÉrca documentul materialului.', err);
    alert('√éncƒÉrcarea documentului a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function removeAuthorizationDossierMaterialDoc(type, material, docId){
  const company = getActiveCompany();
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  const materials = ensureDossierMaterialDocuments(dossier);
  const bucket = materials[type] && materials[type][material];
  if(!Array.isArray(bucket)){
    return;
  }
  materials[type][material] = bucket.filter(doc => doc && doc.id !== docId);
  if(materials[type][material].length === 0){
    delete materials[type][material];
  }
  persistState();
  renderAuthorizationDossierDetail(dossier);
}

function getAuthorizationArchiveEntryById(id){
  const company = getActiveCompany();
  const archive = ensureAuthorizationDossierArchive(company);
  return archive.find(entry => entry && entry.id === id) || null;
}

function saveAuthorizationDossierArchiveEntry(dossier, plan, bytes, filename){
  const company = getActiveCompany();
  const archive = ensureAuthorizationDossierArchive(company);
  const buffer = bytes instanceof Uint8Array ? bytes : (bytes && typeof bytes.length === 'number' ? new Uint8Array(bytes) : new Uint8Array());
  const base64 = uint8ArrayToBase64(buffer);
  let snapshot = null;
  try {
    snapshot = JSON.parse(JSON.stringify(dossier));
  } catch (error) {
    console.warn('Nu s-a putut salva structura dosarului pentru arhivƒÉ.', error);
  }
  const entry = {
    id: company.nextAuthorizationDossierArchiveId++,
    dossier_id: dossier && dossier.id !== undefined ? dossier.id : null,
    name: computeDossierTitle(dossier),
    standard: dossier && dossier.standard ? dossier.standard : null,
    saved_at: new Date().toISOString(),
    filename: filename || `${slugifyForFilename(computeDossierTitle(dossier) || 'dosar-autorizare', 'dosar-autorizare')}.pdf`,
    data: base64,
    page_count: plan && plan.totalPages ? plan.totalPages : null,
    details: Array.isArray(plan && plan.details)
      ? plan.details.map(detail => ({
        label: detail && detail.label ? detail.label : 'Sec»õiune',
        startPage: detail && detail.startPage !== undefined ? detail.startPage : null,
        endPage: detail && detail.endPage !== undefined ? detail.endPage : null,
        pageCount: detail && detail.pageCount !== undefined ? detail.pageCount : null,
      }))
      : [],
    snapshot,
  };
  archive.push(entry);
  persistState();
  renderAuthorizationDossierArchive();
}

function toggleAuthorizationPhaseSettings(phase){
  const targetPhase = phase === 'final' ? 'final' : 'preliminary';
  const panelId = targetPhase === 'final' ? 'auth_final_settings_panel' : 'auth_preliminary_settings_panel';
  const buttonId = targetPhase === 'final' ? 'btn_auth_final_settings' : 'btn_auth_preliminary_settings';
  const otherPanelId = targetPhase === 'final' ? 'auth_preliminary_settings_panel' : 'auth_final_settings_panel';
  const otherButtonId = targetPhase === 'final' ? 'btn_auth_preliminary_settings' : 'btn_auth_final_settings';
  const panel = document.getElementById(panelId);
  const button = document.getElementById(buttonId);
  if(!panel || !button){
    return;
  }
  const willOpen = !panel.classList.contains('open');
  const otherPanel = document.getElementById(otherPanelId);
  const otherButton = document.getElementById(otherButtonId);
  if(otherPanel){
    otherPanel.classList.remove('open');
    otherPanel.setAttribute('aria-hidden', 'true');
  }
  if(otherButton){
    otherButton.setAttribute('aria-expanded', 'false');
  }
  panel.classList.toggle('open', willOpen);
  panel.setAttribute('aria-hidden', willOpen ? 'false' : 'true');
  button.setAttribute('aria-expanded', willOpen ? 'true' : 'false');
  if(willOpen && typeof panel.scrollIntoView === 'function'){
    panel.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

function setReportsMenuOpen(){
  // Integrarea rapoartelor este realizatƒÉ direct √Æn vizualizarea dedicatƒÉ din bara lateralƒÉ.
}

function handleAuthorizationDossierPageNumberToggle(event){
  const target = event && event.target;
  if(!target){
    return;
  }
  const phase = target.getAttribute('data-phase') === 'final' ? 'final' : 'preliminary';
  const company = getActiveCompany();
  updateAuthorizationDossierPhaseNumbering(company, phase, target.checked);
}

function handleAuthorizationDossierStartPageChange(event){
  const target = event && event.target;
  if(!target){
    return;
  }
  const phase = target.getAttribute('data-phase') === 'final' ? 'final' : 'preliminary';
  const company = getActiveCompany();
  const applied = updateAuthorizationDossierPhaseStartPage(company, phase, target.value);
  target.value = applied;
  if(phase === 'preliminary'){
    const dossier = getActiveAuthorizationDossier(company);
    if(dossier){
      const prelimSettings = getAuthorizationDossierPhaseSettings(company, 'preliminary');
      refreshAuthorizationDossierOpisList(dossier, company, prelimSettings);
    }
  } else {
    const dossier = getActiveAuthorizationDossier(company);
    if(dossier){
      refreshFinalPhaseOpis(dossier, company);
    }
  }
}

function handleAuthorizationDossierPageOffsetChange(event){
  const target = event && event.target;
  if(!target){
    return;
  }
  const phase = target.getAttribute('data-phase') === 'final' ? 'final' : 'preliminary';
  const company = getActiveCompany();
  const applied = updateAuthorizationDossierPhaseOffset(company, phase, target.value);
  target.value = applied;
  const dossier = getActiveAuthorizationDossier(company);
  if(!dossier){
    return;
  }
  if(phase === 'preliminary'){
    const prelimSettings = getAuthorizationDossierPhaseSettings(company, 'preliminary');
    refreshAuthorizationDossierOpisList(dossier, company, prelimSettings);
  } else {
    refreshFinalPhaseOpis(dossier, company);
  }
}

function renderAuthorizationDossierArchive(){
  const tbody = document.getElementById('auth_dossier_archive_tbody');
  const wrap = document.getElementById('auth_dossier_archive_table_wrap');
  const empty = document.getElementById('auth_dossier_archive_empty');
  if(!tbody || !wrap || !empty){
    return;
  }
  tbody.innerHTML = '';
  const company = getActiveCompany();
  const archive = ensureAuthorizationDossierArchive(company);
  if(!archive || archive.length === 0){
    wrap.classList.add('hidden');
    empty.classList.remove('hidden');
    return;
  }
  wrap.classList.remove('hidden');
  empty.classList.add('hidden');
  const sorted = archive.slice().sort((a, b) => {
    const aTime = a && a.saved_at ? new Date(a.saved_at).getTime() : 0;
    const bTime = b && b.saved_at ? new Date(b.saved_at).getTime() : 0;
    return bTime - aTime;
  });
  sorted.forEach(entry => {
    const tr = document.createElement('tr');
    const standardLabel = entry && entry.standard ? getStandardLabel(entry.standard) : '‚Äî';
    const savedDate = entry && entry.saved_at ? new Date(entry.saved_at).toLocaleString('ro-RO') : '‚Äî';
    const pages = entry && entry.page_count ? String(entry.page_count) : '‚Äî';
    tr.innerHTML = `
      <td>${escapeHtml(entry && entry.name ? entry.name : 'Dosar PDF')}</td>
      <td>${escapeHtml(standardLabel)}</td>
      <td>${escapeHtml(savedDate)}</td>
      <td>${escapeHtml(pages)}</td>
      <td>
        <div class="dossier-actions">
          <button type="button" class="btn ghost small" data-icon="view" data-archive-action="preview" data-archive-id="${entry.id}">PrevizualizeazƒÉ</button>
          <button type="button" class="btn secondary small" data-icon="download" data-archive-action="download" data-archive-id="${entry.id}">DescarcƒÉ</button>
          <button type="button" class="btn small" data-archive-action="restore" data-archive-id="${entry.id}">RestaureazƒÉ</button>
          <button type="button" class="btn danger small" data-archive-action="delete" data-archive-id="${entry.id}">»òterge</button>
        </div>
      </td>
    `;
    tbody.appendChild(tr);
  });
  tbody.querySelectorAll('button[data-archive-action]').forEach(button => {
    button.addEventListener('click', () => {
      const rawId = button.getAttribute('data-archive-id');
      const action = button.getAttribute('data-archive-action');
      const id = Number(rawId);
      if(Number.isNaN(id)){
        return;
      }
      const entry = getAuthorizationArchiveEntryById(id);
      if(!entry){
        alert('Documentul arhivat nu este disponibil.');
        return;
      }
      if(action === 'delete'){
        deleteAuthorizationDossierArchiveEntry(id);
        return;
      }
      if(action === 'restore'){
        restoreAuthorizationDossierFromArchive(entry);
        return;
      }
      if(!entry.data){
        alert('Documentul arhivat nu este disponibil.');
        return;
      }
      const bytes = base64ToUint8Array(entry.data);
      if(!bytes || bytes.length === 0){
        alert('Documentul arhivat nu este disponibil.');
        return;
      }
      const filename = entry.filename || `${slugifyForFilename(entry.name || 'dosar-autorizare', 'dosar-autorizare')}.pdf`;
      if(action === 'preview'){
        const previewWindow = openAuthorizationDossierPreviewWindow();
        renderAuthorizationDossierPreview(previewWindow, bytes, filename);
      } else {
        triggerPdfDownload(bytes, filename);
      }
    });
  });
}

function deleteAuthorizationDossierArchiveEntry(id){
  if(Number.isNaN(id)){
    return;
  }
  const company = getActiveCompany();
  const archive = ensureAuthorizationDossierArchive(company);
  const index = archive.findIndex(entry => entry && entry.id === id);
  if(index === -1){
    return;
  }
  if(!confirm('»òtergi acest dosar din arhivƒÉ? Opera»õia nu poate fi anulatƒÉ.')){
    return;
  }
  archive.splice(index, 1);
  persistState();
  renderAuthorizationDossierArchive();
}

function restoreAuthorizationDossierFromArchive(entry){
  const company = getActiveCompany();
  if(!company || !entry){
    return;
  }
  if(!entry.snapshot){
    alert('Acest dosar arhivat nu con»õine informa»õii pentru restaurare.');
    return;
  }
  const restored = normalizeAuthorizationDossier(entry.snapshot);
  if(!restored){
    alert('Dosarul nu a putut fi restaurat.');
    return;
  }
  restored.id = generateDocumentId('authdos');
  ensureDossierMaterialDocuments(restored);
  ensureDossierLetterStyle(restored);
  ensureDossierCustomSteps(restored);
  ensureAuthorizationDossiers(company).push(restored);
  const archive = ensureAuthorizationDossierArchive(company);
  const archiveIndex = archive.findIndex(item => item && item.id === entry.id);
  if(archiveIndex !== -1){
    archive.splice(archiveIndex, 1);
  }
  activeAuthorizationDossierId = restored.id;
  persistState();
  renderAuthorizationDossierControls();
  renderAuthorizationDossierDetail(restored);
  renderAuthorizationDossierArchive();
  alert('Dosarul a fost restaurat din arhivƒÉ »ôi este disponibil pentru editare.');
}

function loadProcedureDossier(){
  const tbody = document.getElementById('proc_dossier_tbody');
  const wrap = document.getElementById('proc_dossier_list_wrap');
  const empty = document.getElementById('proc_dossier_empty');
  if(!tbody){
    return;
  }
  tbody.innerHTML = '';
  const company = getActiveCompany();
  const docs = Array.isArray(company.procedureDossier) ? company.procedureDossier.slice() : [];
  if(docs.length === 0){
    if(wrap){
      wrap.classList.add('hidden');
    }
    if(empty){
      empty.classList.remove('hidden');
    }
    return;
  }
  if(wrap){
    wrap.classList.remove('hidden');
  }
  if(empty){
    empty.classList.add('hidden');
  }
  docs.sort((a, b) => (a.added_at || '').localeCompare(b.added_at || ''));
  docs.forEach(doc => {
    const tr = document.createElement('tr');
    const addedAt = doc.added_at ? String(doc.added_at).slice(0, 10) : '';
    const filename = doc.name || 'document';
    const nameCell = document.createElement('td');
    nameCell.textContent = filename;
    const dateCell = document.createElement('td');
    dateCell.textContent = addedAt;
    const actionsCell = document.createElement('td');
    actionsCell.className = 'attachment-actions';
    const actionsNode = createAttachmentActionsNode(doc, { fallbackName: filename || 'document.pdf' });
    if(actionsNode){
      actionsCell.appendChild(actionsNode);
    } else {
      const span = document.createElement('span');
      span.className = 'muted';
      span.textContent = 'Document indisponibil';
      actionsCell.appendChild(span);
    }
    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'btn ghost small';
    deleteBtn.textContent = '»òterge';
    deleteBtn.setAttribute('data-action', 'delete');
    deleteBtn.setAttribute('data-id', doc.id);
    actionsCell.appendChild(deleteBtn);
    tr.appendChild(nameCell);
    tr.appendChild(dateCell);
    tr.appendChild(actionsCell);
    tbody.appendChild(tr);
  });
  tbody.querySelectorAll('button[data-action="delete"]').forEach(button => {
    button.addEventListener('click', () => {
      const docId = button.getAttribute('data-id');
      if(docId){
        removeProcedureDossierDocument(docId);
      }
    });
  });
}

async function addProcedureDossierDocument(){
  const input = document.getElementById('proc_dossier_file');
  if(!input || !input.files || !input.files[0]){
    alert('SelecteazƒÉ un fi»ôier de √ÆncƒÉrcat.');
    return;
  }
  const file = input.files[0];
  const allowed = file.type ? (file.type === 'application/pdf' || file.type.startsWith('image/')) : true;
  if(!allowed){
    alert('Sunt acceptate doar fi»ôiere PDF sau imagini.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    const record = {
      id: generateDocumentId('procdoc'),
      name: file.name || 'document_omologare.pdf',
      data: dataUrl,
      type: file.type || 'application/pdf',
      added_at: new Date().toISOString(),
    };
    const company = getActiveCompany();
    if(!Array.isArray(company.procedureDossier)){
      company.procedureDossier = [];
    }
    company.procedureDossier.push(record);
    persistState();
    loadProcedureDossier();
    input.value = '';
  } catch (err) {
    console.error('Nu s-a putut √ÆncƒÉrca documentul pentru dosarul de omologare.', err);
    alert('√éncƒÉrcarea documentului a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function removeProcedureDossierDocument(documentId){
  const company = getActiveCompany();
  if(!Array.isArray(company.procedureDossier)){
    return;
  }
  company.procedureDossier = company.procedureDossier.filter(item => item && item.id !== documentId);
  persistState();
  loadProcedureDossier();
}

function populateAuthorizationWelderSelect(){
  const select = document.getElementById('auth_welder_select');
  if(!select){
    return;
  }
  const company = getActiveCompany();
  const previous = select.value;
  select.innerHTML = '<option value="">SelecteazƒÉ sudor</option>';
  const ordered = sortWelders(company.welders);
  ordered.forEach(w => {
    const option = document.createElement('option');
    option.value = String(w.id);
    option.textContent = w.name;
    select.appendChild(option);
  });
  const desired = selectedWelder ? String(selectedWelder.id) : previous;
  const exists = Array.from(select.options).some(opt => opt.value === desired);
  select.value = exists ? desired : '';
}

function populateAuthorizationProcedureSelect(){
  const select = document.getElementById('auth_procedure_select');
  if(!select){
    return;
  }
  const company = getActiveCompany();
  const previous = select.value;
  select.innerHTML = '<option value="">SelecteazƒÉ procedeu</option>';
  const list = company.qualifications.filter(q => q && q.category === 'procedee').sort((a, b) => {
    const labelA = `${getStandardLabel(a.standard)} ${a.process || ''}`;
    const labelB = `${getStandardLabel(b.standard)} ${b.process || ''}`;
    return labelA.localeCompare(labelB, 'ro', { sensitivity: 'base' });
  });
  list.forEach(proc => {
    const option = document.createElement('option');
    option.value = String(proc.id);
    const label = getStandardLabel(proc.standard);
    option.textContent = proc.process ? `${label} ¬∑ ${proc.process}` : label;
    select.appendChild(option);
  });
  const exists = Array.from(select.options).some(opt => opt.value === previous);
  select.value = exists ? previous : '';
  select.disabled = select.options.length <= 1;
}

function populateProcedureWelderSelect(){
  const select = document.getElementById('proc_welder_select');
  if(!select){
    return;
  }
  const company = getActiveCompany();
  const previous = select.value;
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Procedeu general';
  select.innerHTML = '';
  select.appendChild(placeholder);
  const ordered = sortWelders(company.welders);
  ordered.forEach(w => {
    const option = document.createElement('option');
    option.value = String(w.id);
    option.textContent = w.name;
    select.appendChild(option);
  });
  const desired = selectedWelder ? String(selectedWelder.id) : previous;
  const exists = Array.from(select.options).some(opt => opt.value === desired);
  select.value = exists ? desired : '';
}

function populatePansonSelect(){
  const select = document.getElementById('w_panson');
  if(!select){
    return;
  }
  const company = getActiveCompany();
  const valueBefore = select.value;
  const manualInput = document.getElementById('w_code_manual');
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'SelecteazƒÉ panson';
  select.appendChild(placeholder);
  company.pansoane.filter(p => !p.archived).sort((a, b) => {
    const codeA = a.code ? String(a.code) : '';
    const codeB = b.code ? String(b.code) : '';
    return codeA.localeCompare(codeB, 'ro', { sensitivity: 'base' });
  }).forEach(panson => {
    const option = document.createElement('option');
    option.value = String(panson.id);
    const label = panson.description ? `${panson.code} ¬∑ ${panson.description}` : panson.code;
    option.textContent = label || `Panson #${panson.id}`;
    select.appendChild(option);
  });
  const desired = selectedWelder && selectedWelder.panson_id ? String(selectedWelder.panson_id) : valueBefore;
  const exists = Array.from(select.options).some(opt => opt.value === desired);
  select.value = exists ? desired : '';
  if(!exists && !desired){
    select.value = '';
  }
  if(selectedWelder && manualInput){
    manualInput.value = selectedWelder.code || '';
  }
}

function updateAuthorizationContext(){
  const label = document.getElementById('auth_current_welder');
  if(label){
    if(selectedWelder){
      const position = selectedWelderPosition || getWelderPosition(selectedWelder.id);
      selectedWelderPosition = position;
      label.textContent = position ? `${selectedWelder.name} #${position}` : selectedWelder.name;
    } else {
      label.textContent = '(selecteazƒÉ un sudor)';
    }
  }
  const select = document.getElementById('auth_welder_select');
  if(select){
    const targetValue = selectedWelder ? String(selectedWelder.id) : '';
    if(select.value !== targetValue){
      select.value = targetValue;
    }
  }
  const pansonField = document.getElementById('auth_welder_panson');
  if(pansonField){
    if(selectedWelder){
      const code = selectedWelder.code || getPansonCodeById(selectedWelder.panson_id) || '';
      pansonField.value = code ? code : '‚Äî';
    } else {
      pansonField.value = '';
      pansonField.placeholder = '‚Äî';
    }
  }
}

function handleAuthorizationProcedureChange(){
  const select = document.getElementById('auth_procedure_select');
  if(!select){
    return;
  }
  const value = select.value;
  const processField = document.getElementById('auth_process');
  const positionField = document.getElementById('auth_position');
  const materialField = document.getElementById('auth_base_material');
  const domainField = document.getElementById('auth_thickness_domain');
  if(!value){
    return;
  }
  const id = Number(value);
  if(Number.isNaN(id)){
    return;
  }
  const company = getActiveCompany();
  const procedure = company.qualifications.find(entry => entry && entry.id === id && entry.category === 'procedee');
  if(!procedure){
    return;
  }
  if(processField && procedure.process){
    processField.value = procedure.process;
  }
  if(positionField && procedure.position){
    const desired = procedure.position;
    const options = Array.from(positionField.options || []);
    if(options.some(option => option.value === desired || option.textContent === desired)){
      positionField.value = desired;
    } else {
      positionField.value = desired;
    }
  }
  if(materialField && procedure.product){
    materialField.value = procedure.product;
  }
  if(domainField && procedure.thickness_range){
    domainField.value = procedure.thickness_range;
  }
}

function updateAttachmentPreview(containerId, attachment, options){
  const container = document.getElementById(containerId);
  if(!container){
    return;
  }
  container.innerHTML = '';
  if(!attachment || !attachment.data){
    return;
  }
  const viewLabel = options && options.viewLabel
    ? options.viewLabel
    : (options && options.label ? options.label : 'VizualizeazƒÉ fi»ôier');
  const downloadLabel = options && options.downloadLabel ? options.downloadLabel : 'DescarcƒÉ';
  const fallbackName = options && options.fallbackName ? options.fallbackName : 'document';
  const attachmentId = registerAttachment(attachment);
  if(attachmentId){
    const viewButton = document.createElement('button');
    viewButton.type = 'button';
    viewButton.className = 'btn ghost small';
    viewButton.dataset.attachmentView = attachmentId;
    viewButton.dataset.attachmentName = attachment.name || fallbackName;
    setButtonTextWithIcon(viewButton, viewLabel, 'view');
    container.appendChild(viewButton);
  }
  const download = document.createElement('a');
  download.href = attachment.data;
  download.download = attachment.name || fallbackName;
  download.className = 'btn secondary small';
  setButtonTextWithIcon(download, downloadLabel, 'download');
  container.appendChild(download);
  const metaText = options && options.meta ? String(options.meta).trim() : '';
  if(metaText){
    const note = document.createElement('span');
    note.className = 'attachment-meta-note';
    note.textContent = metaText;
    container.appendChild(note);
  }
  const type = attachment.type || '';
  if(type.startsWith('image/') || attachment.data.startsWith('data:image')){
    const preview = document.createElement('img');
    preview.src = attachment.data;
    preview.alt = viewLabel;
    container.appendChild(preview);
  }
}

function updatePansonArchiveToggle(){
  const toggle = document.getElementById('toggle_panson_archive');
  if(!toggle){
    return;
  }
  const company = getActiveCompany();
  const total = Array.isArray(company.archivedPansoane) ? company.archivedPansoane.length : 0;
  const baseLabel = pansonArchiveVisible ? 'Ascunde arhiva pansoane' : 'ArhivƒÉ pansoane';
  toggle.textContent = `${baseLabel} (${total})`;
  toggle.disabled = total === 0 && !pansonArchiveVisible;
}

function updatePansonArchiveVisibility(){
  const panel = document.getElementById('panson_archive_panel');
  if(panel){
    panel.classList.toggle('hidden', !pansonArchiveVisible);
    panel.setAttribute('aria-hidden', pansonArchiveVisible ? 'false' : 'true');
  }
  const toggle = document.getElementById('toggle_panson_archive');
  if(toggle){
    toggle.setAttribute('aria-expanded', pansonArchiveVisible ? 'true' : 'false');
  }
  updatePansonArchiveToggle();
}

function renderPansonArchiveList(){
  const tbody = document.getElementById('panson_archive_tbody');
  const wrap = document.getElementById('panson_archive_table_wrap');
  const emptyState = document.getElementById('panson_archive_empty');
  if(!tbody){
    return;
  }
  tbody.innerHTML = '';
  const company = getActiveCompany();
  const list = Array.isArray(company.archivedPansoane) ? company.archivedPansoane.slice() : [];
  const shouldCollapse = list.length === 0 && pansonArchiveVisible;
  if(list.length === 0){
    if(wrap){
      wrap.classList.add('hidden');
    }
    if(emptyState){
      emptyState.classList.remove('hidden');
    }
    if(shouldCollapse){
      pansonArchiveVisible = false;
    }
  } else {
    if(wrap){
      wrap.classList.remove('hidden');
    }
    if(emptyState){
      emptyState.classList.add('hidden');
    }
    list.sort((a, b) => {
      const codeA = a && a.code ? String(a.code) : '';
      const codeB = b && b.code ? String(b.code) : '';
      return codeA.localeCompare(codeB, 'ro', { sensitivity: 'base' });
    }).forEach(entry => {
      const tr = document.createElement('tr');
      const archivedAt = entry && entry.archived_at ? String(entry.archived_at).slice(0, 10) : '';
      tr.innerHTML = `
        <td>${escapeHtml(entry && entry.code ? entry.code : '')}</td>
        <td>${escapeHtml(entry && entry.description ? entry.description : '')}</td>
        <td>${escapeHtml(archivedAt)}</td>
        <td><button class="btn ghost" data-action="restore" data-id="${entry && entry.id !== undefined ? entry.id : ''}">RestaureazƒÉ</button></td>
      `;
      tbody.appendChild(tr);
    });
    tbody.querySelectorAll('button[data-action="restore"]').forEach(button => {
      button.addEventListener('click', () => {
        const id = Number(button.getAttribute('data-id'));
        if(Number.isNaN(id)){
          return;
        }
        restorePanson(id);
      });
    });
  }
  updatePansonArchiveToggle();
  if(shouldCollapse){
    updatePansonArchiveVisibility();
  }
}

function loadPansoane(){
  const tbody = document.getElementById('pansoane_tbody');
  const emptyState = document.getElementById('pansoane_empty');
  const countLabel = document.getElementById('panson_count');
  if(!tbody){
    return;
  }
  tbody.innerHTML = '';
  const company = getActiveCompany();
  const activeList = Array.isArray(company.pansoane)
    ? company.pansoane.filter(p => !p.archived)
    : [];
  if(countLabel){
    countLabel.textContent = activeList.length;
  }
  if(activeList.length === 0){
    if(emptyState){
      emptyState.classList.remove('hidden');
    }
  } else {
    if(emptyState){
      emptyState.classList.add('hidden');
    }
    activeList.sort((a, b) => {
      const codeA = a && a.code ? String(a.code) : '';
      const codeB = b && b.code ? String(b.code) : '';
      return codeA.localeCompare(codeB, 'ro', { sensitivity: 'base' });
    }).forEach(panson => {
      const tr = document.createElement('tr');
      const usageCount = company.welders.filter(w => w && w.panson_id === panson.id).length;
      tr.innerHTML = `
        <td>${escapeHtml(panson && panson.code ? panson.code : '')}</td>
        <td>${escapeHtml(panson && panson.description ? panson.description : '')}</td>
        <td>${escapeHtml(usageCount)}</td>
        <td><button class="btn ghost" data-action="archive" data-id="${panson && panson.id !== undefined ? panson.id : ''}">ArhiveazƒÉ</button></td>
      `;
      tbody.appendChild(tr);
    });
    tbody.querySelectorAll('button[data-action="archive"]').forEach(button => {
      button.addEventListener('click', () => {
        const id = Number(button.getAttribute('data-id'));
        if(Number.isNaN(id)){
          return;
        }
        archivePanson(id);
      });
    });
  }
  renderPansonArchiveList();
  updatePansonArchiveVisibility();
}

function addPanson(){
  const codeInput = document.getElementById('panson_code');
  const descriptionInput = document.getElementById('panson_description');
  if(!codeInput){
    return;
  }
  const codeValue = codeInput.value ? codeInput.value.trim() : '';
  if(!codeValue){
    alert('CompleteazƒÉ codul pansonului.');
    return;
  }
  const descriptionValue = descriptionInput && descriptionInput.value ? descriptionInput.value.trim() : '';
  const company = getActiveCompany();
  const normalizedCode = codeValue.toLowerCase();
  const duplicate = company.pansoane.some(p => p && p.code && p.code.toLowerCase() === normalizedCode)
    || company.archivedPansoane.some(p => p && p.code && p.code.toLowerCase() === normalizedCode);
  if(duplicate){
    alert('ExistƒÉ deja un panson cu acest cod.');
    return;
  }
  const newPanson = {
    id: company.nextPansonId++,
    code: codeValue,
    description: descriptionValue,
    archived: false,
    archived_at: null,
  };
  company.pansoane.push(newPanson);
  persistState();
  loadPansoane();
  populatePansonSelect();
  if(codeInput){
    codeInput.value = '';
  }
  if(descriptionInput){
    descriptionInput.value = '';
  }
}

function archivePanson(id){
  const company = getActiveCompany();
  const index = company.pansoane.findIndex(p => p && p.id === id);
  if(index === -1){
    return;
  }
  const usageCount = company.welders.filter(w => w && w.panson_id === id).length;
  if(usageCount > 0){
    const confirmArchive = confirm('ExistƒÉ sudori care utilizeazƒÉ acest panson. Codul rƒÉm√¢ne salvat la sudorii existen»õi, dar nu va mai putea fi selectat pentru al»õii. Continui?');
    if(!confirmArchive){
      return;
    }
  }
  const [panson] = company.pansoane.splice(index, 1);
  company.archivedPansoane.push({
    id: panson.id,
    code: panson.code,
    description: panson.description,
    archived: true,
    archived_at: new Date().toISOString(),
  });
  persistState();
  loadPansoane();
  populatePansonSelect();
  loadWelders();
}

function restorePanson(id){
  const company = getActiveCompany();
  const index = company.archivedPansoane.findIndex(p => p && p.id === id);
  if(index === -1){
    return;
  }
  const entry = company.archivedPansoane[index];
  let pansonId = entry && entry.id ? entry.id : 0;
  if(pansonId <= 0 || company.pansoane.some(p => p && p.id === pansonId)){
    pansonId = company.nextPansonId++;
  } else if(pansonId >= company.nextPansonId){
    company.nextPansonId = pansonId + 1;
  }
  company.pansoane.push({
    id: pansonId,
    code: entry && entry.code ? entry.code : `P-${pansonId}`,
    description: entry && entry.description ? entry.description : '',
    archived: false,
    archived_at: null,
  });
  company.archivedPansoane.splice(index, 1);
  persistState();
  loadPansoane();
  populatePansonSelect();
  loadWelders();
}


function normalizeWelder(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const name = typeof raw.name === 'string' ? normalizeNameInput(raw.name) : '';
  if(!name){
    return null;
  }
  const idValue = Number(raw.id);
  const id = Number.isInteger(idValue) && idValue > 0 ? idValue : 0;
  const code = raw && raw.code !== undefined && raw.code !== null ? raw.code : null;
  const hireDate = raw && raw.hire_date ? raw.hire_date : null;
  const phone = typeof raw.phone === 'string' ? raw.phone.trim() : '';
  let pansonId = null;
  if(raw && raw.panson_id !== undefined && raw.panson_id !== null){
    const numeric = Number(raw.panson_id);
    pansonId = Number.isNaN(numeric) ? null : numeric;
  }
  return {
    id,
    name,
    code,
    phone,
    panson_id: pansonId,
    hire_date: hireDate,
    photo: normalizeWelderAttachment(raw && raw.photo ? raw.photo : null, 'fotografie'),
    id_card: normalizeWelderAttachment(raw && raw.id_card ? raw.id_card : null, 'carte_identitate'),
    diploma: normalizeWelderAttachment(raw && raw.diploma ? raw.diploma : null, 'diploma'),
    contract: normalizeWelderAttachment(raw && raw.contract ? raw.contract : null, 'contract'),
    aptitude: normalizeWelderAttachment(raw && raw.aptitude ? raw.aptitude : null, 'fisa_aptitudini'),
    bundle: normalizeWelderAttachment(raw && raw.bundle ? raw.bundle : null, 'documente_personale'),
    id_card_expiry: normalizeDateValue(raw && (raw.id_card_expiry || raw.idCardExpiry)),
    aptitude_expiry: normalizeDateValue(raw && (raw.aptitude_expiry || raw.aptitudeExpiry)),
    authorization_dossier: Array.isArray(raw && raw.authorization_dossier)
      ? raw.authorization_dossier.map(item => normalizeDossierItem(item, 'document_autorizare')).filter(Boolean)
      : [],
    welding_log: normalizeWeldingLog(raw && (raw.welding_log || raw.weldingLog)),
  };
}

function ensureWelderWeldingLog(welder){
  if(!welder){
    return createEmptyWeldingLog();
  }
  if(!welder.welding_log || typeof welder.welding_log !== 'object'){
    welder.welding_log = createEmptyWeldingLog();
    return welder.welding_log;
  }
  const normalized = normalizeWeldingLog(welder.welding_log);
  welder.welding_log = normalized;
  return normalized;
}

function normalizeQualification(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const categoryRaw = typeof raw.category === 'string' ? raw.category : '';
  const category = QUALIFICATION_CATEGORIES.includes(categoryRaw)
    ? categoryRaw
    : DEFAULT_QUALIFICATION_CATEGORY;
  const idValue = Number(raw.id);
  const id = Number.isInteger(idValue) && idValue > 0 ? idValue : 0;
  let welderId = null;
  if(raw && raw.welder_id !== undefined && raw.welder_id !== null){
    const numeric = Number(raw.welder_id);
    welderId = Number.isNaN(numeric) ? null : numeric;
  }
  let procedureId = null;
  if(raw && raw.procedure_id !== undefined && raw.procedure_id !== null){
    const numeric = Number(raw.procedure_id);
    procedureId = Number.isNaN(numeric) ? null : numeric;
  }
  const defaultStandard = category === 'procedee' ? DEFAULT_PROCEDURE_STANDARD : DEFAULT_AUTH_STANDARD;
  const standardValue = raw && raw.standard ? raw.standard : defaultStandard;
  const standard = typeof standardValue === 'string' && standardValue.trim()
    ? standardValue.trim()
    : defaultStandard;
  const attachment = raw && raw.attachment
    ? normalizeAttachment(raw.attachment, category === 'procedee' ? 'procedeu.pdf' : 'autorizatie.pdf')
    : null;
  return {
    id,
    welder_id: welderId,
    category,
    standard,
    process: raw && raw.process ? raw.process : '',
    position: raw && raw.position ? raw.position : '',
    base_quality: raw && raw.base_quality ? raw.base_quality : '',
    base_material: raw && raw.base_material ? raw.base_material : '',
    filler_material: raw && raw.filler_material ? raw.filler_material : '',
    base_dimension: raw && raw.base_dimension ? raw.base_dimension : '',
    diameter: raw && raw.diameter ? raw.diameter : '',
    thickness_domain: raw && raw.thickness_domain ? raw.thickness_domain : '',
    observation: raw && raw.observation ? raw.observation : '',
    p_number: raw && raw.p_number ? raw.p_number : null,
    thickness_range: raw && raw.thickness_range ? raw.thickness_range : null,
    product: raw && raw.product ? raw.product : '',
    certificate_no: raw && raw.certificate_no ? raw.certificate_no : null,
    issuer: raw && raw.issuer ? raw.issuer : null,
    expiry_date: category === 'autorizatii' && raw && raw.expiry_date ? raw.expiry_date : null,
    procedure_id: procedureId,
    attachment,
  };
}

function normalizePanson(raw, options){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const code = raw.code !== undefined && raw.code !== null ? String(raw.code).trim() : '';
  if(!code){
    return null;
  }
  const idValue = Number(raw.id);
  const id = Number.isInteger(idValue) && idValue > 0 ? idValue : 0;
  const description = typeof raw.description === 'string' ? raw.description.trim() : '';
  const archivedFlag = options && options.archived ? true : Boolean(raw.archived);
  const archivedAt = raw.archived_at || null;
  return {
    id,
    code,
    description,
    archived: archivedFlag,
    archived_at: archivedFlag ? archivedAt : null,
  };
}

function normalizeArchivedEntry(raw){
  if(!raw || typeof raw !== 'object'){
    return null;
  }
  const welderSource = raw.welder && typeof raw.welder === 'object' ? raw.welder : raw;
  const welder = normalizeWelder(welderSource);
  if(!welder){
    return null;
  }
  const qualifications = Array.isArray(raw.qualifications)
    ? raw.qualifications.map(normalizeQualification).filter(Boolean)
    : [];
  return {
    welder,
    archived_at: raw.archived_at || null,
    qualifications,
    reason: typeof raw.reason === 'string' ? raw.reason : '',
  };
}

function createEmptyCompany(id, name){
  const numericId = Number.isInteger(id) && id > 0 ? id : 1;
  return {
    id: numericId,
    name: typeof name === 'string' && name.trim() ? name.trim() : `Companie ${numericId}`,
    welders: [],
    qualifications: [],
    archivedWelders: [],
    pansoane: [],
    archivedPansoane: [],
    logo: null,
    procedureDossier: [],
    authorizationDossiers: [],
    authorizationDossierArchive: [],
    authorizationDossierSettings: createDefaultAuthorizationDossierSettings(),
    reportBranding: { header: [], footer: [] },
    reportBrandingSpacing: 16,
    nextWelderId: 1,
    nextQualificationId: 1,
    nextPansonId: 1,
    nextAuthorizationDossierArchiveId: 1,
  };
}

function ensureCompanyShape(raw, fallbackId, fallbackName){
  const baseId = Number(raw && raw.id);
  const id = Number.isInteger(baseId) && baseId > 0
    ? baseId
    : (Number.isInteger(fallbackId) && fallbackId > 0 ? fallbackId : 1);
  const name = raw && typeof raw.name === 'string' && raw.name.trim()
    ? raw.name.trim()
    : (typeof fallbackName === 'string' && fallbackName.trim() ? fallbackName.trim() : `Companie ${id}`);

  const welders = [];
  let maxWelderId = 0;
  (Array.isArray(raw && raw.welders) ? raw.welders : []).forEach(item => {
    const normalized = normalizeWelder(item);
    if(!normalized){
      return;
    }
    if(normalized.id > 0 && !welders.some(existing => existing.id === normalized.id)){
      maxWelderId = Math.max(maxWelderId, normalized.id);
    } else {
      normalized.id = 0;
    }
    welders.push(normalized);
  });
  welders.forEach(w => {
    if(w.id <= 0){
      w.id = ++maxWelderId;
    }
  });

  const qualifications = [];
  let maxQualificationId = 0;
  const seenQualIds = new Set();
  (Array.isArray(raw && raw.qualifications) ? raw.qualifications : []).forEach(item => {
    const normalized = normalizeQualification(item);
    if(!normalized){
      return;
    }
    if(normalized.id > 0 && !seenQualIds.has(normalized.id)){
      seenQualIds.add(normalized.id);
      maxQualificationId = Math.max(maxQualificationId, normalized.id);
    } else {
      normalized.id = 0;
    }
    qualifications.push(normalized);
  });
  qualifications.forEach(q => {
    if(q.id <= 0){
      q.id = ++maxQualificationId;
      seenQualIds.add(q.id);
    }
  });

  const archivedWelders = (Array.isArray(raw && raw.archivedWelders) ? raw.archivedWelders : [])
    .map(normalizeArchivedEntry)
    .filter(Boolean);

  const pansoane = [];
  let maxPansonId = 0;
  (Array.isArray(raw && raw.pansoane) ? raw.pansoane : []).forEach(item => {
    const normalized = normalizePanson(item, { archived: false });
    if(!normalized){
      return;
    }
    normalized.archived = false;
    normalized.archived_at = null;
    if(normalized.id > 0 && !pansoane.some(existing => existing.id === normalized.id)){
      maxPansonId = Math.max(maxPansonId, normalized.id);
    } else {
      normalized.id = 0;
    }
    pansoane.push(normalized);
  });
  pansoane.forEach(p => {
    if(p.id <= 0){
      p.id = ++maxPansonId;
    }
  });

  const archivedPansoane = (Array.isArray(raw && raw.archivedPansoane) ? raw.archivedPansoane : [])
    .map(item => {
      const normalized = normalizePanson(item, { archived: true });
      if(!normalized){
        return null;
      }
      normalized.archived = true;
      return normalized;
    })
    .filter(Boolean);

  const nextWelderId = Number.isInteger(raw && raw.nextWelderId) && raw.nextWelderId > maxWelderId
    ? raw.nextWelderId
    : maxWelderId + 1;

  const nextQualificationId = Number.isInteger(raw && raw.nextQualificationId) && raw.nextQualificationId > maxQualificationId
    ? raw.nextQualificationId
    : maxQualificationId + 1;

  const nextPansonId = Number.isInteger(raw && raw.nextPansonId) && raw.nextPansonId > maxPansonId
    ? raw.nextPansonId
    : maxPansonId + 1;

  const logo = raw && raw.logo ? normalizeAttachment(raw.logo, 'logo') : null;
  const procedureDossier = Array.isArray(raw && raw.procedureDossier)
    ? raw.procedureDossier.map(item => normalizeDossierItem(item, 'document_omologare')).filter(Boolean)
    : [];
  const authorizationDossiers = Array.isArray(raw && raw.authorizationDossiers)
    ? raw.authorizationDossiers.map(normalizeAuthorizationDossier).filter(Boolean)
    : [];
  const authorizationArchiveRaw = Array.isArray(raw && raw.authorizationDossierArchive)
    ? raw.authorizationDossierArchive
    : [];
  const authorizationDossierArchive = authorizationArchiveRaw
    .map(normalizeAuthorizationArchiveEntry)
    .filter(Boolean);
  const rawSettings = raw && raw.authorizationDossierSettings && typeof raw.authorizationDossierSettings === 'object'
    ? raw.authorizationDossierSettings
    : raw && raw.authorizationDossierSettings === false
      ? { pageNumbering: false }
      : null;
  const authorizationDossierSettings = normalizeAuthorizationDossierSettings(rawSettings);
  let maxArchiveId = 0;
  authorizationDossierArchive.forEach(entry => {
    if(entry && entry.id && entry.id > maxArchiveId){
      maxArchiveId = entry.id;
    }
  });
  const reportBranding = normalizeReportBranding(raw && raw.reportBranding);
  const reportBrandingSpacing = clampBrandingSpacing(raw && raw.reportBrandingSpacing);
  const nextArchiveId = Number.isInteger(raw && raw.nextAuthorizationDossierArchiveId)
    && raw.nextAuthorizationDossierArchiveId > maxArchiveId
      ? raw.nextAuthorizationDossierArchiveId
      : maxArchiveId + 1;

  return {
    id,
    name,
    welders,
    qualifications,
    archivedWelders,
    pansoane,
    archivedPansoane,
    logo,
    procedureDossier,
    authorizationDossiers,
    authorizationDossierArchive,
    authorizationDossierSettings,
    reportBranding,
    reportBrandingSpacing,
    nextWelderId,
    nextQualificationId,
    nextPansonId,
    nextAuthorizationDossierArchiveId: nextArchiveId,
  };
}

function createDefaultState(){
  const company = createEmptyCompany(1, 'Companie implicitƒÉ');
  return {
    companies: [company],
    activeCompanyId: company.id,
    nextCompanyId: company.id + 1,
    standards: cloneBaseStandards(),
    generalSettings: normalizeGeneralSettings(),
  };
}

function deserializeStateFromObject(parsed){
  if(!parsed || typeof parsed !== 'object'){
    return null;
  }
  if(Array.isArray(parsed.companies)){
    const companies = parsed.companies.map((company, index) => ensureCompanyShape(
      company,
      Number(company && company.id) || index + 1,
      company && company.name ? company.name : `Companie ${index + 1}`
    )).filter(Boolean);
    if(companies.length === 0){
      const fallback = createEmptyCompany(1, 'Companie implicitƒÉ');
      companies.push(fallback);
    }
    const maxId = companies.reduce((max, company) => Math.max(max, company.id), 0);
    const parsedNextCompany = Number(parsed.nextCompanyId);
    const nextCompanyId = Number.isInteger(parsedNextCompany) && parsedNextCompany > maxId
      ? parsedNextCompany
      : maxId + 1;
    let activeCompanyId = Number(parsed.activeCompanyId) || (companies[0] ? companies[0].id : 1);
    if(!companies.some(company => company.id === activeCompanyId)){
      activeCompanyId = companies[0].id;
    }
    const standards = ensureStandards(parsed && parsed.standards);
    return {
      companies,
      activeCompanyId,
      nextCompanyId,
      standards,
      generalSettings: normalizeGeneralSettings(parsed.generalSettings),
    };
  }
  if(Array.isArray(parsed.welders) || Array.isArray(parsed.qualifications)){
    const legacyCompany = ensureCompanyShape({
      id: 1,
      name: parsed && typeof parsed.companyName === 'string' ? parsed.companyName : 'Companie implicitƒÉ',
      welders: parsed && parsed.welders,
      qualifications: parsed && parsed.qualifications,
      archivedWelders: parsed && parsed.archivedWelders,
      nextWelderId: parsed && parsed.nextWelderId,
      nextQualificationId: parsed && parsed.nextQualificationId,
    }, 1, 'Companie implicitƒÉ');
    return {
      companies: [legacyCompany],
      activeCompanyId: legacyCompany.id,
      nextCompanyId: legacyCompany.id + 1,
      standards: cloneBaseStandards(),
      generalSettings: normalizeGeneralSettings(parsed.generalSettings),
    };
  }
  return null;
}

function loadConfigSnapshot(){
  try {
    const raw = localStorage.getItem(STORAGE_CONFIG_KEY);
    if(!raw){
      return null;
    }
    const parsed = JSON.parse(raw);
    if(!parsed || typeof parsed !== 'object'){
      return null;
    }
    const generalSettings = normalizeGeneralSettings(parsed.generalSettings);
    return { generalSettings };
  } catch (err) {
    console.warn('Nu s-a putut citi configurarea aplica»õiei.', err);
    return null;
  }
}

function persistConfigurationSnapshot(){
  try {
    const settings = ensureGeneralSettings();
    const snapshot = {
      generalSettings: {
        inactivityMinutes: settings.inactivityMinutes,
        storageMode: settings.storageMode,
        storageFileName: settings.storageFileName || '',
        suspendLogin: !!settings.suspendLogin,
      },
    };
    localStorage.setItem(STORAGE_CONFIG_KEY, JSON.stringify(snapshot));
  } catch (err) {
    console.warn('Nu s-a putut salva configurarea aplica»õiei.', err);
  }
}

function loadState(){
  const config = loadConfigSnapshot();
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      const normalized = deserializeStateFromObject(parsed);
      if(normalized){
        if(config && config.generalSettings){
          normalized.generalSettings = normalizeGeneralSettings({
            ...normalized.generalSettings,
            ...config.generalSettings,
          });
        }
        return normalized;
      }
    }
  } catch (err) {
    console.warn('Nu se pot √ÆncƒÉrca datele din localStorage.', err);
  }
  const fallback = createDefaultState();
  if(config && config.generalSettings){
    fallback.generalSettings = config.generalSettings;
  }
  return fallback;
}

function getActiveCompany(){
  if(!state || !Array.isArray(state.companies)){
    state = createDefaultState();
  }
  let company = state.companies.find(entry => entry.id === state.activeCompanyId);
  if(!company){
    if(state.companies.length === 0){
      const fallback = createEmptyCompany(state.nextCompanyId || 1, 'Companie implicitƒÉ');
      state.companies.push(fallback);
      state.activeCompanyId = fallback.id;
      if(!state.nextCompanyId || state.nextCompanyId <= fallback.id){
        state.nextCompanyId = fallback.id + 1;
      }
      persistState();
      return fallback;
    }
    company = state.companies[0];
    state.activeCompanyId = company.id;
    persistState();
  }
  return company;
}

function getCompanyById(id){
  if(!state || !Array.isArray(state.companies)){
    return null;
  }
  const numeric = Number(id);
  if(Number.isNaN(numeric)){
    return null;
  }
  return state.companies.find(entry => entry.id === numeric) || null;
}

function persistState(){
  persistConfigurationSnapshot();
  if(isFileStorageMode()){
    try {
      localStorage.removeItem(STORAGE_KEY);
    } catch (err) {
      console.warn('Nu s-a putut curƒÉ»õa copia din localStorage.', err);
    }
    persistStateToFile();
    return;
  }
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (err) {
    console.error('Nu pot salva datele √Æn localStorage.', err);
    alert('Nu s-au putut salva datele √Æn browser. VerificƒÉ spa»õiul disponibil sau permisiunile.');
  }
}

function isFileStorageSupported(){
  return typeof window !== 'undefined'
    && (typeof window.showSaveFilePicker === 'function' || typeof window.showOpenFilePicker === 'function');
}

function isHandlePersistenceSupported(){
  return typeof indexedDB !== 'undefined' && !!indexedDB;
}

function openStorageHandleDb(){
  return new Promise((resolve, reject) => {
    if(!isHandlePersistenceSupported()){
      reject(new Error('IndexedDB indisponibil pentru stocarea handlerelor.'));
      return;
    }
    const request = indexedDB.open(STORAGE_HANDLE_DB_NAME, 1);
    request.onupgradeneeded = () => {
      try {
        const db = request.result;
        if(db && !db.objectStoreNames.contains(STORAGE_HANDLE_STORE)){
          db.createObjectStore(STORAGE_HANDLE_STORE);
        }
      } catch (err) {
        console.warn('Nu s-a putut crea store-ul pentru handler-ele de fi»ôiere.', err);
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function idbRequestToPromise(request){
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function idbTransactionDone(tx){
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
    tx.onerror = () => reject(tx.error || new Error('Transaction error'));
  });
}

async function persistHandleInStore(key, handle){
  if(!isHandlePersistenceSupported()){
    return;
  }
  try {
    const db = await openStorageHandleDb();
    const tx = db.transaction(STORAGE_HANDLE_STORE, 'readwrite');
    tx.objectStore(STORAGE_HANDLE_STORE).put(handle, key);
    await idbTransactionDone(tx);
    db.close();
  } catch (err) {
    console.warn('Nu s-a putut salva referin»õa cƒÉtre fi»ôier/folder.', err);
  }
}

async function removeHandleFromStore(key){
  if(!isHandlePersistenceSupported()){
    return;
  }
  try {
    const db = await openStorageHandleDb();
    const tx = db.transaction(STORAGE_HANDLE_STORE, 'readwrite');
    tx.objectStore(STORAGE_HANDLE_STORE).delete(key);
    await idbTransactionDone(tx);
    db.close();
  } catch (err) {
    console.warn('Nu s-a putut curƒÉ»õa referin»õa salvatƒÉ.', err);
  }
}

async function loadHandleFromStore(key){
  if(!isHandlePersistenceSupported()){
    return null;
  }
  try {
    const db = await openStorageHandleDb();
    const tx = db.transaction(STORAGE_HANDLE_STORE, 'readonly');
    const request = tx.objectStore(STORAGE_HANDLE_STORE).get(key);
    const result = await idbRequestToPromise(request);
    await idbTransactionDone(tx);
    db.close();
    return result || null;
  } catch (err) {
    console.warn('Nu s-a putut √ÆncƒÉrca referin»õa salvatƒÉ.', err);
    return null;
  }
}

async function clearPersistedStorageHandles(){
  await Promise.all([
    removeHandleFromStore(STORAGE_FILE_HANDLE_KEY),
    removeHandleFromStore(STORAGE_DIRECTORY_HANDLE_KEY),
  ]);
}

async function persistStoredFileHandle(handle){
  if(!handle){
    await removeHandleFromStore(STORAGE_FILE_HANDLE_KEY);
    return;
  }
  await persistHandleInStore(STORAGE_FILE_HANDLE_KEY, handle);
}

async function persistStoredDirectoryHandle(handle){
  if(!handle){
    await removeHandleFromStore(STORAGE_DIRECTORY_HANDLE_KEY);
    return;
  }
  await persistHandleInStore(STORAGE_DIRECTORY_HANDLE_KEY, handle);
}

async function ensureStorageFileHandle(){
  if(storageFileHandle){
    return storageFileHandle;
  }
  if(!storageDirectoryHandle){
    return null;
  }
  try {
    const preferredName = getStorageFileName() || DEFAULT_STORAGE_FILE_NAME;
    const handle = await storageDirectoryHandle.getFileHandle(preferredName, { create: true });
    storageFileHandle = handle;
    applyStorageFileName(handle.name || preferredName);
    await persistStoredFileHandle(handle);
    return storageFileHandle;
  } catch (err) {
    console.warn('Nu s-a putut ob»õine fi»ôierul bazei de date din folderul selectat.', err);
    return null;
  }
}

async function resolveDirectoryDatabaseFile(dirHandle){
  if(!dirHandle || typeof dirHandle.getFileHandle !== 'function'){
    return { handle: null, existed: false };
  }
  const preferredName = getStorageFileName() || DEFAULT_STORAGE_FILE_NAME;
  const tryGetExisting = async name => {
    if(!name){
      return null;
    }
    try {
      return await dirHandle.getFileHandle(name);
    } catch (error) {
      if(error && error.name !== 'NotFoundError'){
        console.warn('Nu s-a putut accesa fi»ôierul din folderul selectat.', error);
      }
      return null;
    }
  };
  let handle = await tryGetExisting(preferredName);
  if(handle){
    return { handle, existed: true };
  }
  const visitDirectoryEntries = async iterator => {
    try {
      for await (const entry of iterator){
        if(!entry){
          continue;
        }
        const entryName = entry.name || (Array.isArray(entry) ? entry[0] : null);
        const entryValue = Array.isArray(entry) ? entry[1] : entry;
        const kind = entryValue && entryValue.kind ? entryValue.kind : 'file';
        if(kind !== 'file' || !entryName){
          continue;
        }
        if(String(entryName).toLowerCase().endsWith('.json')){
          const candidate = await tryGetExisting(entryName);
          if(candidate){
            return candidate;
          }
        }
      }
    } catch (error) {
      console.warn('Nu s-a putut parcurge folderul bazei de date.', error);
    }
    return null;
  };
  if(typeof dirHandle.values === 'function'){
    const found = await visitDirectoryEntries(dirHandle.values());
    if(found){
      return { handle: found, existed: true };
    }
  } else if(typeof dirHandle.entries === 'function'){
    const found = await visitDirectoryEntries(dirHandle.entries());
    if(found){
      return { handle: found, existed: true };
    }
  }
  const fallbackName = preferredName || DEFAULT_STORAGE_FILE_NAME;
  try {
    handle = await dirHandle.getFileHandle(fallbackName, { create: true });
    return { handle, existed: false };
  } catch (error) {
    console.warn('Nu s-a putut crea fi»ôierul bazei de date √Æn folderul selectat.', error);
    return { handle: null, existed: false };
  }
}

async function restorePersistedStorageHandles(){
  if(!isFileStorageSupported() || !isHandlePersistenceSupported()){
    return;
  }
  try {
    storageNeedsReconnect = false;
    const [savedDirectory, savedFile] = await Promise.all([
      loadHandleFromStore(STORAGE_DIRECTORY_HANDLE_KEY),
      loadHandleFromStore(STORAGE_FILE_HANDLE_KEY),
    ]);
    if(savedDirectory){
      const canUseDirectory = await ensureFilePermission(savedDirectory, 'read');
      if(canUseDirectory){
        storageDirectoryHandle = savedDirectory;
        if(savedDirectory.name){
          applyStorageDirectoryName(savedDirectory.name);
        }
      }
      if(!storageDirectoryHandle){
        storageNeedsReconnect = true;
      }
    }
    if(savedFile){
      const canUseFile = await ensureFilePermission(savedFile, 'read');
      if(canUseFile){
        storageFileHandle = savedFile;
      }
      if(!storageFileHandle){
        storageNeedsReconnect = true;
      }
    }
    if(!storageFileHandle && storageDirectoryHandle){
      const ensured = await ensureStorageFileHandle();
      if(!ensured){
        storageNeedsReconnect = true;
      }
    }
    if(storageFileHandle && storageFileHandle.name){
      applyStorageFileName(storageFileHandle.name);
    }
    if(storageDirectoryHandle && storageDirectoryHandle.name){
      applyStorageDirectoryName(storageDirectoryHandle.name);
    }
    if(storageNeedsReconnect){
      renderStorageSettings();
    }
  } catch (err) {
    console.warn('Nu s-au putut restaura handler-ele salvate.', err);
  }
}

async function ensureFilePermission(handle, mode){
  if(!handle || typeof handle.queryPermission !== 'function'){
    return true;
  }
  try {
    const descriptor = { mode };
    let result = await handle.queryPermission(descriptor);
    if(result === 'granted'){
      return true;
    }
    if(result === 'denied'){
      return false;
    }
    if(typeof handle.requestPermission === 'function'){
      result = await handle.requestPermission(descriptor);
      return result === 'granted';
    }
  } catch (err) {
    console.warn('Nu s-a putut verifica permisiunea pentru fi»ôier.', err);
  }
  return false;
}

async function persistStateToFile(){
  if(!isFileStorageSupported()){
    alert('Browserul nu suportƒÉ salvarea direct √Æn fi»ôiere. SelecteazƒÉ stocarea √Æn browser sau folose»ôte un browser compatibil.');
    return;
  }
  try {
    const handle = storageFileHandle || await ensureStorageFileHandle();
    if(!handle){
      console.warn('Nu existƒÉ un fi»ôier selectat pentru stocarea localƒÉ.');
      if(isFileStorageMode()){
        const status = document.getElementById('storage_file_status');
        if(status){
          status.textContent = 'SelecteazƒÉ un fi»ôier sau un folder pentru a salva datele local.';
        }
      }
      if(!fileStorageMissingFileWarned){
        alert('Nu s-au putut salva datele deoarece nu este selectat niciun fi»ôier. Alege un fi»ôier sau conecteazƒÉ folderul din setƒÉri.');
        fileStorageMissingFileWarned = true;
      }
      return;
    }
    fileStorageMissingFileWarned = false;
    await writeStateToFile();
  } catch (err) {
    console.error('Nu s-a putut actualiza fi»ôierul bazei de date.', err);
    alert('Nu s-a putut actualiza fi»ôierul bazei de date. VerificƒÉ permisiunile »ôi spa»õiul disponibil.');
  }
}

async function writeStateToFile(){
  const canWrite = await ensureFilePermission(storageFileHandle, 'readwrite');
  if(!canWrite){
    alert('Aplica»õia nu are permisiunea de a scrie √Æn fi»ôierul selectat. SelecteazƒÉ din nou fi»ôierul din setƒÉri.');
    return;
  }
  const writable = await storageFileHandle.createWritable();
  await writable.write(JSON.stringify(state, null, 2));
  await writable.close();
}

function applyStorageFileName(name){
  const settings = ensureGeneralSettings();
  const safeName = typeof name === 'string' ? name : '';
  if(settings.storageFileName !== safeName){
    settings.storageFileName = safeName;
  }
  fileStorageMissingFileWarned = false;
  persistConfigurationSnapshot();
  renderStorageSettings();
  updateStorageModeIndicators();
}

function applyStorageDirectoryName(name){
  const settings = ensureGeneralSettings();
  const safeName = typeof name === 'string' ? name : '';
  if(settings.storageDirectoryName !== safeName){
    settings.storageDirectoryName = safeName;
  }
  persistConfigurationSnapshot();
  renderStorageSettings();
  updateStorageModeIndicators();
}

function setStorageMode(value, options){
  const settings = ensureGeneralSettings();
  const normalized = value === STORAGE_MODE_FILE ? STORAGE_MODE_FILE : STORAGE_MODE_BROWSER;
  const changed = settings.storageMode !== normalized;
  if(changed){
    settings.storageMode = normalized;
    if(normalized !== STORAGE_MODE_FILE){
      storageFileHandle = null;
      storageDirectoryHandle = null;
      settings.storageFileName = '';
      settings.storageDirectoryName = '';
      clearPersistedStorageHandles().catch(err => console.warn('Nu s-au putut curƒÉ»õa referin»õele la fi»ôiere.', err));
    }
  }
  persistConfigurationSnapshot();
  if(changed && !(options && options.skipPersist)){
    persistState();
    renderGeneralSettings();
    return normalized;
  }
  renderGeneralSettings();
  return normalized;
}

async function handleStorageFilePick(){
  if(!isFileStorageSupported()){
    alert('Browserul curent nu suportƒÉ salvarea directƒÉ √Æn fi»ôiere. Folose»ôte un browser compatibil (Chrome, Edge) sau stocarea √Æn browser.');
    return;
  }
  try {
    const handle = typeof window.showSaveFilePicker === 'function'
      ? await window.showSaveFilePicker({
        suggestedName: getStorageFileName() || 'gestiune_sudori.json',
        types: DATABASE_FILE_TYPES,
      })
      : (await window.showOpenFilePicker({ multiple: false, types: DATABASE_FILE_TYPES }))[0];
    if(!handle){
      return;
    }
    const canWrite = await ensureFilePermission(handle, 'readwrite');
    if(!canWrite){
      await persistStoredFileHandle(null);
      await persistStoredDirectoryHandle(null);
      storageFileHandle = null;
      storageDirectoryHandle = null;
      applyStorageDirectoryName('');
      applyStorageFileName('');
      alert('Aplica»õia nu are permisiunea de a accesa fi»ôierul selectat. √éncearcƒÉ din nou »ôi acordƒÉ permisiunea necesarƒÉ.');
      return;
    }
    storageFileHandle = handle;
    storageDirectoryHandle = null;
    storageNeedsReconnect = false;
    applyStorageDirectoryName('');
    await persistStoredDirectoryHandle(null);
    await persistStoredFileHandle(handle);
    const fileName = handle.name || DEFAULT_STORAGE_FILE_NAME;
    applyStorageFileName(fileName);
    setStorageMode(STORAGE_MODE_FILE, { skipPersist: true });
    let existingBytes = 0;
    try {
      const file = await handle.getFile();
      existingBytes = file && file.size ? file.size : 0;
    } catch (sizeError) {
      console.warn('Nu s-a putut verifica dimensiunea fi»ôierului selectat.', sizeError);
    }
    await refreshAllFromStorage();
    persistState();
    if(existingBytes > 0){
      alert('Fi»ôierul selectat a fost conectat. Datele au fost √ÆncƒÉrcate »ôi vor fi salvate automat.');
    } else {
      alert('Fi»ôierul selectat a fost conectat. Datele curente vor fi salvate automat √Æn acest fi»ôier.');
    }
  } catch (err) {
    if(err && err.name === 'AbortError'){
      return;
    }
    storageFileHandle = null;
    storageDirectoryHandle = null;
    await persistStoredFileHandle(null);
    await persistStoredDirectoryHandle(null);
    applyStorageDirectoryName('');
    applyStorageFileName('');
    console.error('Nu s-a putut selecta fi»ôierul bazei de date.', err);
    alert('Nu s-a putut selecta fi»ôierul bazei de date. √éncearcƒÉ din nou.');
  }
}

async function handleStorageFolderPick(){
  if(!isFileStorageSupported() || typeof window.showDirectoryPicker !== 'function'){
    alert('Browserul curent nu permite conectarea directƒÉ la un folder. ActualizeazƒÉ browserul sau folose»ôte stocarea √Æn browser.');
    return;
  }
  try {
    const dirHandle = await window.showDirectoryPicker();
    if(!dirHandle){
      return;
    }
    const canAccess = await ensureFilePermission(dirHandle, 'readwrite');
    if(!canAccess){
      alert('Aplica»õia nu are permisiunea de a accesa folderul selectat. √éncearcƒÉ din nou »ôi acordƒÉ accesul necesar.');
      return;
    }
    const { handle: fileHandle, existed } = await resolveDirectoryDatabaseFile(dirHandle);
    if(!fileHandle){
      alert('Nu s-a putut identifica fi»ôierul bazei de date din folderul selectat.');
      return;
    }
    storageDirectoryHandle = dirHandle;
    storageFileHandle = fileHandle;
    storageNeedsReconnect = false;
    await persistStoredDirectoryHandle(dirHandle);
    await persistStoredFileHandle(fileHandle);
    applyStorageDirectoryName(dirHandle.name || '');
    const fileName = fileHandle.name || getStorageFileName() || DEFAULT_STORAGE_FILE_NAME;
    applyStorageFileName(fileName);
    setStorageMode(STORAGE_MODE_FILE, { skipPersist: true });
    let existingBytes = 0;
    try {
      const file = await fileHandle.getFile();
      existingBytes = file && file.size ? file.size : 0;
    } catch (sizeError) {
      console.warn('Nu s-a putut verifica dimensiunea fi»ôierului din folderul selectat.', sizeError);
    }
    await refreshAllFromStorage();
    persistState();
    if(existed || existingBytes > 0){
      alert('Folderul selectat a fost conectat. Datele au fost √ÆncƒÉrcate automat »ôi vor fi salvate √Æn continuare √Æn acest fi»ôier.');
    } else {
      alert('Folderul selectat a fost conectat. S-a creat un fi»ôier nou pentru bazƒÉ de date »ôi datele vor fi salvate automat.');
    }
  } catch (err) {
    if(err && err.name === 'AbortError'){
      return;
    }
    storageDirectoryHandle = null;
    storageFileHandle = null;
    await persistStoredDirectoryHandle(null);
    await persistStoredFileHandle(null);
    applyStorageDirectoryName('');
    applyStorageFileName('');
    console.error('Nu s-a putut conecta folderul bazei de date.', err);
    alert('Nu s-a putut conecta folderul ales. VerificƒÉ permisiunile »ôi √ÆncearcƒÉ din nou.');
  }
}

async function handleStorageFileLoad(){
  if(!isFileStorageSupported()){
    alert('Browserul curent nu suportƒÉ citirea directƒÉ din fi»ôiere. Folose»ôte un browser compatibil sau importƒÉ manual fi»ôierul JSON.');
    return;
  }
  try {
    const pickerResult = typeof window.showOpenFilePicker === 'function'
      ? await window.showOpenFilePicker({ multiple: false, types: DATABASE_FILE_TYPES })
      : [await window.showSaveFilePicker({ types: DATABASE_FILE_TYPES })];
    const handle = pickerResult && pickerResult[0];
    if(!handle){
      return;
    }
    const canReadWrite = await ensureFilePermission(handle, 'readwrite');
    if(!canReadWrite){
      await persistStoredFileHandle(null);
      await persistStoredDirectoryHandle(null);
      storageFileHandle = null;
      storageDirectoryHandle = null;
      applyStorageDirectoryName('');
      applyStorageFileName('');
      alert('Aplica»õia nu are permisiunea de a accesa fi»ôierul selectat. √éncearcƒÉ din nou »ôi acordƒÉ permisiunile necesare.');
      return;
    }
    storageFileHandle = handle;
    storageDirectoryHandle = null;
    storageNeedsReconnect = false;
    applyStorageDirectoryName('');
    const file = await handle.getFile();
    const text = await file.text();
    const parsed = JSON.parse(text);
    await persistStoredDirectoryHandle(null);
    await persistStoredFileHandle(handle);
    applyStorageFileName(handle.name || DEFAULT_STORAGE_FILE_NAME);
    setStorageMode(STORAGE_MODE_FILE, { skipPersist: true });
    importStatePayload(parsed);
    alert('Baza de date a fost √ÆncƒÉrcatƒÉ cu succes din fi»ôierul selectat.');
  } catch (err) {
    if(err && err.name === 'AbortError'){
      return;
    }
    storageFileHandle = null;
    storageDirectoryHandle = null;
    await persistStoredFileHandle(null);
    await persistStoredDirectoryHandle(null);
    applyStorageDirectoryName('');
    applyStorageFileName('');
    console.error('Nu s-a putut √ÆncƒÉrca fi»ôierul bazei de date.', err);
    alert('Nu s-a putut √ÆncƒÉrca fi»ôierul selectat. VerificƒÉ formatul JSON »ôi √ÆncearcƒÉ din nou.');
  }
}

async function reconnectPersistedStorage(){
  if(!isFileStorageMode()){
    alert('Modul de stocare √Æn fi»ôier nu este activ. SelecteazƒÉ op»õiunea ‚ÄûFi»ôier local‚Äù din setƒÉri.');
    return;
  }
  if(!isFileStorageSupported()){
    alert('Browserul curent nu suportƒÉ reconectarea automatƒÉ a folderelor.');
    return;
  }
  if(!storageDirectoryHandle && !storageFileHandle){
    alert('Nu existƒÉ niciun folder sau fi»ôier memorat. SelecteazƒÉ din nou folderul bazei de date.');
    return;
  }
  try {
    if(storageDirectoryHandle){
      const hasDirPermission = await ensureFilePermission(storageDirectoryHandle, 'readwrite');
      if(!hasDirPermission){
        alert('Permisiunea pentru folder nu a fost acordatƒÉ. SelecteazƒÉ din nou folderul bazei de date.');
        storageNeedsReconnect = true;
        renderStorageSettings();
        return;
      }
    }
    if(storageFileHandle){
      const hasFilePermission = await ensureFilePermission(storageFileHandle, 'readwrite');
      if(!hasFilePermission){
        alert('Permisiunea pentru fi»ôier nu a fost acordatƒÉ. SelecteazƒÉ din nou fi»ôierul bazei de date.');
        storageNeedsReconnect = true;
        renderStorageSettings();
        return;
      }
    } else if(storageDirectoryHandle){
      await ensureStorageFileHandle();
    }
    if(storageFileHandle){
      await reloadStateFromFile();
      storageNeedsReconnect = false;
      if(storageFileHandle.name){
        applyStorageFileName(storageFileHandle.name);
      }
      if(storageDirectoryHandle && storageDirectoryHandle.name){
        applyStorageDirectoryName(storageDirectoryHandle.name);
      }
      renderStorageSettings();
      alert('Folderul bazei de date a fost reconectat. Datele vor fi salvate automat.');
    } else {
      alert('Nu s-a putut identifica fi»ôierul bazei de date din folderul selectat. SelecteazƒÉ din nou folderul.');
    }
  } catch (err) {
    console.error('Nu s-a putut reconecta folderul bazei de date.', err);
    storageNeedsReconnect = true;
    renderStorageSettings();
    alert('Nu s-a putut reconecta folderul selectat. SelecteazƒÉ din nou folderul bazei de date.');
  }
}

async function reloadStateFromFile(){
  if(!isFileStorageMode() || !isFileStorageSupported() || !storageFileHandle){
    return;
  }
  try {
    const canRead = await ensureFilePermission(storageFileHandle, 'read');
    if(!canRead){
      return;
    }
    const file = await storageFileHandle.getFile();
    const text = await file.text();
    const parsed = JSON.parse(text);
    const normalized = deserializeStateFromObject(parsed);
    if(normalized){
      state = normalized;
    }
  } catch (err) {
    console.warn('Nu s-a putut re√ÆncƒÉrca fi»ôierul bazei de date.', err);
  }
}

function exportState(){
  try {
    persistState();
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const stamp = new Date().toISOString().replace(/[:.]/g, '-');
    const a = document.createElement('a');
    a.href = url;
    a.download = `gestiune_sudori_${stamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error('Exportul a e»ôuat.', err);
    alert('Nu s-a putut genera fi»ôierul. √éncearcƒÉ din nou.');
  }
}

function importStatePayload(payload){
  const normalized = deserializeStateFromObject(payload);
  if(!normalized){
    throw new Error('StructurƒÉ de date invalidƒÉ.');
  }
  state = normalized;
  ensureStateStandards();
  syncStandardsFromState();
  ensureGeneralSettings();
  selectedWelder = null;
  selectedWelderPosition = null;
  activeAuthorizationDossierId = null;
  persistState();
  refreshAllFromStorage();
}

function handleImportStateFile(event){
  const input = event.target;
  if(!input || !input.files || !input.files[0]){
    return;
  }
  if(!confirm('Importul bazei de date va √Ænlocui toate datele existente. Continui?')){
    input.value = '';
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = typeof reader.result === 'string'
        ? reader.result
        : String(reader.result || '');
      const parsed = JSON.parse(text);
      importStatePayload(parsed);
      alert('Baza de date a fost importatƒÉ cu succes.');
    } catch (err) {
      console.error('Importul bazei de date a e»ôuat.', err);
      alert('Fi»ôierul selectat nu a putut fi importat. VerificƒÉ formatul JSON.');
    } finally {
      input.value = '';
    }
  };
  reader.onerror = () => {
    console.error('Nu s-a putut citi fi»ôierul selectat pentru import.');
    alert('Citirea fi»ôierului a e»ôuat. √éncearcƒÉ din nou.');
    input.value = '';
  };
  reader.readAsText(file);
}

function escapeHtml(value){
  var safeValue = value === undefined || value === null ? '' : value;
  return String(safeValue).replace(/[&<>"']/g, function(ch){
    return ESCAPE_MAP[ch];
  });
}

function setButtonTextWithIcon(element, label, iconType){
  if(!element){
    return null;
  }
  const text = label !== undefined && label !== null ? String(label) : '';
  element.textContent = text;
  if(iconType){
    element.setAttribute('data-icon', iconType);
  } else {
    element.removeAttribute('data-icon');
  }
  return element;
}

function createAttachmentActionsHtml(attachment, options){
  if(!attachment || !attachment.data){
    return '';
  }
  const attachmentId = registerAttachment(attachment);
  const viewLabel = options && options.viewLabel
    ? options.viewLabel
    : (options && options.label ? options.label : 'VizualizeazƒÉ');
  const downloadLabel = options && options.downloadLabel ? options.downloadLabel : 'DescarcƒÉ';
  const fallbackName = options && options.fallbackName ? options.fallbackName : 'document.pdf';
  const name = attachment.name || fallbackName;
  const safeName = escapeHtml(name);
  const href = escapeHtml(attachment.data);
  const safeView = escapeHtml(viewLabel);
  const safeDownload = escapeHtml(downloadLabel);
  return `<div class="attachment-actions"><button type="button" class="btn ghost small" data-icon="view" data-attachment-view="${attachmentId}" data-attachment-name="${safeName}">${safeView}</button><a class="btn secondary small" data-icon="download" href="${href}" download="${safeName}">${safeDownload}</a></div>`;
}

function createAttachmentActionsNode(attachment, options){
  const html = createAttachmentActionsHtml(attachment, options);
  if(!html){
    return null;
  }
  const wrapper = document.createElement('div');
  wrapper.innerHTML = html.trim();
  return wrapper.firstElementChild;
}

function openDocumentViewer(attachment, title){
  const safeTitle = title || (attachment && attachment.name) || 'Document';
  if(!attachment || !attachment.data){
    alert('Documentul nu este disponibil pentru vizualizare.');
    return;
  }
  let objectUrl = null;
  try {
    objectUrl = dataUrlToObjectUrl(attachment.data);
  } catch (err) {
    console.warn('Nu s-a putut crea URL-ul temporar pentru document.', err);
  }
  const viewerUrl = objectUrl || attachment.data;
  let viewerWindow = null;
  try {
    viewerWindow = window.open('', '_blank');
  } catch (err) {
    console.warn('Nu s-a putut deschide fereastra de previzualizare.', err);
  }
  if(viewerWindow){
    try {
      viewerWindow.document.title = safeTitle;
      viewerWindow.document.body.style.margin = '0';
      viewerWindow.document.body.style.height = '100vh';
      const isImage = (attachment.type && attachment.type.startsWith('image/')) || attachment.data.startsWith('data:image');
      if(isImage){
        viewerWindow.document.body.innerHTML = `<img src="${viewerUrl}" alt="${escapeHtml(safeTitle)}" style="display:block;width:100%;height:auto;object-fit:contain;" />`;
      } else {
        const mime = escapeHtml(attachment.type || 'application/pdf');
        viewerWindow.document.body.innerHTML = `<embed src="${viewerUrl}#toolbar=1&view=Fit" type="${mime}" style="width:100%;height:100%;" />`;
      }
      if(objectUrl && objectUrl.startsWith('blob:')){
        viewerWindow.addEventListener('beforeunload', () => {
          try { URL.revokeObjectURL(objectUrl); } catch (err) { console.warn('Nu s-a putut elibera URL-ul previzualizƒÉrii.', err); }
        }, { once: true });
      }
      return;
    } catch (err) {
      console.error('Previzualizarea √Æntr-o fereastrƒÉ nouƒÉ a e»ôuat. Se folose»ôte varianta fallback.', err);
    }
  }
  const modal = document.getElementById('document_viewer');
  const body = document.getElementById('document_viewer_body');
  const headerTitle = document.getElementById('document_viewer_title');
  if(!modal || !body){
    return;
  }
  if(activeViewerUrl){
    try { URL.revokeObjectURL(activeViewerUrl); } catch (err) { console.warn('Nu s-a putut revoca URL-ul temporar.', err); }
    activeViewerUrl = null;
  }
  body.innerHTML = '';
  if(headerTitle){
    headerTitle.textContent = safeTitle;
  }
  const type = attachment.type || '';
  let node = null;
  if(type.startsWith('image/') || attachment.data.startsWith('data:image')){
    const img = document.createElement('img');
    img.src = attachment.data;
    img.alt = safeTitle;
    node = img;
  } else {
    const fallbackUrl = objectUrl || attachment.data;
    if(fallbackUrl && fallbackUrl.startsWith('blob:')){
      activeViewerUrl = fallbackUrl;
    }
    const frame = document.createElement('iframe');
    frame.src = fallbackUrl;
    frame.title = safeTitle;
    node = frame;
  }
  if(!node){
    const fallback = document.createElement('p');
    fallback.className = 'section-text';
    fallback.textContent = 'Documentul nu a putut fi afi»ôat.';
    node = fallback;
  }
  body.appendChild(node);
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
  document.body.dataset.viewerOpen = 'true';
  document.body.style.overflow = 'hidden';
}

function closeDocumentViewer(){
  const modal = document.getElementById('document_viewer');
  const body = document.getElementById('document_viewer_body');
  if(activeViewerUrl){
    try { URL.revokeObjectURL(activeViewerUrl); } catch (err) { console.warn('Nu s-a putut revoca URL-ul temporar.', err); }
    activeViewerUrl = null;
  }
  if(body){
    body.innerHTML = '';
  }
  if(modal){
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
  }
  if(document.body.dataset.viewerOpen){
    delete document.body.dataset.viewerOpen;
  }
  if(!document.body.dataset.welderModalOpen && !document.body.dataset.brandingModalOpen){
    document.body.style.overflow = '';
  }
}

function statusBadge(expiry){
  if(!expiry){
    return '<span class="status warn">n/a</span>';
  }
  const d = new Date(expiry);
  if(Number.isNaN(d.getTime())){
    return '<span class="status warn">n/a</span>';
  }
  const today = new Date();
  today.setHours(0,0,0,0);
  d.setHours(0,0,0,0);
  const diff = Math.ceil((d - today) / (1000*60*60*24));
  if(diff < 0) return '<span class="status bad">expirat</span>';
  if(diff <= 30) return '<span class="status warn">aproape expirat</span>';
  return '<span class="status ok">activ</span>';
}

function getExpiryStatus(expiry){
  if(!expiry){
    return 'ok';
  }
  const d = new Date(expiry);
  if(Number.isNaN(d.getTime())){
    return 'warn';
  }
  const today = new Date();
  today.setHours(0,0,0,0);
  d.setHours(0,0,0,0);
  const diff = Math.ceil((d - today) / (1000*60*60*24));
  if(diff < 0){
    return 'bad';
  }
  if(diff <= 30){
    return 'warn';
  }
  return 'ok';
}

function buildWelderQualificationSummaries(welderId, company){
  const context = company || getActiveCompany();
  if(!context || !welderId){
    return {
      statusHtml: '<span class="muted">FƒÉrƒÉ autorizƒÉri</span>',
      processHtml: '<span class="muted">‚Äî</span>',
    };
  }
  const entries = context.qualifications.filter(q => q.welder_id === welderId && q.category === 'autorizatii');
  if(entries.length === 0){
    return {
      statusHtml: '<span class="muted">FƒÉrƒÉ autorizƒÉri</span>',
      processHtml: '<span class="muted">‚Äî</span>',
    };
  }
  const sorted = entries.slice().sort((a, b) => {
    const aDate = a && a.expiry_date ? a.expiry_date : '';
    const bDate = b && b.expiry_date ? b.expiry_date : '';
    return aDate.localeCompare(bDate);
  });
  const statusHtml = sorted.map(q => {
    const status = getExpiryStatus(q && q.expiry_date ? q.expiry_date : null);
    const standardLabel = escapeHtml(getStandardLabel(q && q.standard ? q.standard : ''));
    const expiryText = q && q.expiry_date ? ` ¬∑ ${escapeHtml(q.expiry_date)}` : ' ¬∑ fƒÉrƒÉ termen';
    return `<span class="status-chip ${status}"><span class="dot"></span>${standardLabel}${expiryText}</span>`;
  }).join('');
  const processHtml = sorted.map(q => {
    const status = getExpiryStatus(q && q.expiry_date ? q.expiry_date : null);
    const processParts = [];
    if(q && q.process){
      processParts.push(escapeHtml(q.process));
    }
    const procedureLabel = resolveProcedureLabel(context, q && q.procedure_id ? q.procedure_id : null);
    if(procedureLabel){
      processParts.push(escapeHtml(procedureLabel));
    }
    const label = processParts.length ? processParts.join(' ¬∑ ') : '‚Äî';
    return `<span class="status-chip ${status}"><span class="dot"></span>${label}</span>`;
  }).join('');
  return {
    statusHtml,
    processHtml,
  };
}

function computeWelderStats(welderId){
  const company = getActiveCompany();
  const list = company.qualifications.filter(q => q.welder_id === welderId && q.category === 'autorizatii');
  const today = new Date();
  today.setHours(0,0,0,0);
  let activeCount = 0;
  let nextExpiring = null;

  list.forEach(q => {
    if(!q.expiry_date){
      activeCount += 1;
      return;
    }
    const exp = new Date(q.expiry_date);
    if(Number.isNaN(exp.getTime())){
      return;
    }
    exp.setHours(0,0,0,0);
    if(exp >= today){
      activeCount += 1;
    }
    if(!nextExpiring || exp < nextExpiring){
      nextExpiring = exp;
    }
  });

  return {
    activeCount,
    nextExpiring: nextExpiring ? nextExpiring.toISOString().slice(0,10) : '',
  };
}

function sortWelders(list){
  return [].concat(list).sort(function(a, b){
    const nameA = a && a.name ? a.name : '';
    const nameB = b && b.name ? b.name : '';
    return nameA.localeCompare(nameB, 'ro', { sensitivity: 'base' });
  });
}

function getWelderPosition(welderId){
  const company = getActiveCompany();
  const ordered = sortWelders(company.welders);
  const index = ordered.findIndex(w => w.id === welderId);
  return index === -1 ? null : index + 1;
}

function findWelderNameById(welderId){
  if(welderId === null || welderId === undefined){
    return '';
  }
  if(!state || !Array.isArray(state.companies)){
    return '';
  }
  for(const company of state.companies){
    if(!company){
      continue;
    }
    const activeMatch = Array.isArray(company.welders)
      ? company.welders.find(w => w && w.id === welderId)
      : null;
    if(activeMatch){
      return activeMatch.name || '';
    }
    const archivedMatch = Array.isArray(company.archivedWelders)
      ? company.archivedWelders.find(entry => entry && entry.welder && entry.welder.id === welderId)
      : null;
    if(archivedMatch && archivedMatch.welder){
      return archivedMatch.welder.name || '';
    }
  }
  return '';
}

function getPansonCodeById(pansonId){
  if(!pansonId){
    return '';
  }
  const company = getActiveCompany();
  if(!company){
    return '';
  }
  const active = Array.isArray(company.pansoane)
    ? company.pansoane.find(p => p && p.id === pansonId)
    : null;
  if(active && active.code){
    return active.code;
  }
  const archived = Array.isArray(company.archivedPansoane)
    ? company.archivedPansoane.find(p => p && p.id === pansonId)
    : null;
  return archived && archived.code ? archived.code : '';
}

function updateArchiveToggleLabel(shownCount, totalCount){
  const toggle = document.getElementById('toggle_archive');
  if(!toggle){
    return;
  }
  const company = getActiveCompany();
  const total = typeof totalCount === 'number' ? totalCount : company.archivedWelders.length;
  const shown = typeof shownCount === 'number' ? shownCount : total;
  const baseLabel = archiveVisible ? 'Ascunde arhiva' : 'ArhivƒÉ sudori';
  const countLabel = total === 0
    ? '0'
    : (shown === total ? `${total}` : `${shown}/${total}`);
  toggle.textContent = `${baseLabel} (${countLabel})`;
  toggle.disabled = total === 0 && !archiveVisible;
}

function updateArchiveVisibility(shownCount, totalCount){
  const panel = document.getElementById('archive_panel');
  if(panel){
    panel.classList.toggle('hidden', !archiveVisible);
    panel.setAttribute('aria-hidden', archiveVisible ? 'false' : 'true');
  }
  const toggle = document.getElementById('toggle_archive');
  if(toggle){
    toggle.setAttribute('aria-expanded', archiveVisible ? 'true' : 'false');
  }
  const company = getActiveCompany();
  if(typeof shownCount === 'number' && typeof totalCount === 'number'){
    updateArchiveToggleLabel(shownCount, totalCount);
  } else {
    const total = company.archivedWelders.filter(entry => entry && entry.welder).length;
    if(total === 0){
      updateArchiveToggleLabel(0, 0);
    } else {
      const search = archiveSearchTerm.trim().toLowerCase();
      if(!search){
        updateArchiveToggleLabel(total, total);
      } else {
        const shown = company.archivedWelders.filter(entry => {
          if(!entry || !entry.welder){
            return false;
          }
          const name = entry.welder.name ? entry.welder.name.toLowerCase() : '';
          const code = entry.welder.code !== undefined && entry.welder.code !== null
            ? String(entry.welder.code).toLowerCase()
            : '';
          const reason = entry && typeof entry.reason === 'string' ? entry.reason.toLowerCase() : '';
          return `${name} ${code} ${reason}`.includes(search);
        }).length;
        updateArchiveToggleLabel(shown, total);
      }
    }
  }
}

function renderArchiveList(){
  const tbody = document.getElementById('archive_tbody');
  const wrap = document.getElementById('archive_table_wrap');
  const emptyState = document.getElementById('archive_empty');
  const noResults = document.getElementById('archive_no_results');
  const searchInput = document.getElementById('archive_search');
  const company = getActiveCompany();
  if(tbody){
    tbody.innerHTML = '';
  }
  const archivedEntries = company.archivedWelders.filter(entry => entry && entry.welder);
  const totalEntries = archivedEntries.length;
  const search = archiveSearchTerm.trim().toLowerCase();
  const filtered = !search
    ? archivedEntries
    : archivedEntries.filter(entry => {
        const welder = entry && entry.welder ? entry.welder : {};
        const name = welder && welder.name ? welder.name.toLowerCase() : '';
        const code = welder && welder.code !== undefined && welder.code !== null
          ? String(welder.code).toLowerCase()
          : '';
        const reason = entry && typeof entry.reason === 'string' ? entry.reason.toLowerCase() : '';
        return `${name} ${code} ${reason}`.includes(search);
      });
  const sorted = filtered.slice().sort((a, b) => {
    const nameA = a && a.welder && a.welder.name ? a.welder.name : '';
    const nameB = b && b.welder && b.welder.name ? b.welder.name : '';
    if(nameA && nameB){
      return nameA.localeCompare(nameB, 'ro', { sensitivity: 'base' });
    }
    return nameA.localeCompare(nameB);
  });

  if(tbody){
    sorted.forEach(entry => {
      const welder = entry.welder || {};
      let archiveIndex = company.archivedWelders.indexOf(entry);
      if(archiveIndex === -1 && welder && welder.id !== undefined){
        archiveIndex = company.archivedWelders.findIndex(item => item && item.welder && item.welder.id === welder.id);
      }
      const archivedAt = entry && entry.archived_at ? String(entry.archived_at).slice(0, 10) : '';
      const qualifications = Array.isArray(entry.qualifications) ? entry.qualifications.length : 0;
      const reasonText = entry && typeof entry.reason === 'string' ? entry.reason : '';
      const reasonCell = reasonText ? escapeHtml(reasonText) : '<span class="muted">‚Äî</span>';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(welder && welder.name ? welder.name : '(fƒÉrƒÉ nume)')}</td>
        <td>${escapeHtml(welder && welder.code !== undefined && welder.code !== null ? welder.code : '')}</td>
        <td>${escapeHtml(archivedAt)}</td>
        <td>${reasonCell}</td>
        <td>${qualifications}</td>
        <td><button type="button" class="btn secondary" data-action="restore" data-id="${welder && welder.id !== undefined ? welder.id : ''}" data-index="${archiveIndex >= 0 ? archiveIndex : ''}">RestaureazƒÉ</button></td>
      `;
      tbody.appendChild(tr);
    });

    tbody.querySelectorAll('button[data-action="restore"]').forEach(button => {
      button.addEventListener('click', () => {
        const rawId = button.getAttribute('data-id');
        const hasId = rawId !== null && rawId !== '';
        const id = hasId ? Number(rawId) : NaN;
        const rawIndex = button.getAttribute('data-index');
        const hasIndex = rawIndex !== null && rawIndex !== '';
        const archiveIndex = hasIndex ? Number(rawIndex) : NaN;
        if(Number.isNaN(id) && Number.isNaN(archiveIndex)){
          return;
        }
        const archivedEntry = !Number.isNaN(id)
          ? company.archivedWelders.find(item => item && item.welder && item.welder.id === id)
          : company.archivedWelders[archiveIndex];
        const displayName = archivedEntry && archivedEntry.welder && archivedEntry.welder.name
          ? archivedEntry.welder.name
          : 'acest sudor';
        if(!confirm(`Reactivezi sudorul ${displayName} »ôi autoriza»õiile sale?`)){
          return;
        }
        restoreArchivedWelder(id, Number.isNaN(archiveIndex) ? null : archiveIndex);
      });
    });
  }

  if(searchInput){
    if(totalEntries === 0){
      archiveSearchTerm = '';
    }
    if(searchInput.value !== archiveSearchTerm){
      searchInput.value = archiveSearchTerm;
    }
    searchInput.disabled = totalEntries === 0;
  }
  if(wrap){
    wrap.classList.toggle('hidden', sorted.length === 0);
  }
  if(emptyState){
    emptyState.classList.toggle('hidden', totalEntries !== 0);
  }
  if(noResults){
    noResults.classList.toggle('hidden', !(totalEntries > 0 && sorted.length === 0));
  }
  if(totalEntries === 0 && archiveVisible){
    archiveVisible = false;
  }
  updateArchiveVisibility(sorted.length, totalEntries);
}

function populateCompanySelector(){
  const select = document.getElementById('company_selector');
  if(!select){
    return;
  }
  select.innerHTML = '';
  if(!state || !Array.isArray(state.companies) || state.companies.length === 0){
    const option = document.createElement('option');
    option.value = '';
    option.textContent = 'FƒÉrƒÉ companii';
    select.appendChild(option);
    select.disabled = true;
    return;
  }
  select.disabled = false;
  state.companies.forEach(company => {
    const option = document.createElement('option');
    option.value = String(company.id);
    option.textContent = company.name || `Companie ${company.id}`;
    select.appendChild(option);
  });
  const desiredValue = String(state.activeCompanyId);
  if(select.value !== desiredValue){
    select.value = desiredValue;
  }
}

function updateTopbarCompanyLogo(){
  const logoImg = document.getElementById('active_company_logo');
  if(!logoImg){
    return;
  }
  const company = getActiveCompany();
  if(company && company.logo && company.logo.data){
    logoImg.src = company.logo.data;
    logoImg.alt = `Logo ${company.name || 'companie'}`;
    logoImg.classList.add('visible');
  } else {
    logoImg.removeAttribute('src');
    logoImg.alt = 'Logo companie';
    logoImg.classList.remove('visible');
  }
}

function renameCompany(id, newName){
  const company = getCompanyById(id);
  if(!company){
    return;
  }
  const trimmed = typeof newName === 'string' ? newName.trim() : '';
  if(!trimmed){
    alert('Numele companiei nu poate fi gol.');
    return;
  }
  if(company.name === trimmed){
    return;
  }
  company.name = trimmed;
  persistState();
  populateCompanySelector();
  renderCompanySettings();
  updateHomeDashboard();
}

function renderCompanySettings(){
  const container = document.getElementById('company_list');
  if(!container){
    return;
  }
  container.innerHTML = '';
  if(!state || !Array.isArray(state.companies) || state.companies.length === 0){
    const empty = document.createElement('p');
    empty.className = 'muted';
    empty.textContent = 'AdaugƒÉ o companie pentru a √Æncepe eviden»õa.';
    container.appendChild(empty);
    return;
  }
  state.companies.forEach(company => {
    const row = document.createElement('div');
    row.className = 'company-item';

    const nameWrapper = document.createElement('div');
    nameWrapper.style.flex = '1 1 220px';
    const nameLabel = document.createElement('label');
    nameLabel.className = 'muted';
    nameLabel.textContent = 'Nume companie';
    nameLabel.style.display = 'block';
    nameLabel.style.marginBottom = '4px';
    const nameInput = document.createElement('input');
    nameInput.value = company.name || '';
    nameInput.setAttribute('data-id', String(company.id));
    nameInput.addEventListener('keydown', event => {
      if(event.key === 'Enter'){
        event.preventDefault();
        renameCompany(company.id, nameInput.value);
      }
    });
    nameWrapper.appendChild(nameLabel);
    nameWrapper.appendChild(nameInput);
    row.appendChild(nameWrapper);

    const logoWrapper = document.createElement('div');
    logoWrapper.style.display = 'flex';
    logoWrapper.style.flexDirection = 'column';
    logoWrapper.style.gap = '8px';
    logoWrapper.style.alignItems = 'flex-start';
    const logoPreview = document.createElement('div');
    logoPreview.className = 'logo-preview';
    if(company.logo && company.logo.data){
      const img = document.createElement('img');
      img.src = company.logo.data;
      img.alt = `Logo ${company.name || ''}`;
      logoPreview.appendChild(img);
    } else {
      logoPreview.textContent = 'FƒÉrƒÉ logo';
    }
    logoWrapper.appendChild(logoPreview);
    const logoInput = document.createElement('input');
    logoInput.type = 'file';
    logoInput.accept = 'image/*';
    logoInput.addEventListener('change', async event => {
      const file = event.target.files && event.target.files[0];
      if(file){
        await handleCompanyLogoChange(company.id, file);
      }
    });
    logoWrapper.appendChild(logoInput);
    const removeLogoButton = document.createElement('button');
    removeLogoButton.type = 'button';
    removeLogoButton.className = 'btn ghost';
    removeLogoButton.textContent = 'EliminƒÉ logo';
    removeLogoButton.disabled = !(company.logo && company.logo.data);
    removeLogoButton.addEventListener('click', () => removeCompanyLogo(company.id));
    logoWrapper.appendChild(removeLogoButton);
    row.appendChild(logoWrapper);

    const totalAuthorizations = company.qualifications.filter(q => q && q.category === 'autorizatii').length;
    const totalProcedures = company.qualifications.filter(q => q && q.category === 'procedee').length;
    const statsTag = document.createElement('span');
    statsTag.className = 'tag';
    statsTag.style.marginLeft = 'auto';
    statsTag.textContent = `Sudori: ${company.welders.length} ¬∑ Autoriza»õii: ${totalAuthorizations} ¬∑ Procedee: ${totalProcedures}`;
    row.appendChild(statsTag);

    const saveButton = document.createElement('button');
    saveButton.type = 'button';
    saveButton.className = 'btn ghost';
    saveButton.textContent = 'SalveazƒÉ numele';
    saveButton.addEventListener('click', () => renameCompany(company.id, nameInput.value));

    const activateButton = document.createElement('button');
    activateButton.type = 'button';
    activateButton.className = company.id === state.activeCompanyId ? 'btn secondary' : 'btn';
    activateButton.textContent = company.id === state.activeCompanyId ? 'ActivƒÉ' : 'SeteazƒÉ activƒÉ';
    activateButton.disabled = company.id === state.activeCompanyId;
    activateButton.addEventListener('click', () => setActiveCompany(company.id));

    const actionsWrapper = document.createElement('div');
    actionsWrapper.style.display = 'flex';
    actionsWrapper.style.flexWrap = 'wrap';
    actionsWrapper.style.alignItems = 'center';
    actionsWrapper.style.gap = '8px';
    actionsWrapper.appendChild(saveButton);

    const brandingButton = document.createElement('button');
    brandingButton.type = 'button';
    brandingButton.className = 'btn ghost';
    brandingButton.textContent = '‚öôÔ∏è';
    brandingButton.title = 'SetƒÉri antet & subsol rapoarte';
    brandingButton.setAttribute('aria-label', `SetƒÉri antet »ôi subsol pentru ${company.name || 'companie'}`);
    brandingButton.addEventListener('click', () => openBrandingModal(company.id));
    actionsWrapper.appendChild(brandingButton);

    const deleteButton = document.createElement('button');
    deleteButton.type = 'button';
    deleteButton.className = 'btn danger';
    deleteButton.textContent = '»òterge compania';
    deleteButton.disabled = state.companies.length <= 1;
    deleteButton.addEventListener('click', () => deleteCompany(company.id));
    actionsWrapper.appendChild(deleteButton);

    actionsWrapper.appendChild(activateButton);
    row.appendChild(actionsWrapper);

    container.appendChild(row);
  });
  updateTopbarCompanyLogo();
  refreshBrandingEditors();
}

function deleteCompany(companyId){
  if(!state || !Array.isArray(state.companies)){
    return;
  }
  if(state.companies.length <= 1){
    alert('Nu po»õi »ôterge ultima companie disponibilƒÉ.');
    return;
  }
  const company = getCompanyById(companyId);
  if(!company){
    alert('Compania nu a fost gƒÉsitƒÉ.');
    return;
  }
  if(!confirm(`»òtergi compania ‚Äû${company.name}‚Äù? Datele asociate vor fi eliminate.`)){
    return;
  }
  const password = prompt('Introdu parola pentru confirmarea »ôtergerii:');
  if(password === null){
    return;
  }
  if(password !== AUTH_PASSWORD){
    alert('Parola introdusƒÉ nu este corectƒÉ.');
    return;
  }
  state.companies = state.companies.filter(entry => entry.id !== company.id);
  if(state.companies.length === 0){
    const fallback = createEmptyCompany(state.nextCompanyId || 1, 'Companie implicitƒÉ');
    state.companies.push(fallback);
  }
  if(state.activeCompanyId === company.id){
    state.activeCompanyId = state.companies[0].id;
  }
  if(brandingModalCompanyId === company.id){
    closeBrandingModal();
  }
  activeAuthorizationDossierId = null;
  selectedWelder = null;
  selectedWelderPosition = null;
  archiveVisible = false;
  pansonArchiveVisible = false;
  persistState();
  populateCompanySelector();
  renderCompanySettings();
  updateHomeDashboard();
  resetWelderForm();
  closeWelderModal();
  loadWelders();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
  loadPansoane();
  loadAuthorizations();
  loadProcedures();
  renderArchiveList();
  updateTopbarCompanyLogo();
  renderAuthStandardTabs();
  renderStandardManagerList();
  loadAuthorizationDossier();
  loadProcedureDossier();
  refreshBrandingEditors();
}

function renderBrandingEditorForCompany(container, company){
  if(!container){
    return;
  }
  if(!company){
    container.innerHTML = '<p class="muted">SelecteazƒÉ o companie activƒÉ pentru a personaliza rapoartele.</p>';
    return;
  }
  const branding = ensureReportBranding(company);
  container.innerHTML = '';
  ['header', 'footer'].forEach(section => {
    const sectionWrapper = document.createElement('div');
    sectionWrapper.className = 'branding-section';
    const title = document.createElement('h3');
    title.textContent = section === 'header' ? 'Antet PDF' : 'Footer PDF';
    sectionWrapper.appendChild(title);
    const hint = document.createElement('p');
    hint.className = 'muted';
    hint.textContent = section === 'header'
      ? 'Elementele de mai jos apar √Æn partea superioarƒÉ a fiecƒÉrei pagini.'
      : 'Elementele de mai jos apar √Æn partea inferioarƒÉ a fiecƒÉrei pagini.';
    sectionWrapper.appendChild(hint);
    const list = document.createElement('div');
    list.className = 'branding-list';
    const items = Array.isArray(branding[section]) ? branding[section] : [];
    if(items.length === 0){
      const empty = document.createElement('p');
      empty.className = 'muted';
      empty.textContent = 'Nu existƒÉ elemente definite.';
      list.appendChild(empty);
    } else {
      items.forEach(item => {
        const row = document.createElement('div');
        row.className = 'branding-item';
        const meta = document.createElement('div');
        meta.className = 'meta';
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = item.type === 'image' ? 'Imagine' : 'Text';
        meta.appendChild(label);
        if(item.type === 'image' && item.data){
          const img = document.createElement('img');
          img.src = item.data;
          img.alt = item.name || 'Imagine branding';
          img.className = 'branding-preview';
          meta.appendChild(img);
        } else if(item.type === 'text'){
          const preview = document.createElement('div');
          preview.textContent = item.content;
          preview.style.fontSize = `${clampBrandingTextSize(item.size)}px`;
          meta.appendChild(preview);
        }
        const details = document.createElement('div');
        details.className = 'muted';
        const alignLabel = item.align === 'center'
          ? 'Centru'
          : item.align === 'right'
            ? 'Dreapta'
            : 'St√¢nga';
        const sizeLabel = item.type === 'text' ? ` ¬∑ ${clampBrandingTextSize(item.size)} pt` : '';
        const rowLabel = ` ¬∑ Linie: ${item.row && item.row > 0 ? item.row : 1}`;
        details.textContent = `Aliniere: ${alignLabel}${sizeLabel}${rowLabel}`;
        meta.appendChild(details);
        row.appendChild(meta);

        const actions = document.createElement('div');
        actions.className = 'actions';
        if(item.type === 'text'){
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.className = 'btn ghost small';
          editBtn.textContent = 'EditeazƒÉ text';
          editBtn.addEventListener('click', () => editBrandingText(section, item.id));
          actions.appendChild(editBtn);

          const sizeInput = document.createElement('input');
          sizeInput.type = 'number';
          sizeInput.min = '5';
          sizeInput.max = '28';
          sizeInput.value = clampBrandingTextSize(item.size);
          sizeInput.title = 'MƒÉrime text (pt)';
          sizeInput.addEventListener('change', () => updateBrandingTextSize(section, item.id, Number(sizeInput.value)));
          actions.appendChild(sizeInput);
        }

        const rowInput = document.createElement('input');
        rowInput.type = 'number';
        rowInput.min = '1';
        rowInput.value = item.row && item.row > 0 ? item.row : 1;
        rowInput.className = 'row-select';
        rowInput.title = 'Linia pe paginƒÉ';
        rowInput.addEventListener('change', () => updateBrandingRow(section, item.id, Number(rowInput.value)));
        actions.appendChild(rowInput);

        const alignSelect = document.createElement('select');
        [
          { value: 'left', label: 'St√¢nga' },
          { value: 'center', label: 'Centru' },
          { value: 'right', label: 'Dreapta' },
        ].forEach(optionData => {
          const option = document.createElement('option');
          option.value = optionData.value;
          option.textContent = optionData.label;
          alignSelect.appendChild(option);
        });
        alignSelect.value = item.align === 'center' || item.align === 'right' ? item.align : 'left';
        alignSelect.addEventListener('change', () => updateBrandingAlign(section, item.id, alignSelect.value));
        actions.appendChild(alignSelect);

        if(item.type === 'image'){
          const replaceInput = document.createElement('input');
          replaceInput.type = 'file';
          replaceInput.accept = 'image/*';
          replaceInput.style.display = 'none';
          replaceInput.addEventListener('change', event => {
            const file = event.target.files && event.target.files[0];
            if(file){
              replaceBrandingImage(section, item.id, file);
            }
          });
          const replaceBtn = document.createElement('button');
          replaceBtn.type = 'button';
          replaceBtn.className = 'btn ghost small';
          replaceBtn.textContent = '√énlocuie»ôte imagine';
          replaceBtn.addEventListener('click', () => replaceInput.click());
          actions.appendChild(replaceBtn);
          actions.appendChild(replaceInput);
        }

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'btn ghost small';
        deleteBtn.textContent = '»òterge';
        deleteBtn.addEventListener('click', () => deleteBrandingItem(section, item.id));
        actions.appendChild(deleteBtn);

        row.appendChild(actions);
        list.appendChild(row);
      });
    }
    sectionWrapper.appendChild(list);

    const controls = document.createElement('div');
    controls.className = 'branding-controls';
    const addTextBtn = document.createElement('button');
    addTextBtn.type = 'button';
    addTextBtn.className = 'btn secondary';
    addTextBtn.textContent = 'AdaugƒÉ text';
    addTextBtn.addEventListener('click', () => addBrandingText(section));
    controls.appendChild(addTextBtn);

    const addImageInput = document.createElement('input');
    addImageInput.type = 'file';
    addImageInput.accept = 'image/*';
    addImageInput.style.display = 'none';
    addImageInput.addEventListener('change', event => {
      const file = event.target.files && event.target.files[0];
      if(file){
        handleBrandingImageUpload(section, file);
      }
    });
    const addImageBtn = document.createElement('button');
    addImageBtn.type = 'button';
    addImageBtn.className = 'btn ghost';
    addImageBtn.textContent = 'AdaugƒÉ imagine';
    addImageBtn.addEventListener('click', () => addImageInput.click());
    controls.appendChild(addImageBtn);
    controls.appendChild(addImageInput);

    sectionWrapper.appendChild(controls);
    container.appendChild(sectionWrapper);
  });

  const spacingControl = document.createElement('div');
  spacingControl.className = 'branding-spacing-control';
  const spacingInput = document.createElement('input');
  spacingInput.type = 'number';
  spacingInput.min = '0';
  spacingInput.max = '120';
  spacingInput.value = getCompanyBrandingSpacing(company);
  spacingInput.id = `branding_spacing_${company.id}`;
  spacingInput.addEventListener('change', () => {
    const applied = updateCompanyBrandingSpacing(company.id, Number(spacingInput.value));
    spacingInput.value = applied;
  });
  const spacingLabel = document.createElement('label');
  spacingLabel.setAttribute('for', spacingInput.id);
  spacingLabel.textContent = 'Spa»õiere √Æntre elemente (px):';
  const spacingHint = document.createElement('span');
  spacingHint.textContent = 'AjusteazƒÉ distan»õa pentru a pƒÉstra toate elementele pe aceea»ôi linie.';
  spacingControl.appendChild(spacingLabel);
  spacingControl.appendChild(spacingInput);
  spacingControl.appendChild(spacingHint);
  container.appendChild(spacingControl);
}

function openBrandingModal(companyId){
  const modal = document.getElementById('branding_modal');
  const content = document.getElementById('branding_modal_content');
  if(!modal || !content){
    return;
  }
  const company = getCompanyById(companyId);
  if(!company){
    alert('Compania nu a fost gƒÉsitƒÉ.');
    return;
  }
  brandingModalCompanyId = company.id;
  const title = document.getElementById('branding_modal_title');
  if(title){
    title.textContent = `SetƒÉri antet & subsol ‚Äì ${company.name || 'Companie'}`;
  }
  renderBrandingEditorForCompany(content, company);
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
  document.body.dataset.brandingModalOpen = 'true';
  document.body.style.overflow = 'hidden';
}

function closeBrandingModal(){
  const modal = document.getElementById('branding_modal');
  if(!modal){
    return;
  }
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
  delete document.body.dataset.brandingModalOpen;
  if(!document.body.dataset.welderModalOpen && !document.body.dataset.viewerOpen){
    document.body.style.overflow = '';
  }
  brandingModalCompanyId = null;
}

function renderReportBrandingEditor(){
  const container = document.getElementById('report_branding_editor');
  const company = getActiveCompany();
  renderBrandingEditorForCompany(container, company);
}

function refreshBrandingEditors(){
  renderReportBrandingEditor();
  if(brandingModalCompanyId){
    const modalContent = document.getElementById('branding_modal_content');
    const title = document.getElementById('branding_modal_title');
    const targetCompany = getCompanyById(brandingModalCompanyId);
    if(!targetCompany){
      closeBrandingModal();
      return;
    }
    if(title){
      title.textContent = `SetƒÉri antet & subsol ‚Äì ${targetCompany.name || 'Companie'}`;
    }
    if(modalContent){
      renderBrandingEditorForCompany(modalContent, targetCompany);
    }
  }
}

function findBrandingItem(section, itemId){
  const company = getActiveCompany();
  const branding = ensureReportBranding(company);
  const items = Array.isArray(branding[section]) ? branding[section] : [];
  const index = items.findIndex(item => item && item.id === itemId);
  return { items, index };
}

function addBrandingText(section){
  const contentPrompt = prompt('Introdu textul care va fi afi»ôat √Æn raport:');
  if(contentPrompt === null){
    return;
  }
  const content = contentPrompt.trim();
  if(!content){
    alert('Textul nu poate fi gol.');
    return;
  }
  const align = prompt('Aliniere (st√¢nga / centru / dreapta):', 'centru');
  const normalizedAlign = align && align.toLowerCase().includes('dreap')
    ? 'right'
    : (align && align.toLowerCase().includes('st') ? 'left' : 'center');
  const sizePrompt = prompt('MƒÉrime text (puncte, 5-28):', '11');
  const size = clampBrandingTextSize(sizePrompt);
  const company = getActiveCompany();
  const branding = ensureReportBranding(company);
  branding[section].push({
    id: generateDocumentId('branding'),
    type: 'text',
    content,
    align: normalizedAlign,
    size,
  });
  persistState();
  refreshBrandingEditors();
}

async function handleBrandingImageUpload(section, file){
  if(!file){
    return;
  }
  if(file.type && !file.type.startsWith('image/')){
    alert('Se pot √ÆncƒÉrca doar fi»ôiere imagine.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    const company = getActiveCompany();
    const branding = ensureReportBranding(company);
    branding[section].push({
      id: generateDocumentId('branding'),
      type: 'image',
      name: file.name || 'imagine.png',
      data: dataUrl,
      mime: file.type || 'image/png',
      align: 'center',
    });
    persistState();
    refreshBrandingEditors();
  } catch (err) {
    console.error('Nu s-a putut √ÆncƒÉrca imaginea pentru branding.', err);
    alert('√éncƒÉrcarea imaginii a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function updateBrandingRow(section, itemId, row){
  const { items, index } = findBrandingItem(section, itemId);
  if(index === -1){
    return;
  }
  const numeric = Number(row);
  items[index].row = Number.isInteger(numeric) && numeric > 0 ? numeric : 1;
  persistState();
  refreshBrandingEditors();
}

function updateBrandingAlign(section, itemId, align){
  const { items, index } = findBrandingItem(section, itemId);
  if(index === -1){
    return;
  }
  const normalized = align === 'center' || align === 'right' ? align : 'left';
  items[index].align = normalized;
  persistState();
  refreshBrandingEditors();
}

function updateBrandingTextSize(section, itemId, size){
  const { items, index } = findBrandingItem(section, itemId);
  if(index === -1){
    return;
  }
  const item = items[index];
  if(item.type !== 'text'){
    return;
  }
  const clamped = clampBrandingTextSize(size);
  item.size = clamped;
  persistState();
  refreshBrandingEditors();
}

function editBrandingText(section, itemId){
  const { items, index } = findBrandingItem(section, itemId);
  if(index === -1){
    return;
  }
  const item = items[index];
  if(item.type !== 'text'){
    return;
  }
  const promptValue = prompt('ActualizeazƒÉ con»õinutul textului:', item.content || '');
  if(promptValue === null){
    return;
  }
  const content = promptValue.trim();
  if(!content){
    alert('Textul nu poate fi gol.');
    return;
  }
  item.content = content;
  persistState();
  refreshBrandingEditors();
}

async function replaceBrandingImage(section, itemId, file){
  if(!file){
    return;
  }
  if(file.type && !file.type.startsWith('image/')){
    alert('Se pot √ÆncƒÉrca doar fi»ôiere imagine.');
    return;
  }
  const { items, index } = findBrandingItem(section, itemId);
  if(index === -1){
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    items[index].data = dataUrl;
    items[index].name = file.name || items[index].name || 'imagine.png';
    items[index].mime = file.type || 'image/png';
    persistState();
    refreshBrandingEditors();
  } catch (err) {
    console.error('Nu s-a putut √Ænlocui imaginea.', err);
    alert('√énlocuirea imaginii a e»ôuat. √éncearcƒÉ din nou.');
  }
}

function deleteBrandingItem(section, itemId){
  const company = getActiveCompany();
  const branding = ensureReportBranding(company);
  branding[section] = (Array.isArray(branding[section]) ? branding[section] : []).filter(item => item && item.id !== itemId);
  persistState();
  refreshBrandingEditors();
}

async function handleCompanyLogoChange(companyId, file){
  const company = getCompanyById(companyId);
  if(!company || !file){
    return;
  }
  const extension = file.name ? file.name.toLowerCase() : '';
  const matchesExtension = extension.endsWith('.png') || extension.endsWith('.jpg') || extension.endsWith('.jpeg') || extension.endsWith('.gif') || extension.endsWith('.webp');
  const isImage = file.type ? file.type.startsWith('image/') : matchesExtension;
  if(!isImage){
    alert('Fi»ôierul logo trebuie sƒÉ fie o imagine.');
    return;
  }
  try {
    const dataUrl = await readFileAsDataURL(file);
    company.logo = {
      name: file.name || 'logo.png',
      data: dataUrl,
      type: file.type || 'image/png',
    };
    persistState();
    renderCompanySettings();
    updateTopbarCompanyLogo();
  } catch (err) {
    console.error('Nu s-a putut citi fi»ôierul de logo.', err);
    alert('Nu s-a putut √ÆncƒÉrca fi»ôierul. √éncearcƒÉ din nou.');
  }
}

function removeCompanyLogo(companyId){
  const company = getCompanyById(companyId);
  if(!company || !company.logo){
    return;
  }
  company.logo = null;
  persistState();
  renderCompanySettings();
  updateTopbarCompanyLogo();
}

function ensureReportBranding(company){
  if(!company.reportBranding || typeof company.reportBranding !== 'object'){
    company.reportBranding = { header: [], footer: [] };
  }
  ['header', 'footer'].forEach(section => {
    if(!Array.isArray(company.reportBranding[section])){
      company.reportBranding[section] = [];
    }
  });
  if(typeof company.reportBrandingSpacing !== 'number'){
    company.reportBrandingSpacing = 16;
  } else {
    company.reportBrandingSpacing = clampBrandingSpacing(company.reportBrandingSpacing);
  }
  return company.reportBranding;
}

function getCompanyBrandingSpacing(company){
  if(!company){
    return 16;
  }
  company.reportBrandingSpacing = clampBrandingSpacing(company.reportBrandingSpacing);
  return company.reportBrandingSpacing;
}

function updateCompanyBrandingSpacing(companyId, value){
  const company = getCompanyById(companyId);
  if(!company){
    return 16;
  }
  const applied = clampBrandingSpacing(value);
  if(company.reportBrandingSpacing !== applied){
    company.reportBrandingSpacing = applied;
    persistState();
    refreshBrandingEditors();
  }
  return applied;
}

function generatePdfReport(type){
  const company = getActiveCompany();
  if(!company){
    alert('SelecteazƒÉ o companie activƒÉ.');
    return;
  }
  const titleMap = {
    welders: 'Raport sudori',
    authorizations: 'Raport autoriza»õii',
    procedures: 'Raport omologƒÉri',
  };
  const heading = `${titleMap[type] || 'Raport'} ‚Äì ${company.name || ''}`;
  const generatedAt = `Generat la: ${new Date().toLocaleString('ro-RO')}`;
  const rows = [];
  let headers = [];
  if(type === 'welders'){
    headers = ['Sudor', 'Cod', 'Telefon', 'Angajare'];
    (company.welders || []).forEach(w => {
      rows.push([
        w.name || '',
        w.code || '',
        w.phone || '',
        w.hire_date || '',
      ]);
    });
  } else if(type === 'authorizations'){
    headers = ['Sudor', 'Standard', 'Proces', 'Pozi»õie', 'Certificat', 'ExpirƒÉ'];
    (company.qualifications || []).filter(q => q && q.category === 'autorizatii').forEach(q => {
      rows.push([
        findWelderNameById(q.welder_id) || '',
        getStandardLabel(q.standard),
        q.process || '',
        q.position || '',
        q.certificate_no || '',
        q.expiry_date || '',
      ]);
    });
  } else if(type === 'procedures'){
    headers = ['Sudor', 'Standard', 'Procedeu', 'Pozi»õie', 'Certificat'];
    (company.qualifications || []).filter(q => q && q.category === 'procedee').forEach(q => {
      rows.push([
        findWelderNameById(q.welder_id) || 'general',
        getStandardLabel(q.standard),
        q.process || '',
        q.position || '',
        q.certificate_no || '',
      ]);
    });
  }
  if(rows.length === 0){
    headers = headers.length ? headers : ['Informa»õii'];
    rows.push(['Nu existƒÉ date pentru raport.']);
  }
  const tableHeader = `<tr>${headers.map(header => `<th>${escapeHtml(header)}</th>`).join('')}</tr>`;
  const tableBody = rows.map(row => `<tr>${row.map(cell => `<td>${escapeHtml(cell || '')}</td>`).join('')}</tr>`).join('');
  const content = `
    <table class="print-table">
      <thead>${tableHeader}</thead>
      <tbody>${tableBody}</tbody>
    </table>
  `;
  const page = renderPrintPage({
    company,
    orientation: type === 'welders' ? 'portrait' : 'landscape',
    heading: escapeHtml(heading),
    subheading: escapeHtml(generatedAt),
    content,
  });
  openPrintPreview({
    title: heading,
    pages: [page],
  });
}

function setActiveCompany(id){
  const company = getCompanyById(id);
  if(!company){
    return;
  }
  if(state.activeCompanyId === company.id){
    return;
  }
  state.activeCompanyId = company.id;
  selectedWelder = null;
  selectedWelderPosition = null;
  archiveVisible = false;
  persistState();
  populateCompanySelector();
  renderCompanySettings();
  updateHomeDashboard();
  resetWelderForm();
  closeWelderModal();
  loadWelders();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
  loadPansoane();
  loadAuthorizations();
  loadProcedures();
  renderArchiveList();
  updateTopbarCompanyLogo();
  renderAuthStandardTabs();
  renderStandardManagerList();
  loadAuthorizationDossier();
  loadProcedureDossier();
}

function handleAddCompany(){
  const name = prompt('Introdu numele noii companii:');
  if(name === null){
    return;
  }
  const trimmed = name.trim();
  if(!trimmed){
    alert('Numele companiei este obligatoriu.');
    return;
  }
  const newId = state.nextCompanyId++;
  const newCompany = createEmptyCompany(newId, trimmed);
  state.companies.push(newCompany);
  state.activeCompanyId = newCompany.id;
  selectedWelder = null;
  selectedWelderPosition = null;
  archiveVisible = false;
  persistState();
  populateCompanySelector();
  renderCompanySettings();
  updateHomeDashboard();
  resetWelderForm();
  closeWelderModal();
  loadWelders();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
  loadPansoane();
  loadAuthorizations();
  loadProcedures();
  renderArchiveList();
  updateTopbarCompanyLogo();
  renderAuthStandardTabs();
  renderStandardManagerList();
  loadAuthorizationDossier();
  loadProcedureDossier();
}

function updateHomeDashboard(){
  const totalWeldersEl = document.getElementById('home_total_welders');
  const totalAuthEl = document.getElementById('home_total_authorizations');
  const totalProcEl = document.getElementById('home_total_procedures');
  const expiringSoonEl = document.getElementById('home_expiring_soon');
  const expiredEl = document.getElementById('home_expired');
  const idCardExpiringEl = document.getElementById('home_id_card_expiring');
  const idCardExpiredEl = document.getElementById('home_id_card_expired');
  const aptitudeExpiringEl = document.getElementById('home_aptitude_expiring');
  const aptitudeExpiredEl = document.getElementById('home_aptitude_expired');
  const tableBody = document.getElementById('home_expiring_table');
  const emptyMessage = document.getElementById('home_no_expiring');
  const companyTable = document.getElementById('home_company_table');
  const companyEmptyMessage = document.getElementById('home_companies_empty');
  if(!totalWeldersEl || !totalAuthEl || !totalProcEl || !expiringSoonEl || !expiredEl || !idCardExpiringEl || !idCardExpiredEl || !aptitudeExpiringEl || !aptitudeExpiredEl || !tableBody || !emptyMessage || !companyTable || !companyEmptyMessage){
    return;
  }
  let totalWelders = 0;
  let totalAuthorizations = 0;
  let totalProcedures = 0;
  let expiringSoon = 0;
  let expired = 0;
  let idCardExpiring = 0;
  let idCardExpired = 0;
  let aptitudeExpiring = 0;
  let aptitudeExpired = 0;
  const upcoming = [];
  const companyRows = [];
  const today = new Date();
  today.setHours(0,0,0,0);

  if(state && Array.isArray(state.companies)){
    state.companies.forEach(company => {
      if(!company){
        return;
      }
      const welderCount = Array.isArray(company.welders) ? company.welders.length : 0;
      totalWelders += welderCount;
      const qualifications = Array.isArray(company.qualifications) ? company.qualifications : [];
      let companyExpiring = 0;
      let companyExpired = 0;
      let companyAuthCount = 0;
      let companyProcCount = 0;
      qualifications.forEach(q => {
        if(!q){
          return;
        }
        if(q.category === 'procedee'){
          companyProcCount += 1;
          totalProcedures += 1;
          return;
        }
        if(q.category !== 'autorizatii'){
          return;
        }
        companyAuthCount += 1;
        totalAuthorizations += 1;
        if(!q.expiry_date){
          return;
        }
        const expiry = new Date(q.expiry_date);
        if(Number.isNaN(expiry.getTime())){
          return;
        }
        expiry.setHours(0,0,0,0);
        const diffDays = Math.ceil((expiry - today) / (1000*60*60*24));
        if(diffDays < 0){
          expired += 1;
          companyExpired += 1;
        } else if(diffDays <= 30){
          expiringSoon += 1;
          companyExpiring += 1;
        }
        if(diffDays >= 0 && diffDays <= 60){
          const welderName = company.welders.find(w => w.id === q.welder_id)?.name || findWelderNameById(q.welder_id) || '';
          upcoming.push({
            companyName: company.name || `Companie ${company.id}`,
            welderName: welderName || '‚Äî',
            standard: q.standard,
            process: q.process,
            position: q.position,
            expiry: expiry.toISOString().slice(0, 10),
          });
        }
      });
      companyRows.push({
        id: company.id,
        name: company.name || `Companie ${company.id}`,
        welderCount,
        authCount: companyAuthCount,
        procedureCount: companyProcCount,
        expiring: companyExpiring,
        expired: companyExpired,
      });

      const welders = Array.isArray(company.welders) ? company.welders : [];
      welders.forEach(welder => {
        if(!welder){
          return;
        }
        const idExpiryValue = welder.id_card_expiry || welder.idCardExpiry;
        const idExpiryDate = parseDateOnly(idExpiryValue);
        if(idExpiryDate){
          const diff = Math.ceil((idExpiryDate - today) / MS_PER_DAY);
          if(diff < 0){
            idCardExpired += 1;
          } else if(diff <= 30){
            idCardExpiring += 1;
          }
        }
        const aptitudeExpiryValue = welder.aptitude_expiry || welder.aptitudeExpiry;
        const aptitudeExpiryDate = parseDateOnly(aptitudeExpiryValue);
        if(aptitudeExpiryDate){
          const diff = Math.ceil((aptitudeExpiryDate - today) / MS_PER_DAY);
          if(diff < 0){
            aptitudeExpired += 1;
          } else if(diff <= 30){
            aptitudeExpiring += 1;
          }
        }
      });
    });
  }

  totalWeldersEl.textContent = totalWelders;
  totalAuthEl.textContent = totalAuthorizations;
  totalProcEl.textContent = totalProcedures;
  expiringSoonEl.textContent = expiringSoon;
  expiredEl.textContent = expired;
  idCardExpiringEl.textContent = idCardExpiring;
  idCardExpiredEl.textContent = idCardExpired;
  aptitudeExpiringEl.textContent = aptitudeExpiring;
  aptitudeExpiredEl.textContent = aptitudeExpired;

  companyTable.innerHTML = '';
  if(companyRows.length === 0){
    companyEmptyMessage.classList.remove('hidden');
  } else {
    companyEmptyMessage.classList.add('hidden');
    companyRows.sort((a, b) => a.name.localeCompare(b.name, 'ro', { sensitivity: 'base' }));
    companyRows.forEach(row => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(row.name)}</td>
        <td>${escapeHtml(row.welderCount)}</td>
        <td>${escapeHtml(row.authCount)}</td>
        <td>${escapeHtml(row.procedureCount)}</td>
        <td>${escapeHtml(row.expiring)}</td>
        <td>${escapeHtml(row.expired)}</td>
      `;
      companyTable.appendChild(tr);
    });
  }

  tableBody.innerHTML = '';
  if(upcoming.length === 0){
    emptyMessage.classList.remove('hidden');
  } else {
    emptyMessage.classList.add('hidden');
    upcoming.sort((a, b) => a.expiry.localeCompare(b.expiry));
    upcoming.slice(0, 8).forEach(entry => {
      const tr = document.createElement('tr');
      const standardLabel = getStandardLabel(entry.standard);
      const processParts = [];
      if(entry.process){
        processParts.push(entry.process);
      }
      if(entry.position){
        processParts.push(entry.position);
      }
      const processDisplay = processParts.length ? processParts.join(' / ') : '‚Äî';
      tr.innerHTML = `
        <td>${escapeHtml(entry.companyName)}</td>
        <td>${escapeHtml(entry.welderName)}</td>
        <td>${escapeHtml(standardLabel)}</td>
        <td>${escapeHtml(processDisplay)}</td>
        <td>${escapeHtml(entry.expiry)}</td>
      `;
      tableBody.appendChild(tr);
    });
  }
}

let activeWeldersSubview = 'menu';
let activeView = 'home';

function openWelderModal(mode){
  const modal = document.getElementById('welder_modal');
  if(!modal){
    return;
  }
  welderModalMode = mode === 'edit' ? 'edit' : 'create';
  modal.dataset.mode = welderModalMode;
  const title = document.getElementById('welder_modal_title');
  if(title){
    title.textContent = welderModalMode === 'edit' ? 'EditeazƒÉ sudor' : 'Sudor nou';
  }
  const saveButton = document.getElementById('btn_save_welder');
  if(saveButton){
    saveButton.textContent = 'SalveazƒÉ';
  }
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
  document.body.dataset.welderModalOpen = 'true';
  document.body.style.overflow = 'hidden';
  const focusTarget = document.getElementById('w_name');
  if(focusTarget && typeof focusTarget.focus === 'function'){
    setTimeout(() => {
      try {
        focusTarget.focus();
      } catch (err) {
        console.warn('Nu s-a putut focaliza c√¢mpul de nume al sudorului.', err);
      }
    }, 0);
  }
}

function closeWelderModal(){
  const modal = document.getElementById('welder_modal');
  if(!modal){
    return;
  }
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
  if(document.body.dataset.welderModalOpen){
    delete document.body.dataset.welderModalOpen;
  }
  if(!document.body.dataset.viewerOpen && !document.body.dataset.brandingModalOpen){
    document.body.style.overflow = '';
  }
}

function setWeldersSubview(mode){
  const valid = ['menu', 'welders', 'pansoane'];
  const target = valid.includes(mode) ? mode : 'menu';
  activeWeldersSubview = target;
  const menu = document.getElementById('welders_menu');
  const welders = document.getElementById('welders_overview');
  const pansoane = document.getElementById('pansoane_overview');
  if(menu){
    menu.classList.toggle('hidden', target !== 'menu');
  }
  if(welders){
    welders.classList.toggle('hidden', target !== 'welders');
  }
  if(pansoane){
    pansoane.classList.toggle('hidden', target !== 'pansoane');
  }
  if(target !== 'welders'){
    closeWelderModal();
  }
  if(target === 'welders'){
    loadWelders();
    renderArchiveList();
  }
  if(target === 'pansoane'){
    loadPansoane();
  }
}

function setActiveView(view, options){
  activeView = view;
  if(view !== 'welders'){
    closeWelderModal();
  }
  const targetId = `view_${view}`;
  document.querySelectorAll('.view').forEach(section => {
    const isActive = section.id === targetId;
    section.classList.toggle('active', isActive);
  });
  document.querySelectorAll('.nav-button').forEach(button => {
    const target = button.getAttribute('data-view');
    button.classList.toggle('active', target === view);
  });
  if(view === 'home'){
    updateHomeDashboard();
  }
  if(view === 'authorizations'){
    if(options && options.group){
      setActiveAuthGroup(options.group);
    } else {
      setActiveAuthGroup(activeAuthGroup);
    }
    populateAuthorizationWelderSelect();
    populateAuthorizationProcedureSelect();
    populateProcedureWelderSelect();
    updateAuthorizationContext();
    loadAuthorizations();
    loadAuthorizationDossier();
  }
  if(view === 'procedures'){
    populateProcedureWelderSelect();
    loadProcedures();
    loadProcedureDossier();
  }
  if(view === 'welders'){
    const subview = options && options.subview ? options.subview : (activeWeldersSubview || 'menu');
    setWeldersSubview(subview);
  }
  if(view === 'settings'){
    renderCompanySettings();
  }
}

function loadWelders(){
  const tbody = document.getElementById('welders_tbody');
  if(!tbody){
    return;
  }
  if(activeWeldersSubview !== 'welders'){
    return;
  }
  const company = getActiveCompany();
  if(selectedWelder && !company.welders.some(w => w.id === selectedWelder.id)){
    selectedWelder = null;
    selectedWelderPosition = null;
  }
  tbody.innerHTML = '';
  const ordered = sortWelders(company.welders);
  const search = welderSearchTerm.trim().toLowerCase();
  const filtered = ordered.filter(function(w){
    if(!search){
      return true;
    }
    const code = w && w.code !== undefined && w.code !== null ? String(w.code) : '';
    const haystack = `${w && w.name ? w.name : ''} ${code}`.toLowerCase();
    return haystack.includes(search);
  });

  const countLabel = document.getElementById('welder_count');
  if(countLabel){
    countLabel.textContent = filtered.length;
  }

  filtered.forEach(w => {
    const position = ordered.findIndex(item => item.id === w.id) + 1;
    const tr = document.createElement('tr');
    tr.dataset.id = String(w.id);
    tr.dataset.position = String(position);
    if(selectedWelder && selectedWelder.id === w.id){
      tr.classList.add('selected');
    }
    const pansonCode = (w && w.panson_id ? getPansonCodeById(w.panson_id) : null) || (w && w.code !== undefined && w.code !== null ? String(w.code) : '');
    const pansonDisplay = pansonCode ? escapeHtml(pansonCode) : '<span class="muted">‚Äî</span>';
    const safeName = escapeHtml(w && w.name ? w.name : '');
    const summaries = buildWelderQualificationSummaries(w && w.id ? w.id : null, company);
    const nameLabel = safeName || '‚Äî';
    tr.innerHTML = `
      <td>${pansonDisplay}</td>
      <td><a href="#" data-id="${w.id}" class="welder-name-link">${nameLabel}</a></td>
      <td><div class="qualifications-summary">${summaries.statusHtml}</div></td>
      <td><div class="process-summary">${summaries.processHtml}</div></td>
      <td><button type="button" class="icon-button delete-welder" data-id="${w.id}" title="ArhiveazƒÉ ${nameLabel}" aria-label="ArhiveazƒÉ ${nameLabel}">üóëÔ∏è</button></td>
    `;
    tbody.appendChild(tr);
  });

  tbody.querySelectorAll('.welder-name-link').forEach(link => {
    link.addEventListener('click', event => {
      event.preventDefault();
      const id = Number(link.getAttribute('data-id'));
      if(Number.isNaN(id)){
        return;
      }
      const row = link.closest('tr');
      if(row){
        const position = Number(row.getAttribute('data-position'));
        if(!Number.isNaN(position)){
          selectedWelderPosition = position;
        }
      }
      selectWelder(id);
    });
  });

  tbody.querySelectorAll('.delete-welder').forEach(button => {
    button.addEventListener('click', event => {
      event.preventDefault();
      event.stopPropagation();
      const id = Number(button.getAttribute('data-id'));
      if(Number.isNaN(id)){
        return;
      }
      const welder = company.welders.find(w => w.id === id);
      const displayName = welder && welder.name ? welder.name : 'acest sudor';
      if(!confirm(`Sudorul ${displayName} va fi mutat √Æn arhivƒÉ. Continui?`)){
        return;
      }
      const reasonInput = prompt(`Introduce motivul arhivƒÉrii pentru ${displayName}.`);
      if(reasonInput === null){
        return;
      }
      const reason = reasonInput.trim();
      if(!reason){
        alert('Motivul arhivƒÉrii este obligatoriu.');
        return;
      }
      archiveWelder(id, reason);
    });
  });

  if(selectedWelder){
    const updated = company.welders.find(w => w.id === selectedWelder.id);
    if(updated){
      selectedWelder = updated;
      fillWelderForm(updated);
      selectedWelderPosition = getWelderPosition(updated.id);
      updateAuthorizationContext();
    } else {
      resetWelderForm();
    }
  }
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
}

function archiveWelder(id, reason){
  const company = getActiveCompany();
  const index = company.welders.findIndex(w => w.id === id);
  if(index === -1){
    return;
  }
  const welder = company.welders[index];
  const relatedQualifications = company.qualifications.filter(q => q.welder_id === id);
  company.welders.splice(index, 1);
  company.qualifications = company.qualifications.filter(q => q.welder_id !== id);
  company.archivedWelders.push({
    welder: { ...welder },
    archived_at: new Date().toISOString(),
    qualifications: relatedQualifications,
    reason: reason || '',
  });
  persistState();
  renderCompanySettings();
  updateHomeDashboard();
  if(selectedWelder && selectedWelder.id === id){
    resetWelderForm();
    closeWelderModal();
  }
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
  loadAuthorizations();
  loadProcedures();
  loadWelders();
  renderArchiveList();
}

function restoreArchivedWelder(id, fallbackIndex){
  const company = getActiveCompany();
  let index = company.archivedWelders.findIndex(entry => entry && entry.welder && entry.welder.id === id);
  if(index === -1 && typeof fallbackIndex === 'number' && fallbackIndex >= 0 && fallbackIndex < company.archivedWelders.length){
    index = fallbackIndex;
  }
  if(index === -1){
    return;
  }
  const entry = company.archivedWelders[index];
  const welderSource = entry && entry.welder ? entry.welder : null;
  if(!welderSource){
    company.archivedWelders.splice(index, 1);
    persistState();
    renderArchiveList();
    return;
  }

  const archivedWelderId = Number(welderSource.id) || 0;
  let welderId = archivedWelderId;
  const idConflict = welderId > 0 && company.welders.some(w => w.id === welderId);
  if(welderId <= 0 || idConflict){
    welderId = company.nextWelderId++;
  } else if(welderId >= company.nextWelderId){
    company.nextWelderId = welderId + 1;
  }

  const restoredWelder = {
    id: welderId,
    name: welderSource && typeof welderSource.name === 'string' ? welderSource.name : '',
    code: welderSource && welderSource.code !== undefined && welderSource.code !== null ? welderSource.code : null,
    hire_date: welderSource && welderSource.hire_date ? welderSource.hire_date : null,
    phone: welderSource && welderSource.phone ? welderSource.phone : '',
    panson_id: welderSource && welderSource.panson_id ? welderSource.panson_id : null,
    photo: normalizeWelderAttachment(welderSource && welderSource.photo ? welderSource.photo : null, 'fotografie'),
    id_card: normalizeWelderAttachment(welderSource && welderSource.id_card ? welderSource.id_card : null, 'carte_identitate'),
    diploma: normalizeWelderAttachment(welderSource && welderSource.diploma ? welderSource.diploma : null, 'diploma'),
    contract: normalizeWelderAttachment(welderSource && welderSource.contract ? welderSource.contract : null, 'contract'),
    authorization_dossier: Array.isArray(welderSource && welderSource.authorization_dossier)
      ? welderSource.authorization_dossier.map(item => normalizeDossierItem(item, 'document_autorizare')).filter(Boolean)
      : [],
    welding_log: normalizeWeldingLog(welderSource && (welderSource.welding_log || welderSource.weldingLog)),
  };
  company.welders.push(restoredWelder);

  const existingQualificationIds = new Set(company.qualifications.map(q => q.id));
  const restoredQualifications = Array.isArray(entry.qualifications)
    ? entry.qualifications.map(q => ({ ...q }))
    : [];

  restoredQualifications.forEach(q => {
    const originalCategory = q && typeof q.category === 'string' ? q.category : DEFAULT_QUALIFICATION_CATEGORY;
    const category = QUALIFICATION_CATEGORIES.includes(originalCategory)
      ? originalCategory
      : DEFAULT_QUALIFICATION_CATEGORY;
    let qualificationId = Number(q && q.id) || 0;
    if(qualificationId <= 0 || existingQualificationIds.has(qualificationId)){
      qualificationId = company.nextQualificationId++;
    } else if(qualificationId >= company.nextQualificationId){
      company.nextQualificationId = qualificationId + 1;
    }
    existingQualificationIds.add(qualificationId);

    const originalWelderId = q && q.welder_id !== undefined && q.welder_id !== null
      ? Number(q.welder_id)
      : null;
    const targetWelderId = originalWelderId === archivedWelderId ? welderId : originalWelderId;

    const defaultStandard = category === 'procedee' ? DEFAULT_PROCEDURE_STANDARD : DEFAULT_AUTH_STANDARD;
    const standard = q && q.standard ? q.standard : defaultStandard;
    const attachment = category === 'autorizatii' && q && q.attachment
      ? normalizeAttachment(q.attachment, 'autorizatie.pdf')
      : null;
    company.qualifications.push({
      id: qualificationId,
      welder_id: targetWelderId,
      category,
      standard,
      process: q && q.process ? q.process : '',
      position: q && q.position ? q.position : '',
      p_number: q && q.p_number ? q.p_number : null,
      thickness_range: q && q.thickness_range ? q.thickness_range : null,
      product: q && q.product ? q.product : '',
      certificate_no: q && q.certificate_no ? q.certificate_no : null,
      issuer: q && q.issuer ? q.issuer : null,
      expiry_date: category === 'autorizatii' ? (q && q.expiry_date ? q.expiry_date : null) : null,
      attachment,
    });
  });

  company.archivedWelders.splice(index, 1);
  persistState();
  renderCompanySettings();
  updateHomeDashboard();
  syncStandardsFromState();
  renderAuthStandardTabs();
  renderStandardManagerList();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  selectWelder(restoredWelder.id);
  renderArchiveList();
}

function appendWeldingLogRow(entry){
  const tbody = document.getElementById('w_welding_log_tbody');
  if(!tbody){
    return;
  }
  const source = entry && typeof entry === 'object' ? { ...entry } : createEmptyWeldingLogEntry();
  const rowId = source.id && typeof source.id === 'string' ? source.id : generateDocumentId('wlog');
  const tr = document.createElement('tr');
  tr.setAttribute('data-row-id', rowId);
  const fieldConfigs = [
    { key: 'date', type: 'date' },
    { key: 'contract', type: 'text' },
    { key: 'work', type: 'textarea' },
    { key: 'material', type: 'textarea' },
    { key: 'thickness', type: 'text' },
    { key: 'process', type: 'text' },
    { key: 'position', type: 'text' },
    { key: 'ndt', type: 'textarea' },
    { key: 'dt', type: 'textarea' },
    { key: 'remarks', type: 'textarea' },
  ];
  fieldConfigs.forEach(config => {
    const td = document.createElement('td');
    let input;
    if(config.type === 'textarea'){
      input = document.createElement('textarea');
    } else {
      input = document.createElement('input');
      input.type = config.type === 'date' ? 'date' : 'text';
    }
    input.className = 'log-field';
    input.setAttribute('data-field', config.key);
    const value = source[config.key] !== undefined && source[config.key] !== null ? String(source[config.key]) : '';
    input.value = value;
    td.appendChild(input);
    tr.appendChild(td);
  });
  const actionCell = document.createElement('td');
  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'btn ghost small';
  removeBtn.textContent = '»òterge';
  removeBtn.addEventListener('click', () => {
    tr.remove();
  });
  actionCell.appendChild(removeBtn);
  tr.appendChild(actionCell);
  tbody.appendChild(tr);
}

function renderWeldingLogEditor(log){
  const tbody = document.getElementById('w_welding_log_tbody');
  if(!tbody){
    return;
  }
  tbody.innerHTML = '';
  const entries = Array.isArray(log && log.entries) ? log.entries : [];
  if(entries.length === 0){
    appendWeldingLogRow(createEmptyWeldingLogEntry());
    return;
  }
  entries.forEach(entry => appendWeldingLogRow(entry));
}

function collectWeldingLogFromForm(){
  const numberInput = document.getElementById('w_log_number');
  const number = numberInput && typeof numberInput.value === 'string' ? numberInput.value.trim() : '';
  const includeInput = document.getElementById('w_log_include');
  const includeInDossier = includeInput ? includeInput.checked : true;
  const tbody = document.getElementById('w_welding_log_tbody');
  const entries = [];
  if(tbody){
    tbody.querySelectorAll('tr').forEach(row => {
      const base = createEmptyWeldingLogEntry();
      const rowId = row.getAttribute('data-row-id');
      if(rowId){
        base.id = rowId;
      }
      row.querySelectorAll('[data-field]').forEach(input => {
        const field = input.getAttribute('data-field');
        if(!field || !(field in base)){
          return;
        }
        const value = input.value !== undefined && input.value !== null ? String(input.value).trim() : '';
        base[field] = value;
      });
      const hasContent = base.date || base.contract || base.work || base.material || base.thickness
        || base.process || base.position || base.ndt || base.dt || base.remarks;
      if(hasContent){
        entries.push(base);
      }
    });
  }
  return { number, entries, include_in_dossier: includeInDossier };
}

function fillWelderForm(w){
  const nameInput = document.getElementById('w_name');
  if(nameInput){
    nameInput.value = w && typeof w.name === 'string' ? w.name : '';
  }
  const phoneInput = document.getElementById('w_phone');
  if(phoneInput){
    phoneInput.value = w && typeof w.phone === 'string' ? w.phone : '';
  }
  const hireInput = document.getElementById('w_hire');
  if(hireInput){
    hireInput.value = w && w.hire_date ? w.hire_date : '';
  }
  populatePansonSelect();
  const pansonSelect = document.getElementById('w_panson');
  if(pansonSelect){
    const value = w && w.panson_id ? String(w.panson_id) : '';
    pansonSelect.value = Array.from(pansonSelect.options).some(opt => opt.value === value) ? value : '';
  }
  const manualInput = document.getElementById('w_code_manual');
  if(manualInput){
    manualInput.value = w && w.code !== undefined && w.code !== null ? w.code : '';
  }
  const idExpiryInput = document.getElementById('w_id_card_expiry');
  if(idExpiryInput){
    idExpiryInput.value = w && w.id_card_expiry ? w.id_card_expiry : '';
  }
  const aptitudeExpiryInput = document.getElementById('w_aptitude_expiry');
  if(aptitudeExpiryInput){
    aptitudeExpiryInput.value = w && w.aptitude_expiry ? w.aptitude_expiry : '';
  }
  updateAttachmentPreview('w_photo_preview', w && w.photo ? w.photo : null, {
    viewLabel: 'VizualizeazƒÉ fotografia',
    downloadLabel: 'DescarcƒÉ fotografia',
    fallbackName: 'foto',
  });
  updateAttachmentPreview('w_id_card_preview', w && w.id_card ? w.id_card : null, {
    viewLabel: 'VizualizeazƒÉ cartea de identitate',
    downloadLabel: 'DescarcƒÉ cartea de identitate',
    fallbackName: 'ci',
    meta: w && w.id_card_expiry ? `ExpirƒÉ la ${formatDisplayDate(w.id_card_expiry)}` : '',
  });
  updateAttachmentPreview('w_diploma_preview', w && w.diploma ? w.diploma : null, {
    viewLabel: 'VizualizeazƒÉ diploma',
    downloadLabel: 'DescarcƒÉ diploma',
    fallbackName: 'diploma',
  });
  updateAttachmentPreview('w_contract_preview', w && w.contract ? w.contract : null, {
    viewLabel: 'VizualizeazƒÉ contractul',
    downloadLabel: 'DescarcƒÉ contractul',
    fallbackName: 'contract',
  });
  updateAttachmentPreview('w_aptitude_preview', w && w.aptitude ? w.aptitude : null, {
    viewLabel: 'VizualizeazƒÉ fi»ôa de aptitudini',
    downloadLabel: 'DescarcƒÉ fi»ôa de aptitudini',
    fallbackName: 'fisa_aptitudini',
    meta: w && w.aptitude_expiry ? `ExpirƒÉ la ${formatDisplayDate(w.aptitude_expiry)}` : '',
  });
  updateAttachmentPreview('w_bundle_preview', w && w.bundle ? w.bundle : null, {
    viewLabel: 'VizualizeazƒÉ documentele personale',
    downloadLabel: 'DescarcƒÉ documentele personale',
    fallbackName: 'documente_personale',
  });
  ['w_photo','w_id_card','w_diploma','w_contract','w_aptitude','w_bundle'].forEach(id => {
    const input = document.getElementById(id);
    if(input){
      input.value = '';
    }
  });
  const log = ensureWelderWeldingLog(w);
  const logNumberInput = document.getElementById('w_log_number');
  if(logNumberInput){
    logNumberInput.value = log && log.number ? log.number : '';
  }
  const logIncludeCheckbox = document.getElementById('w_log_include');
  if(logIncludeCheckbox){
    logIncludeCheckbox.checked = isWeldingLogIncluded(log);
  }
  renderWeldingLogEditor(log);
  loadAuthorizationDossier();
}

function resetWelderForm(){
  selectedWelder = null;
  selectedWelderPosition = null;
  const nameInput = document.getElementById('w_name');
  if(nameInput){
    nameInput.value = '';
  }
  const phoneInput = document.getElementById('w_phone');
  if(phoneInput){
    phoneInput.value = '';
  }
  const hireInput = document.getElementById('w_hire');
  if(hireInput){
    hireInput.value = '';
  }
  const manualInput = document.getElementById('w_code_manual');
  if(manualInput){
    manualInput.value = '';
  }
  const idExpiryInput = document.getElementById('w_id_card_expiry');
  if(idExpiryInput){
    idExpiryInput.value = '';
  }
  const aptitudeExpiryInput = document.getElementById('w_aptitude_expiry');
  if(aptitudeExpiryInput){
    aptitudeExpiryInput.value = '';
  }
  populatePansonSelect();
  const pansonSelect = document.getElementById('w_panson');
  if(pansonSelect){
    pansonSelect.value = '';
  }
  ['w_photo_preview','w_id_card_preview','w_diploma_preview','w_contract_preview','w_aptitude_preview','w_bundle_preview'].forEach(id => {
    const container = document.getElementById(id);
    if(container){
      container.innerHTML = '';
    }
  });
  ['w_photo','w_id_card','w_diploma','w_contract','w_aptitude','w_bundle'].forEach(id => {
    const input = document.getElementById(id);
    if(input){
      input.value = '';
    }
  });
  const logNumberInput = document.getElementById('w_log_number');
  if(logNumberInput){
    logNumberInput.value = '';
  }
  const logIncludeCheckbox = document.getElementById('w_log_include');
  if(logIncludeCheckbox){
    logIncludeCheckbox.checked = true;
  }
  renderWeldingLogEditor(createEmptyWeldingLog());
  updateAuthorizationContext();
  loadAuthorizationDossier();
}

function findDuplicateWelder(payload, excludeId){
  const targetParts = getNameParts(payload.name);
  const codeToCheck = payload.code ? String(payload.code).trim().toLowerCase() : '';
  if(!targetParts.full && !codeToCheck){
    return null;
  }
  const company = getActiveCompany();
  return company.welders.find(function(w){
    if(excludeId && w.id === excludeId){
      return false;
    }
    const existingParts = getNameParts(w && w.name ? w.name : '');
    const welderCode = w && w.code !== undefined && w.code !== null
      ? String(w.code).trim().toLowerCase()
      : '';
    const sameName = targetParts.full && existingParts.full
      ? targetParts.family === existingParts.family && targetParts.given === existingParts.given
      : false;
    if(sameName){
      return true;
    }
    if(codeToCheck && welderCode && welderCode === codeToCheck){
      return true;
    }
    return false;
  }) || null;
}

async function saveWelder(){
  const nameInput = document.getElementById('w_name');
  const phoneInput = document.getElementById('w_phone');
  const hireInput = document.getElementById('w_hire');
  const pansonSelect = document.getElementById('w_panson');
  const manualCodeInput = document.getElementById('w_code_manual');
  const name = normalizeNameInput(nameInput ? nameInput.value : '');
  if(!name){
    alert('CompleteazƒÉ numele.');
    return;
  }
  const phone = phoneInput && phoneInput.value ? phoneInput.value.trim() : '';
  const hireDate = hireInput && hireInput.value ? hireInput.value : null;
  const idCardExpiryInput = document.getElementById('w_id_card_expiry');
  const aptitudeExpiryInput = document.getElementById('w_aptitude_expiry');
  const idCardExpiry = normalizeDateValue(idCardExpiryInput && idCardExpiryInput.value ? idCardExpiryInput.value : null);
  const aptitudeExpiry = normalizeDateValue(aptitudeExpiryInput && aptitudeExpiryInput.value ? aptitudeExpiryInput.value : null);
  const company = getActiveCompany();

  let pansonId = null;
  let code = null;
  if(pansonSelect && pansonSelect.value){
    const numeric = Number(pansonSelect.value);
    if(!Number.isNaN(numeric)){
      const panson = company.pansoane.find(entry => entry && entry.id === numeric);
      if(panson){
        pansonId = panson.id;
        code = panson.code || null;
      }
    }
  }
  if(!code && manualCodeInput && manualCodeInput.value){
    const manual = manualCodeInput.value.trim();
    code = manual ? manual : null;
  }

  const payload = {
    name,
    code,
    phone,
    hire_date: hireDate,
    panson_id: pansonId,
    id_card_expiry: idCardExpiry || null,
    aptitude_expiry: aptitudeExpiry || null,
  };

  const excludeId = selectedWelder ? selectedWelder.id : null;
  const duplicate = findDuplicateWelder(payload, excludeId);
  if(duplicate){
    alert('Sudorul existƒÉ deja √Æn listƒÉ. VerificƒÉ numele sau codul de identificare.');
    return;
  }

  const attachmentSources = {
    photo: selectedWelder && selectedWelder.photo ? { ...selectedWelder.photo } : null,
    id_card: selectedWelder && selectedWelder.id_card ? { ...selectedWelder.id_card } : null,
    diploma: selectedWelder && selectedWelder.diploma ? { ...selectedWelder.diploma } : null,
    contract: selectedWelder && selectedWelder.contract ? { ...selectedWelder.contract } : null,
    aptitude: selectedWelder && selectedWelder.aptitude ? { ...selectedWelder.aptitude } : null,
    bundle: selectedWelder && selectedWelder.bundle ? { ...selectedWelder.bundle } : null,
  };

  const fileDescriptors = [
    { id: 'w_photo', key: 'photo', label: 'fotografie' },
    { id: 'w_id_card', key: 'id_card', label: 'carte_identitate' },
    { id: 'w_diploma', key: 'diploma', label: 'diploma' },
    { id: 'w_contract', key: 'contract', label: 'contract' },
    { id: 'w_aptitude', key: 'aptitude', label: 'fisa_aptitudini' },
    { id: 'w_bundle', key: 'bundle', label: 'documente_personale' },
  ];

  for(const descriptor of fileDescriptors){
    const input = document.getElementById(descriptor.id);
    if(input && input.files && input.files[0]){
      const file = input.files[0];
      try {
        const dataUrl = await readFileAsDataURL(file);
        attachmentSources[descriptor.key] = {
          name: file.name || descriptor.label,
          data: dataUrl,
          type: file.type || '',
        };
      } catch (err) {
        console.error('Nu s-a putut citi fi»ôierul ata»ôat pentru', descriptor.key, err);
        alert('Nu s-a putut citi unul dintre fi»ôierele ata»ôate. √éncearcƒÉ din nou.');
        return;
      }
    }
  }

  if(attachmentSources.id_card && !idCardExpiry){
    alert('Introdu data de expirare pentru cartea de identitate.');
    return;
  }
  if(attachmentSources.aptitude && !aptitudeExpiry){
    alert('Introdu data de expirare pentru fi»ôa de aptitudini.');
    return;
  }

  const logPayload = collectWeldingLogFromForm();
  let normalizedLog = normalizeWeldingLog(logPayload);
  normalizedLog = await attachWeldingLogPdf(payload.name, normalizedLog, company);

  if(selectedWelder){
    const idx = company.welders.findIndex(w => w.id === selectedWelder.id);
    if(idx !== -1){
      company.welders[idx] = {
        ...company.welders[idx],
        ...payload,
        photo: attachmentSources.photo,
        id_card: attachmentSources.id_card,
        diploma: attachmentSources.diploma,
        contract: attachmentSources.contract,
        aptitude: attachmentSources.aptitude,
        bundle: attachmentSources.bundle,
        welding_log: normalizedLog,
      };
    }
  } else {
    const newWelder = {
      id: company.nextWelderId++,
      ...payload,
      photo: attachmentSources.photo,
      id_card: attachmentSources.id_card,
      diploma: attachmentSources.diploma,
      contract: attachmentSources.contract,
      aptitude: attachmentSources.aptitude,
      bundle: attachmentSources.bundle,
      authorization_dossier: [],
      welding_log: normalizedLog,
    };
    company.welders.push(newWelder);
  }

  persistState();
  renderCompanySettings();
  updateHomeDashboard();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  loadWelders();
  closeWelderModal();
  selectedWelder = null;
  selectedWelderPosition = null;
  resetWelderForm();
  updateAuthorizationContext();
  loadAuthorizations();
  loadProcedures();
}

async function previewWeldingLogPdf(){
  const nameInput = document.getElementById('w_name');
  const formName = nameInput && typeof nameInput.value === 'string' ? nameInput.value.trim() : '';
  const fallbackName = selectedWelder && selectedWelder.name ? selectedWelder.name : 'Sudor';
  const welderName = formName || fallbackName;
  const logPayload = collectWeldingLogFromForm();
  const normalizedLog = normalizeWeldingLog(logPayload);
  try {
    const attachment = await buildWeldingLogPdfAttachment(welderName, normalizedLog, getActiveCompany());
    if(!attachment){
      alert('Fi»ôa de eviden»õƒÉ nu poate fi generatƒÉ √Æn format PDF √Æn acest moment.');
      return;
    }
    openDocumentViewer(attachment, attachment.name || `${welderName} ‚Äì Fi»ôa de eviden»õƒÉ a lucrƒÉrilor de sudare`);
  } catch (error) {
    console.error('Previzualizarea fi»ôei de eviden»õƒÉ a e»ôuat.', error);
    alert('Previzualizarea fi»ôei de eviden»õƒÉ nu a putut fi generatƒÉ.');
  }
}

function collectAuthorizationPayload(){
  return {
    standard: document.getElementById('auth_standard').value,
    process: document.getElementById('auth_process').value,
    position: document.getElementById('auth_position').value,
    base_quality: document.getElementById('auth_base_quality').value.trim(),
    base_material: document.getElementById('auth_base_material').value.trim(),
    filler_material: document.getElementById('auth_filler_material').value.trim(),
    base_dimension: document.getElementById('auth_base_dimension').value.trim(),
    diameter: document.getElementById('auth_diameter').value.trim(),
    thickness_domain: document.getElementById('auth_thickness_domain').value.trim(),
    certificate_no: document.getElementById('auth_cert').value.trim() || null,
    issuer: document.getElementById('auth_issuer').value.trim() || null,
    expiry_date: document.getElementById('auth_expiry').value || null,
    observation: document.getElementById('auth_observation').value.trim(),
  };
}

function collectProcedurePayload(){
  return {
    standard: document.getElementById('proc_standard').value,
    process: document.getElementById('proc_process').value,
    position: document.getElementById('proc_position').value,
    p_number: document.getElementById('proc_pno').value.trim() || null,
    thickness_range: document.getElementById('proc_thk').value.trim() || null,
    product: document.getElementById('proc_product').value,
    certificate_no: document.getElementById('proc_cert').value.trim() || null,
    issuer: document.getElementById('proc_issuer').value.trim() || null,
  };
}

async function addAuthorization(){
  const company = getActiveCompany();
  const welderSelect = document.getElementById('auth_welder_select');
  const attachmentInput = document.getElementById('auth_attachment');
  const welderId = welderSelect && welderSelect.value ? Number(welderSelect.value) : NaN;
  if(Number.isNaN(welderId) || welderId <= 0){
    alert('SelecteazƒÉ un sudor pentru autoriza»õie.');
    return;
  }
  const welder = company.welders.find(w => w.id === welderId);
  if(!welder){
    alert('Sudorul selectat nu mai existƒÉ √Æn companie.');
    populateAuthorizationWelderSelect();
    populateAuthorizationProcedureSelect();
    return;
  }
  const payload = collectAuthorizationPayload();
  if(!payload.standard){
    alert('Alege standardul autoriza»õiei.');
    return;
  }
  const procedureSelect = document.getElementById('auth_procedure_select');
  const procedureIdValue = procedureSelect && procedureSelect.value ? Number(procedureSelect.value) : NaN;
  const procedureId = Number.isNaN(procedureIdValue) ? null : procedureIdValue;
  if(procedureSelect && procedureSelect.options.length <= 1){
    alert('AdaugƒÉ mai √Ænt√¢i un procedeu omologat pentru a putea √Ænregistra autoriza»õia.');
    return;
  }
  if(!procedureId){
    alert('SelecteazƒÉ procedeul omologat corespunzƒÉtor acestei autoriza»õii.');
    return;
  }
  let attachment = null;
  if(attachmentInput && attachmentInput.files && attachmentInput.files[0]){
    const file = attachmentInput.files[0];
    const isPdf = file.type ? file.type === 'application/pdf' : file.name.toLowerCase().endsWith('.pdf');
    if(!isPdf){
      alert('Fi»ôierul ata»ôat trebuie sƒÉ fie √Æn format PDF.');
      return;
    }
    try {
      const dataUrl = await readFileAsDataURL(file);
      attachment = {
        name: file.name || 'autorizatie.pdf',
        data: dataUrl,
        type: file.type || 'application/pdf',
      };
    } catch (err) {
      console.error('Nu s-a putut citi fi»ôierul PDF ata»ôat.', err);
      alert('Nu s-a putut citi fi»ôierul PDF ata»ôat. √éncearcƒÉ din nou.');
      return;
    }
  }

  const qualification = {
    id: company.nextQualificationId++,
    welder_id: welder.id,
    category: 'autorizatii',
    ...payload,
    procedure_id: procedureId,
    attachment,
  };
  company.qualifications.push(qualification);
  persistState();
  renderCompanySettings();
  updateHomeDashboard();
  if(attachmentInput){
    attachmentInput.value = '';
  }
  if(!selectedWelder || selectedWelder.id !== welder.id){
    selectWelder(welder.id);
  } else {
    loadAuthorizations();
    loadWelders();
  }
}

async function addProcedure(){
  const company = getActiveCompany();
  const payload = collectProcedurePayload();
  if(!payload.standard){
    alert('SelecteazƒÉ standardul procedurii.');
    return;
  }
  const welderSelect = document.getElementById('proc_welder_select');
  const welderIdValue = welderSelect && welderSelect.value ? Number(welderSelect.value) : NaN;
  const welderId = Number.isNaN(welderIdValue) || welderIdValue <= 0 ? null : welderIdValue;
  const attachmentInput = document.getElementById('proc_attachment');
  let attachment = null;
  if(attachmentInput && attachmentInput.files && attachmentInput.files[0]){
    const file = attachmentInput.files[0];
    const isPdf = file.type ? file.type === 'application/pdf' : file.name.toLowerCase().endsWith('.pdf');
    if(!isPdf){
      alert('Fi»ôierul procedurii trebuie sƒÉ fie √Æn format PDF.');
      return;
    }
    try {
      const dataUrl = await readFileAsDataURL(file);
      attachment = {
        name: file.name || 'procedeu.pdf',
        data: dataUrl,
        type: file.type || 'application/pdf',
      };
    } catch (err) {
      console.error('Nu s-a putut citi fi»ôierul de procedeu.', err);
      alert('√éncƒÉrcarea fi»ôierului de procedeu a e»ôuat.');
      return;
    }
  }
  const qualification = {
    id: company.nextQualificationId++,
    welder_id: welderId,
    category: 'procedee',
    ...payload,
    attachment,
    expiry_date: null,
  };
  company.qualifications.push(qualification);
  persistState();
  renderCompanySettings();
  updateHomeDashboard();
  loadProcedures();
  populateAuthorizationProcedureSelect();
  loadWelders();
  if(attachmentInput){
    attachmentInput.value = '';
  }
}

function removeQualification(id){
  const company = getActiveCompany();
  const idx = company.qualifications.findIndex(q => q.id === id);
  if(idx === -1) return;
  company.qualifications.splice(idx, 1);
  persistState();
  renderCompanySettings();
  updateHomeDashboard();
  loadAuthorizations();
  loadProcedures();
  populateAuthorizationProcedureSelect();
  loadWelders();
}

function applySelectedWelderContext(welder){
  if(welder && welder.id){
    selectedWelder = welder;
    selectedWelderPosition = getWelderPosition(welder.id);
  } else {
    selectedWelder = null;
    selectedWelderPosition = null;
  }
  updateAuthorizationContext();
  loadAuthorizations();
  loadProcedures();
  loadWelders();
  loadAuthorizationDossier();
}

function selectAuthorizationWelder(id){
  const company = getActiveCompany();
  let welder = null;
  if(Number.isInteger(id) && id > 0){
    welder = company.welders.find(w => w.id === id) || null;
    if(!welder){
      const archived = company.archivedWelders.find(entry => entry && entry.welder && entry.welder.id === id);
      welder = archived && archived.welder ? archived.welder : null;
    }
  }
  applySelectedWelderContext(welder);
}

function loadAuthorizations(){
  const container = document.getElementById('auth_existing_tables');
  const emptyState = document.getElementById('auth_empty_state');
  const tabsContainer = document.getElementById('auth_existing_tabs');
  const hint = document.getElementById('auth_existing_hint');
  if(!container || !tabsContainer){
    return;
  }
  container.innerHTML = '';
  tabsContainer.innerHTML = '';
  const company = getActiveCompany();
  const authorizations = company.qualifications.filter(q => q && q.category === 'autorizatii');
  if(authorizations.length === 0){
    if(emptyState){
      emptyState.textContent = 'Nu existƒÉ autoriza»õii salvate.';
      emptyState.classList.remove('hidden');
    }
    if(hint){
      hint.textContent = 'nu existƒÉ autoriza»õii salvate';
    }
    tabsContainer.classList.add('hidden');
    return;
  }
  if(emptyState){
    emptyState.classList.add('hidden');
  }
  const groupsMap = new Map();
  authorizations.forEach(q => {
    const standardEntry = getStandardById(q.standard);
    const groupKey = standardEntry && standardEntry.group ? standardEntry.group : 'ALTE';
    if(!groupsMap.has(groupKey)){
      groupsMap.set(groupKey, []);
    }
    groupsMap.get(groupKey).push(q);
  });
  const orderedGroups = Array.from(groupsMap.keys()).sort((a, b) => a.localeCompare(b, 'ro', { sensitivity: 'base' }));
  if(!activeAuthorizationExistingGroup || !groupsMap.has(activeAuthorizationExistingGroup)){
    activeAuthorizationExistingGroup = orderedGroups[0];
  }
  tabsContainer.classList.toggle('hidden', orderedGroups.length <= 1);
  orderedGroups.forEach(group => {
    const button = document.createElement('button');
    button.type = 'button';
    button.textContent = `${group} (${groupsMap.get(group).length})`;
    button.dataset.group = group;
    const isActive = group === activeAuthorizationExistingGroup;
    button.classList.toggle('active', isActive);
    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    button.addEventListener('click', () => {
      activeAuthorizationExistingGroup = group;
      loadAuthorizations();
    });
    tabsContainer.appendChild(button);
  });

  const activeList = groupsMap.get(activeAuthorizationExistingGroup) || [];
  activeList.sort((a, b) => {
    const welderA = findWelderNameById(a.welder_id) || '';
    const welderB = findWelderNameById(b.welder_id) || '';
    const compareNames = welderA.localeCompare(welderB, 'ro', { sensitivity: 'base' });
    if(compareNames !== 0){
      return compareNames;
    }
    const dateA = a && a.expiry_date ? a.expiry_date : '';
    const dateB = b && b.expiry_date ? b.expiry_date : '';
    return dateA.localeCompare(dateB);
  });

  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Nr. crt.</th>
        <th>Nume / panson</th>
        <th>Procedeu de sudare</th>
        <th>Calitate mat. de bazƒÉ</th>
        <th>Materiale de bazƒÉ</th>
        <th>Material de adaos</th>
        <th>Pozi»õie de sudare</th>
        <th>Dim. mat. de bazƒÉ</th>
        <th>Diametru / grosime</th>
        <th>Domeniu grosime</th>
        <th>Obs</th>
        <th>Document</th>
        <th></th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  const tbody = table.querySelector('tbody');

  activeList.forEach((q, index) => {
    const tr = document.createElement('tr');
    const welderName = q.welder_id ? findWelderNameById(q.welder_id) : '';
    let pansonCode = '';
    if(q.welder_id){
      const welderRecord = company.welders.find(w => w.id === q.welder_id);
      if(welderRecord){
        pansonCode = welderRecord.code || getPansonCodeById(welderRecord.panson_id) || '';
      } else {
        const archivedRecord = company.archivedWelders.find(entry => entry && entry.welder && entry.welder.id === q.welder_id);
        if(archivedRecord && archivedRecord.welder){
          pansonCode = archivedRecord.welder.code || getPansonCodeById(archivedRecord.welder.panson_id) || '';
        }
      }
    }
    const nameHtml = welderName ? escapeHtml(welderName) : '<span class="muted">(fƒÉrƒÉ sudor)</span>';
    const pansonHtml = pansonCode ? `<div class="muted">${escapeHtml(pansonCode)}</div>` : '';
    const formatValue = value => value ? escapeHtml(value) : '<span class="muted">‚Äî</span>';
    const certificateLinks = q && q.attachment && q.attachment.data
      ? createAttachmentActionsHtml(q.attachment, { fallbackName: 'autorizatie.pdf' })
      : '';
    const procedureLabel = resolveProcedureLabel(company, q && q.procedure_id);
    const processParts = [];
    if(q && q.process){
      processParts.push(`<div>${escapeHtml(q.process)}</div>`);
    }
    if(procedureLabel){
      processParts.push(`<div class="muted">Procedeu: ${escapeHtml(procedureLabel)}</div>`);
    }
    const processCell = processParts.length ? processParts.join('') : '<span class="muted">‚Äî</span>';
    const observationParts = [];
    if(q && q.observation){
      observationParts.push(escapeHtml(q.observation));
    }
    if(q && q.expiry_date){
      const status = statusBadge(q.expiry_date);
      observationParts.push(`${status} <span class="muted">ExpirƒÉ: ${escapeHtml(q.expiry_date)}</span>`);
    }
    const observationCell = observationParts.length ? observationParts.join('<br>') : '<span class="muted">‚Äî</span>';
    const certificateCell = certificateLinks || '<span class="muted">‚Äî</span>';
    tr.innerHTML = `
      <td>${index + 1}</td>
      <td>${nameHtml}${pansonHtml}</td>
      <td>${processCell}</td>
      <td>${formatValue(q && q.base_quality)}</td>
      <td>${formatValue(q && q.base_material)}</td>
      <td>${formatValue(q && q.filler_material)}</td>
      <td>${formatValue(q && q.position)}</td>
      <td>${formatValue(q && q.base_dimension)}</td>
      <td>${formatValue(q && q.diameter)}</td>
      <td>${formatValue(q && q.thickness_domain)}</td>
      <td>${observationCell}</td>
      <td>${certificateCell}</td>
      <td>
        <div class="attachment-actions">
          <button type="button" class="btn ghost small" data-action="renew" data-id="${q.id}">Reautorizare</button>
          <button type="button" class="btn ghost small" data-action="extend" data-id="${q.id}">Prelungire</button>
          <button type="button" class="btn ghost small" data-action="delete" data-id="${q.id}">»òterge</button>
        </div>
      </td>
    `;
    tbody.appendChild(tr);
  });

  tbody.querySelectorAll('button[data-action="delete"]').forEach(button => {
    button.addEventListener('click', () => {
      const id = Number(button.getAttribute('data-id'));
      if(Number.isNaN(id)){
        return;
      }
      if(confirm('»òtergi aceastƒÉ autoriza»õie?')){
        removeQualification(id);
      }
    });
  });

  tbody.querySelectorAll('button[data-action="renew"]').forEach(button => {
    button.addEventListener('click', () => {
      const id = Number(button.getAttribute('data-id'));
      if(Number.isNaN(id)){
        return;
      }
      pushAuthorizationToDossier(id, 'autorizare');
    });
  });

  tbody.querySelectorAll('button[data-action="extend"]').forEach(button => {
    button.addEventListener('click', () => {
      const id = Number(button.getAttribute('data-id'));
      if(Number.isNaN(id)){
        return;
      }
      pushAuthorizationToDossier(id, 'prelungire');
    });
  });

  container.appendChild(table);
  if(hint){
    hint.textContent = `total autoriza»õii: ${authorizations.length}`;
  }
}

function loadProcedures(){
  const tbody = document.getElementById('procedures_tbody');
  const wrap = document.getElementById('procedures_list_wrap');
  const emptyState = document.getElementById('procedures_empty_state');
  if(!tbody){
    return;
  }
  tbody.innerHTML = '';
  const company = getActiveCompany();
  const list = company.qualifications.filter(q => q && q.category === 'procedee')
    .sort((a, b) => {
      const keyA = `${getStandardLabel(a.standard)} ${a.process || ''} ${a.certificate_no || ''}`;
      const keyB = `${getStandardLabel(b.standard)} ${b.process || ''} ${b.certificate_no || ''}`;
      return keyA.localeCompare(keyB, 'ro', { sensitivity: 'base' });
    });
  if(list.length === 0){
    if(wrap){
      wrap.classList.add('hidden');
    }
    if(emptyState){
      emptyState.classList.remove('hidden');
    }
    return;
  }
  if(wrap){
    wrap.classList.remove('hidden');
  }
  if(emptyState){
    emptyState.classList.add('hidden');
  }
  list.forEach(q => {
    const tr = document.createElement('tr');
    const standardLabel = getStandardLabel(q.standard);
    const ownerName = q && q.welder_id ? findWelderNameById(q.welder_id) : '';
    const certificateValue = q && q.certificate_no ? q.certificate_no : '';
    let certificateCell = certificateValue ? escapeHtml(certificateValue) : '<span class="muted">‚Äî</span>';
    if(q && q.attachment && q.attachment.data){
      certificateCell += createAttachmentActionsHtml(q.attachment, { fallbackName: 'procedeu.pdf' });
    }
    tr.innerHTML = `
      <td>${escapeHtml(standardLabel)}</td>
      <td>${escapeHtml(q && q.process ? q.process : '')}</td>
      <td>${escapeHtml(q && q.position ? q.position : '')}</td>
      <td>${escapeHtml(q && q.p_number ? q.p_number : '')}</td>
      <td>${escapeHtml(q && q.thickness_range ? q.thickness_range : '')}</td>
      <td>${escapeHtml(q && q.product ? q.product : '')}</td>
      <td>${certificateCell}</td>
      <td>${ownerName ? escapeHtml(ownerName) : '<span class="muted">general</span>'}</td>
      <td><button class="btn ghost" data-id="${q.id}" data-action="del">»òterge</button></td>
    `;
    tbody.appendChild(tr);
  });

  tbody.querySelectorAll('button[data-action="del"]').forEach(button => {
    button.addEventListener('click', () => {
      const id = Number(button.getAttribute('data-id'));
      if(Number.isNaN(id)){
        return;
      }
      if(confirm('»òtergi acest procedeu omologat?')){
        removeQualification(id);
      }
    });
  });
  populateAuthorizationProcedureSelect();
}

function selectWelder(id){
  const company = getActiveCompany();
  const welder = company.welders.find(w => w.id === id);
  if(!welder){
    applySelectedWelderContext(null);
    resetWelderForm();
    populateAuthorizationWelderSelect();
    populateProcedureWelderSelect();
    closeWelderModal();
    return;
  }
  if(activeView !== 'welders'){
    setActiveView('welders', { subview: 'welders' });
  } else if(activeWeldersSubview !== 'welders'){
    setWeldersSubview('welders');
  }
  applySelectedWelderContext(welder);
  fillWelderForm(welder);
  openWelderModal('edit');
}

async function refreshAllFromStorage(){
  const selectedId = selectedWelder ? selectedWelder.id : null;
  const previousCompanyId = state.activeCompanyId;
  if(isFileStorageMode()){
    await reloadStateFromFile();
  } else {
    state = loadState();
  }
  ensureStateStandards();
  syncStandardsFromState();
  ensureGeneralSettings();
  renderGeneralSettings();
  restartInactivityTimer();
  if(state.companies.length === 0){
    const fallback = createEmptyCompany(state.nextCompanyId || 1, 'Companie implicitƒÉ');
    state.companies.push(fallback);
    state.activeCompanyId = fallback.id;
    state.nextCompanyId = fallback.id + 1;
  }
  archiveVisible = false;
  if(!state.companies.some(company => company.id === previousCompanyId)){
    state.activeCompanyId = state.companies[0].id;
  } else {
    state.activeCompanyId = previousCompanyId;
  }
  populateCompanySelector();
  renderCompanySettings();
  updateHomeDashboard();
  renderAuthStandardTabs();
  renderStandardManagerList();
  const company = getActiveCompany();
  if(selectedId && company.welders.some(w => w.id === selectedId)){
    selectWelder(selectedId);
  } else {
    resetWelderForm();
    closeWelderModal();
  }
  loadWelders();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
  loadAuthorizations();
  loadProcedures();
  renderArchiveList();
  updateTopbarCompanyLogo();
  loadAuthorizationDossier();
  loadProcedureDossier();
}

window.addEventListener('DOMContentLoaded', async () => {
  await restorePersistedStorageHandles();
  if(isFileStorageMode()){
    await reloadStateFromFile();
  }
  ensureStateStandards();
  syncStandardsFromState();
  ensureGeneralSettings();
  initAuthentication();
  renderGeneralSettings();
  document.body.addEventListener('click', event => {
    const closeModalTrigger = event.target.closest('[data-action="close-welder-modal"]');
    if(closeModalTrigger){
      event.preventDefault();
      closeWelderModal();
      return;
    }
    const closeBrandingTrigger = event.target.closest('[data-action="close-branding-modal"]');
    if(closeBrandingTrigger){
      event.preventDefault();
      closeBrandingModal();
      return;
    }
    const trigger = event.target.closest('[data-attachment-view]');
    if(trigger){
      const attachmentId = trigger.getAttribute('data-attachment-view');
      const attachment = getAttachmentById(attachmentId);
      if(!attachment){
        alert('Documentul nu a putut fi gƒÉsit.');
      } else {
        const name = trigger.getAttribute('data-attachment-name') || attachment.name || 'Document';
        openDocumentViewer(attachment, name);
      }
      event.preventDefault();
      return;
    }
    if(event.target.matches('[data-action="close-viewer"]')){
      closeDocumentViewer();
    }
  });
  const dossierDetail = document.getElementById('auth_dossier_detail');
  if(dossierDetail){
    dossierDetail.addEventListener('change', event => {
      const target = event.target;
      if(target && target.matches('input[data-step-visibility]')){
        handleAuthorizationStepVisibilityChange(target);
      }
    });
  }
  const viewer = document.getElementById('document_viewer');
  if(viewer){
    viewer.addEventListener('click', event => {
      if(event.target === viewer){
        closeDocumentViewer();
      }
    });
  }
  const inactivityInput = document.getElementById('general_inactivity_minutes');
  if(inactivityInput){
    inactivityInput.addEventListener('change', () => {
      const applied = setGeneralInactivityMinutes(inactivityInput.value);
      inactivityInput.value = applied;
    });
  }
  const storageModeSelect = document.getElementById('general_storage_mode');
  if(storageModeSelect){
    storageModeSelect.addEventListener('change', event => setStorageMode(event.target.value));
  }
  const storagePickBtn = document.getElementById('btn_storage_pick_file');
  if(storagePickBtn){
    storagePickBtn.addEventListener('click', handleStorageFilePick);
  }
  const storageFolderBtn = document.getElementById('btn_storage_pick_folder');
  if(storageFolderBtn){
    storageFolderBtn.addEventListener('click', handleStorageFolderPick);
  }
  const storageLoadBtn = document.getElementById('btn_storage_load_file');
  if(storageLoadBtn){
    storageLoadBtn.addEventListener('click', handleStorageFileLoad);
  }
  const storageReconnectBtn = document.getElementById('btn_storage_reconnect');
  if(storageReconnectBtn){
    storageReconnectBtn.addEventListener('click', reconnectPersistedStorage);
  }
  const suspendLoginCheckbox = document.getElementById('general_suspend_login');
  if(suspendLoginCheckbox){
    suspendLoginCheckbox.addEventListener('change', () => setLoginSuspended(suspendLoginCheckbox.checked));
  }
  const welderModal = document.getElementById('welder_modal');
  if(welderModal){
    welderModal.addEventListener('click', event => {
      if(event.target === welderModal){
        closeWelderModal();
      }
    });
  }
  const brandingModal = document.getElementById('branding_modal');
  if(brandingModal){
    brandingModal.addEventListener('click', event => {
      if(event.target === brandingModal){
        closeBrandingModal();
      }
    });
  }
  document.addEventListener('keydown', event => {
    if(event.key !== 'Escape'){
      return;
    }
    if(document.body.dataset.viewerOpen){
      closeDocumentViewer();
      event.preventDefault();
      return;
    }
    if(document.body.dataset.brandingModalOpen){
      closeBrandingModal();
      event.preventDefault();
      return;
    }
    if(document.body.dataset.welderModalOpen){
      closeWelderModal();
      event.preventDefault();
    }
  });
  populateCompanySelector();
  renderCompanySettings();
  updateHomeDashboard();
  const newWelderBtn = document.getElementById('btn_new_welder');
  if(newWelderBtn){
    newWelderBtn.addEventListener('click', () => {
      resetWelderForm();
      openWelderModal('create');
    });
  }
  document.getElementById('btn_save_welder').addEventListener('click', saveWelder);
  const addAuthorizationBtn = document.getElementById('btn_add_authorization');
  if(addAuthorizationBtn){
    addAuthorizationBtn.addEventListener('click', addAuthorization);
  }
  const refreshAuthorizationBtn = document.getElementById('btn_refresh_authorizations');
  if(refreshAuthorizationBtn){
    refreshAuthorizationBtn.addEventListener('click', refreshAllFromStorage);
  }
  const addProcedureBtn = document.getElementById('btn_add_procedure');
  if(addProcedureBtn){
    addProcedureBtn.addEventListener('click', addProcedure);
  }
  const refreshProcedureBtn = document.getElementById('btn_refresh_procedures');
  if(refreshProcedureBtn){
    refreshProcedureBtn.addEventListener('click', refreshAllFromStorage);
  }
  const reportWeldersBtn = document.getElementById('btn_report_welders');
  if(reportWeldersBtn){
    reportWeldersBtn.addEventListener('click', () => {
      setReportsMenuOpen(false);
      generatePdfReport('welders');
    });
  }
  const reportAuthBtn = document.getElementById('btn_report_authorizations');
  if(reportAuthBtn){
    reportAuthBtn.addEventListener('click', () => {
      setReportsMenuOpen(false);
      generatePdfReport('authorizations');
    });
  }
  const reportProceduresBtn = document.getElementById('btn_report_procedures');
  if(reportProceduresBtn){
    reportProceduresBtn.addEventListener('click', () => {
      setReportsMenuOpen(false);
      generatePdfReport('procedures');
    });
  }
  document.getElementById('btn_export_state').addEventListener('click', exportState);
  const importInput = document.getElementById('input_import_state');
  if(importInput){
    importInput.addEventListener('change', handleImportStateFile);
  }
  const importBtn = document.getElementById('btn_import_state');
  if(importBtn){
    importBtn.addEventListener('click', () => {
      if(importInput){
        importInput.click();
      }
    });
  }
  const addCompanyBtn = document.getElementById('btn_add_company');
  if(addCompanyBtn){
    addCompanyBtn.addEventListener('click', handleAddCompany);
  }
  const companySelect = document.getElementById('company_selector');
  if(companySelect){
    companySelect.addEventListener('change', event => {
      const value = event.target.value;
      if(!value){
        return;
      }
      const numeric = Number(value);
      if(Number.isNaN(numeric)){
        return;
      }
      setActiveCompany(numeric);
    });
  }
  const searchInput = document.getElementById('welder_search');
  if(searchInput){
    searchInput.addEventListener('input', event => {
      welderSearchTerm = event.target.value || '';
      loadWelders();
    });
  }
  document.querySelectorAll('.nav-button').forEach(button => {
    button.addEventListener('click', () => {
      const view = button.getAttribute('data-view');
      if(view){
        setActiveView(view);
        setReportsMenuOpen(false);
      }
    });
  });
  const weldersMenuButton = document.getElementById('welders_menu_welders');
  if(weldersMenuButton){
    weldersMenuButton.addEventListener('click', () => setWeldersSubview('welders'));
  }
  const pansoaneMenuButton = document.getElementById('welders_menu_pansoane');
  if(pansoaneMenuButton){
    pansoaneMenuButton.addEventListener('click', () => setWeldersSubview('pansoane'));
  }
  document.querySelectorAll('[data-subview-back]').forEach(button => {
    button.addEventListener('click', () => {
      const target = button.getAttribute('data-subview-back') || 'menu';
      setWeldersSubview(target);
    });
  });
  const manageStandardsBtn = document.getElementById('btn_manage_standards');
  if(manageStandardsBtn){
    manageStandardsBtn.addEventListener('click', () => toggleStandardManager());
  }
  const addStandardBtn = document.getElementById('btn_add_standard');
  if(addStandardBtn){
    addStandardBtn.addEventListener('click', addAuthorizationStandard);
  }
  const closeStandardManagerBtn = document.getElementById('btn_close_standard_manager');
  if(closeStandardManagerBtn){
    closeStandardManagerBtn.addEventListener('click', () => toggleStandardManager(false));
  }
  const authStandardSelect = document.getElementById('auth_standard');
  if(authStandardSelect){
    authStandardSelect.addEventListener('change', updateAuthorizationFieldLabels);
  }
  const authWelderSelect = document.getElementById('auth_welder_select');
  if(authWelderSelect){
    authWelderSelect.addEventListener('change', event => {
      const value = event.target.value;
      if(!value){
        selectAuthorizationWelder(null);
        resetWelderForm();
        return;
      }
      const id = Number(value);
      if(Number.isNaN(id)){
        return;
      }
      selectAuthorizationWelder(id);
    });
  }
  const authProcedureSelect = document.getElementById('auth_procedure_select');
  if(authProcedureSelect){
    authProcedureSelect.addEventListener('change', handleAuthorizationProcedureChange);
  }
  const archiveSearch = document.getElementById('archive_search');
  if(archiveSearch){
    archiveSearch.addEventListener('input', event => {
      archiveSearchTerm = event.target.value || '';
      renderArchiveList();
    });
  }
  const archiveToggle = document.getElementById('toggle_archive');
  if(archiveToggle){
    archiveToggle.addEventListener('click', () => {
      if(archiveToggle.disabled){
        return;
      }
      archiveVisible = !archiveVisible;
      updateArchiveVisibility();
    });
  }
  const pansonToggle = document.getElementById('toggle_panson_archive');
  if(pansonToggle){
    pansonToggle.addEventListener('click', () => {
      if(pansonToggle.disabled){
        return;
      }
      pansonArchiveVisible = !pansonArchiveVisible;
      updatePansonArchiveVisibility();
    });
  }
  const addPansonBtn = document.getElementById('btn_add_panson');
  if(addPansonBtn){
    addPansonBtn.addEventListener('click', addPanson);
  }
  const addWeldingLogRowBtn = document.getElementById('btn_add_welding_log_row');
  if(addWeldingLogRowBtn){
    addWeldingLogRowBtn.addEventListener('click', () => appendWeldingLogRow());
  }
  const previewWeldingLogBtn = document.getElementById('btn_preview_welding_log');
  if(previewWeldingLogBtn){
    previewWeldingLogBtn.addEventListener('click', previewWeldingLogPdf);
  }
  const newAuthDossierBtn = document.getElementById('btn_new_auth_dossier');
  if(newAuthDossierBtn){
    newAuthDossierBtn.addEventListener('click', handleCreateAuthorizationDossier);
  }
  document.querySelectorAll('[data-action="toggle-auth-settings"]').forEach(button => {
    button.addEventListener('click', event => {
      const phase = event.currentTarget ? event.currentTarget.getAttribute('data-phase') : null;
      toggleAuthorizationPhaseSettings(phase === 'final' ? 'final' : 'preliminary');
    });
  });
  const addDossierRowBtn = document.getElementById('btn_add_dossier_row');
  if(addDossierRowBtn){
    addDossierRowBtn.addEventListener('click', handleAddAuthorizationDossierRow);
  }
  const deleteDossierBtn = document.getElementById('btn_delete_auth_dossier');
  if(deleteDossierBtn){
    deleteDossierBtn.addEventListener('click', handleDeleteAuthorizationDossier);
  }
  const previewPreliminaryBtn = document.getElementById('btn_preview_auth_preliminary_pdf');
  if(previewPreliminaryBtn){
    previewPreliminaryBtn.addEventListener('click', previewPreliminaryAuthorizationDossierPdf);
  }
  const previewFinalBtn = document.getElementById('btn_preview_auth_final_pdf');
  if(previewFinalBtn){
    previewFinalBtn.addEventListener('click', previewFinalAuthorizationDossierPdf);
  }
  const saveDossierBtn = document.getElementById('btn_save_auth_dossier_pdf');
  if(saveDossierBtn){
    saveDossierBtn.addEventListener('click', saveAuthorizationDossierPdf);
  }
  const downloadPreliminaryBtn = document.getElementById('btn_download_auth_preliminary_pdf');
  if(downloadPreliminaryBtn){
    downloadPreliminaryBtn.addEventListener('click', downloadPreliminaryAuthorizationDossierPdf);
  }
  const downloadFinalBtn = document.getElementById('btn_download_auth_final_pdf');
  if(downloadFinalBtn){
    downloadFinalBtn.addEventListener('click', downloadFinalAuthorizationDossierPdf);
  }
  const numberingCheckbox = document.getElementById('auth_dossier_page_numbers');
  if(numberingCheckbox){
    numberingCheckbox.addEventListener('change', handleAuthorizationDossierPageNumberToggle);
  }
  const finalNumberingCheckbox = document.getElementById('auth_final_page_numbers');
  if(finalNumberingCheckbox){
    finalNumberingCheckbox.addEventListener('change', handleAuthorizationDossierPageNumberToggle);
  }
  const prelimStartInput = document.getElementById('auth_dossier_start_page');
  if(prelimStartInput){
    prelimStartInput.addEventListener('change', handleAuthorizationDossierStartPageChange);
    prelimStartInput.addEventListener('blur', handleAuthorizationDossierStartPageChange);
  }
  const prelimOffsetInput = document.getElementById('auth_dossier_page_offset');
  if(prelimOffsetInput){
    prelimOffsetInput.addEventListener('change', handleAuthorizationDossierPageOffsetChange);
    prelimOffsetInput.addEventListener('blur', handleAuthorizationDossierPageOffsetChange);
  }
  const finalStartInput = document.getElementById('auth_final_start_page');
  if(finalStartInput){
    finalStartInput.addEventListener('change', handleAuthorizationDossierStartPageChange);
    finalStartInput.addEventListener('blur', handleAuthorizationDossierStartPageChange);
  }
  const finalOffsetInput = document.getElementById('auth_final_page_offset');
  if(finalOffsetInput){
    finalOffsetInput.addEventListener('change', handleAuthorizationDossierPageOffsetChange);
    finalOffsetInput.addEventListener('blur', handleAuthorizationDossierPageOffsetChange);
  }
  const dossierLetterField = document.getElementById('auth_dossier_letter');
  if(dossierLetterField){
    dossierLetterField.addEventListener('input', event => updateAuthorizationDossierLetter(event.target.value));
  }
  const finalLetterField = document.getElementById('auth_final_letter');
  if(finalLetterField){
    finalLetterField.addEventListener('input', event => updateFinalPhaseLetter(event.target.value));
  }
  const editPreliminaryLetterBtn = document.getElementById('btn_edit_preliminary_letter');
  if(editPreliminaryLetterBtn){
    editPreliminaryLetterBtn.addEventListener('click', () => openAuthorizationLetterEditor('preliminary'));
  }
  const editFinalLetterBtn = document.getElementById('btn_edit_final_letter');
  if(editFinalLetterBtn){
    editFinalLetterBtn.addEventListener('click', () => openAuthorizationLetterEditor('final'));
  }
  const previewPreliminaryLetterBtn = document.getElementById('btn_preview_preliminary_letter_pdf');
  if(previewPreliminaryLetterBtn){
    previewPreliminaryLetterBtn.addEventListener('click', () => previewAuthorizationLetterPdf('preliminary'));
  }
  const previewFinalLetterBtn = document.getElementById('btn_preview_final_letter_pdf');
  if(previewFinalLetterBtn){
    previewFinalLetterBtn.addEventListener('click', () => previewAuthorizationLetterPdf('final'));
  }
  const preliminaryPhaseToggle = document.getElementById('auth_phase_preliminary_closed');
  if(preliminaryPhaseToggle){
    preliminaryPhaseToggle.addEventListener('change', event => updateAuthorizationDossierPhaseStatus('preliminary', event.target.checked));
  }
  const finalPhaseToggle = document.getElementById('auth_phase_final_closed');
  if(finalPhaseToggle){
    finalPhaseToggle.addEventListener('change', event => updateAuthorizationDossierPhaseStatus('final', event.target.checked));
  }
  const addCustomStepBtn = document.getElementById('btn_add_custom_step');
  if(addCustomStepBtn){
    addCustomStepBtn.addEventListener('click', handleAddCustomStep);
  }
  const customStepsList = document.getElementById('auth_custom_steps_list');
  if(customStepsList){
    customStepsList.addEventListener('click', handleCustomStepClick);
    customStepsList.addEventListener('change', handleCustomStepFileChange);
  }
  const addFinalCustomStepBtn = document.getElementById('btn_add_final_custom_step');
  if(addFinalCustomStepBtn){
    addFinalCustomStepBtn.addEventListener('click', handleAddFinalCustomStep);
  }
  const finalCustomStepsList = document.getElementById('auth_final_custom_steps_list');
  if(finalCustomStepsList){
    finalCustomStepsList.addEventListener('click', handleFinalCustomStepClick);
    finalCustomStepsList.addEventListener('change', handleFinalCustomStepFileChange);
  }
  const addBaseMaterialBtn = document.getElementById('btn_add_base_material_doc');
  if(addBaseMaterialBtn){
    addBaseMaterialBtn.addEventListener('click', () => handleAddMaterialDoc('base'));
  }
  const addFillerMaterialBtn = document.getElementById('btn_add_filler_material_doc');
  if(addFillerMaterialBtn){
    addFillerMaterialBtn.addEventListener('click', () => handleAddMaterialDoc('filler'));
  }
  const finalLabButton = document.getElementById('btn_add_final_lab_doc');
  const finalLabInput = document.getElementById('auth_final_lab_file');
  if(finalLabButton && finalLabInput){
    finalLabButton.addEventListener('click', () => finalLabInput.click());
    finalLabInput.addEventListener('change', () => {
      if(finalLabInput.files && finalLabInput.files[0]){
        addFinalPhaseGeneralDoc('labAuthorizations', finalLabInput.files[0]);
      }
      finalLabInput.value = '';
    });
  }
  const finalInspectorButton = document.getElementById('btn_add_final_inspector_doc');
  const finalInspectorInput = document.getElementById('auth_final_inspector_file');
  if(finalInspectorButton && finalInspectorInput){
    finalInspectorButton.addEventListener('click', () => finalInspectorInput.click());
    finalInspectorInput.addEventListener('change', () => {
      if(finalInspectorInput.files && finalInspectorInput.files[0]){
        addFinalPhaseGeneralDoc('inspectorReports', finalInspectorInput.files[0]);
      }
      finalInspectorInput.value = '';
    });
  }
  const addProcDocBtn = document.getElementById('btn_add_proc_dossier');
  if(addProcDocBtn){
    addProcDocBtn.addEventListener('click', addProcedureDossierDocument);
  }
  const refreshProcDocBtn = document.getElementById('btn_refresh_proc_dossier');
  if(refreshProcDocBtn){
    refreshProcDocBtn.addEventListener('click', () => loadProcedureDossier());
  }
  const pansonSelect = document.getElementById('w_panson');
  if(pansonSelect){
    pansonSelect.addEventListener('change', event => {
      const value = event.target.value;
      const manualInput = document.getElementById('w_code_manual');
      if(!manualInput){
        return;
      }
      if(!value){
        return;
      }
      const company = getActiveCompany();
      const panson = company.pansoane.find(entry => entry && String(entry.id) === String(value));
      if(panson && panson.code){
        manualInput.value = panson.code;
      }
    });
  }
  window.addEventListener('message', handleAuthorizationLetterEditorMessage);
  renderAuthStandardTabs();
  renderStandardManagerList();
  initSubTabs('auth_tabs');
  initSubTabs('proc_tabs');
  resetWelderForm();
  loadWelders();
  loadProcedures();
  loadPansoane();
  populateAuthorizationWelderSelect();
  populateAuthorizationProcedureSelect();
  populateProcedureWelderSelect();
  populatePansonSelect();
  updateAuthorizationContext();
  renderArchiveList();
  updatePansonArchiveVisibility();
  setActiveView('home');
  updateTopbarCompanyLogo();
  loadAuthorizationDossier();
  loadProcedureDossier();
});

window.addEventListener('storage', event => {
  if(event.key === STORAGE_KEY || event.key === STORAGE_CONFIG_KEY){
    refreshAllFromStorage();
  }
});
</script>
</body>
</html>
